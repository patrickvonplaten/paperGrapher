{"version":3,"file":"chunks/components_GraphSurface_2efa4bfc17d7c37cd4285e4adb055066-b1c743d8e5183243328b.js","sources":["webpack:///components/GraphSurface.js","webpack:///./node_modules/react-sigma/es/EdgeShapes.js","webpack:///./node_modules/react-sigma/es/Filter.js","webpack:///./node_modules/react-sigma/es/ForceAtlas2.js","webpack:///./node_modules/react-sigma/es/LoadGEXF.js","webpack:///./node_modules/react-sigma/es/LoadJSON.js","webpack:///./node_modules/react-sigma/es/NOverlap.js","webpack:///./node_modules/react-sigma/es/NeoCypher.js","webpack:///./node_modules/react-sigma/es/NeoGraphItemsProducers.js","webpack:///./node_modules/react-sigma/es/NodeShapes.js","webpack:///./node_modules/react-sigma/es/RandomizeNodePositions.js","webpack:///./node_modules/react-sigma/es/ReactSigmaLayoutPlugin.js","webpack:///./node_modules/react-sigma/es/RelativeSize.js","webpack:///./node_modules/react-sigma/es/Sigma.js","webpack:///./node_modules/react-sigma/es/SigmaEnableSVG.js","webpack:///./node_modules/react-sigma/es/SigmaEnableWebGL.js","webpack:///./node_modules/react-sigma/es/Utils.js","webpack:///./node_modules/react-sigma/es/index.js","webpack:///./node_modules/react-sigma/es/tools.js","webpack:///./node_modules/react-sigma/sigma/edges.js","webpack:///./node_modules/react-sigma/sigma/layout.forceAtlas2.js","webpack:///./node_modules/react-sigma/sigma/layout.noverlap.js","webpack:///./node_modules/react-sigma/sigma/main.js","webpack:///./node_modules/react-sigma/sigma/neo4j.cypher.js","webpack:///./node_modules/react-sigma/sigma/nodes.js","webpack:///./node_modules/react-sigma/sigma/parsers.gexf.js","webpack:///./node_modules/react-sigma/sigma/parsers.json.js","webpack:///./node_modules/react-sigma/sigma/plugins.animate.js","webpack:///./node_modules/react-sigma/sigma/plugins.filter.js","webpack:///./node_modules/react-sigma/sigma/plugins.relativeSize.js","webpack:///./node_modules/react-sigma/sigma/svg.js","webpack:///./node_modules/react-sigma/sigma/webgl.js"],"sourcesContent":["if (typeof window !== 'undefined') { \n  const { Sigma, RandomizeNodePositions, RelativeSize } = require('react-sigma');\n}\n\n\nexport default class GraphSurface extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      searchResult: this.props.searchResult,\n      sigmaIsLoaded: typeof window !== 'undefined'\n    };\n  }\n\n  componentDidMount() {\n    console.log(typeof window)\n    const { Sigma, RandomizeNodePositions, RelativeSize } = require('react-sigma');\n    this.setState({sigmaIsLoaded: true})\n  }\n\n  render() {\n    console.log(\"SearchObject\", this.state.searchResult)\n\n    let myGraph = { nodes: [{ id: \"n1\", label: \"Alice\" }, { id: \"n2\", label: \"Rabbit\" }], edges: [{ id: \"e1\", source: \"n1\", target: \"n2\", label: \"SEES\" }] };\n\n\n    return (\n      typeof window !== 'undefined' ? (\n        <div>\n          <div> SearchObject </div>\n          <Sigma graph={myGraph} settings={{ drawEdges: true, clone: false }}>\n            <RelativeSize initialSize={15} />\n            <RandomizeNodePositions />\n          </Sigma>\n          <div> {this.state.searchResult.title} </div>\n        </div>\n      ) : null\n    );\n  }\n}\n\n\n// WEBPACK FOOTER //\n// components/GraphSurface.js","import React from 'react';\nimport '../sigma/edges';\n\n/**\n\nEdgeShapes component, interface for customEdgeShapes sigma plugin.\nIt supposes that sigma graph is already in place, therefore component should not be\nmounted until graph is available. It can be used within Sigma component if graph is\npreloaded, or within loader component, like LoadJSON.\n\nNote! this Component requires \"canvas\" renderer to work.\n\nTo assign a shape renderer to an edge, simply set edge.type='shape-name' e.g. edge.type='dotted'.\n```\n<Sigma renderer=\"canvas\" graph={{nodes:[\"id0\", \"id1\"], edges:[{id:\"e0\",source:\"id0\",target:\"id1\"}]}}>\n\t<EdgeShapes default=\"dotted\"/>\n</Sigma>\n```\n\nSupported shapes\n```\ntype Sigma$Edge$Shapes = \"line\" | \"arrow\" | \"curve\" | \"curvedArrow\" | \"dashed\" | \"dotted\" | \"parallel\" | \"tapered\";\n```\n\nSee [plugin page](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.renderers.customEdgeShapes)\nfor more datails on implementation.\n\n@param {string} default  set default sigma edge to be applied to edges where type is not set\n\n**/\n\nclass EdgeShapes extends React.Component {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.render = () => null;\n\n\t\tif (this.props.sigma && this.props.default) this.props.sigma.settings({ defaultEdgeType: this.props.default });\n\t}\n\n}\n\nEdgeShapes.propTypes = {\n\tdefault: typeof Sigma$Edge$Shapes === 'function' ? require('prop-types').instanceOf(Sigma$Edge$Shapes) : require('prop-types').any,\n\tsigma: typeof Sigma === 'function' ? require('prop-types').instanceOf(Sigma) : require('prop-types').any\n};\nexport default EdgeShapes;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/EdgeShapes.js\n// module id = ./node_modules/react-sigma/es/EdgeShapes.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/plugins.filter';\n\n/**\n\nFilter component, interface for filter sigma plugin.\nIt supposes that sigma graph is already in place, therefore component should not be\nmounted until graph is available. It can be used within Sigma component if graph is\npreloaded, or within loader component, like NeoCypher.\n\nFilter is hiding all nodes which do not apply to the provided nodesBy criteria.\n\n@param {Nodes$Filter} nodesBy   will hide nodes where filter returns false\n\ntype Nodes$Filter = (node: Sigma$Node) => boolean;\n\n\n**/\n\nclass Filter extends React.Component {\n\tconstructor(...args) {\n\t\tvar _temp;\n\n\t\treturn _temp = super(...args), this.render = () => null, _temp;\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.filter = new sigma.plugins.filter(this.props.sigma);\n\t\tthis._apply(this.props);\n\t}\n\n\t// TODO: will it work in composition with ForceAtlas for instance?\n\t//It should hide nodes before rendering of subplugins, therefore used in componentWillUpdate.. is it right?\n\tcomponentWillUpdate(props) {\n\t\tif (props.nodesBy !== this.props.nodesBy || props.neighborsOf !== this.props.neighborsOf) this._apply(props);\n\t}\n\n\t// TODO: Composition is not working yet!!\n\n\n\t_apply(props) {\n\t\tthis.filter.undo([\"neighborsOf\", \"nodesBy\"]);\n\t\tif (props.neighborsOf) {\n\t\t\tthis.filter.neighborsOf(props.neighborsOf, \"neighborsOf\");\n\t\t}\n\t\tif (props.nodesBy) this.filter.nodesBy(props.nodesBy, \"nodesBy\");\n\t\tthis.filter.apply();\n\t\tif (this.props.sigma) this.props.sigma.refresh();\n\t}\n}\n\nFilter.propTypes = {\n\tnodesBy: typeof Nodes$Filter === 'function' ? require('prop-types').instanceOf(Nodes$Filter) : require('prop-types').any,\n\tneighborsOf: require('prop-types').string,\n\tsigma: typeof Sigma === 'function' ? require('prop-types').instanceOf(Sigma) : require('prop-types').any\n};\nexport default Filter;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/Filter.js\n// module id = ./node_modules/react-sigma/es/Filter.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/layout.forceAtlas2';\nimport { embedProps } from './tools';\n\n/**\n\nForceAtlas2 component, starts ForceAtlas2 sigma plugin once component is mounted.\nIt supposes that sigma graph is already in place, therefore component should not be\nmounted while graph is unavailable. It can be used within Sigma component if graph is\npreloaded, or within loader component, like NeoCypher.\n\nIt accepts all the parameters of ForceAtlas2 described on its github page:\n@param {boolean} [worker=true]           Use a web worker to run calculations in separate thread\n@param {boolean} barnesHutOptimize  Use the algorithm's Barnes-Hut to improve repulsion's scalability\n\t\t\t\t\t\t\t\t\tThis is useful for large graph but harmful to small ones.\n@param {number} barnesHutTheta\n@param {boolean} adjustSizes\n@param {number} iterationsPerRender\n@param {boolean} [linLogMode=true]\n@param {boolean} outboundAttractionDistribution\n@param {number} edgeWeightInfluence\n@param {number} scalingRatio\n@param {boolean} strongGravityMode\n@param {number} gravity\n@param {number} slowDown\n@param {number} timeout   how long algorythm should run. default=graph.nodes().length * 10\n\n[see sigma plugin page for more details](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.forceAtlas2)\n\n**/\n\nclass ForceAtlas2 extends React.Component {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = { running: false };\n\t}\n\n\tcomponentDidMount() {\n\t\tthis._refreshGraph();\n\t}\n\n\tcomponentDidUpdate(prevProps, prevState) {\n\t\tlet s = this.props.sigma;\n\t\tif (prevState.running && !this.state.running && s) {\n\t\t\ts.stopForceAtlas2();\n\t\t\ts.settings({ drawEdges: prevState.drawEdges === false ? false : true });\n\t\t\ts.refresh();\n\t\t}\n\t}\n\n\tcomponentWillUnmount() {\n\t\tif (this.props.sigma) this.props.sigma.killForceAtlas2();\n\t\tif (this.state.timer) clearTimeout(this.state.timer);\n\t}\n\n\trender() {\n\t\tif (!this.state.running) {\n\t\t\treturn React.createElement(\n\t\t\t\t'div',\n\t\t\t\tnull,\n\t\t\t\tembedProps(this.props.children, { sigma: this.props.sigma })\n\t\t\t);\n\t\t}\n\t\treturn null;\n\t}\n\n\t_refreshGraph() {\n\t\tlet s = this.props.sigma;\n\t\tif (!sigma || !s) return;\n\n\t\tlet drawEdges = s.settings(\"drawEdges\");\n\t\tif (s.graph.edges().length > 1000) s.settings({ drawEdges: false });\n\n\t\ts.startForceAtlas2(this._stripOptions(this.props));\n\t\t// TODO: convert running status to state\n\t\tlet timer = setTimeout(() => {\n\t\t\tthis.setState({ running: false, timer: undefined });\n\t\t}, this.props.timeout || s.graph.nodes().length * 8);\n\t\tthis.setState({ running: true, timer, drawEdges });\n\t}\n\n\t//strip force atlas options from component props\n\t_stripOptions(props) {\n\t\treturn Object.assign({}, props, {\n\t\t\tsigma: undefined,\n\t\t\tchildren: undefined\n\t\t});\n\t}\n\n}\n\nForceAtlas2.defaultProps = {\n\tworker: true,\n\tlinLogMode: true\n};\nForceAtlas2.propTypes = {\n\tworker: require('prop-types').bool.isRequired,\n\tbarnesHutOptimize: require('prop-types').bool,\n\tbarnesHutTheta: require('prop-types').number,\n\tadjustSizes: require('prop-types').bool,\n\titerationsPerRender: require('prop-types').number,\n\tlinLogMode: require('prop-types').bool.isRequired,\n\toutboundAttractionDistribution: require('prop-types').bool,\n\tedgeWeightInfluence: require('prop-types').number,\n\tscalingRatio: require('prop-types').number,\n\tstrongGravityMode: require('prop-types').bool,\n\tslowDown: require('prop-types').number,\n\tgravity: require('prop-types').number,\n\ttimeout: require('prop-types').number,\n\tsigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any,\n\tchildren: require('prop-types').any\n};\nexport default ForceAtlas2;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/ForceAtlas2.js\n// module id = ./node_modules/react-sigma/es/ForceAtlas2.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/parsers.gexf';\nimport { embedProps } from './tools';\n\n/**\n\nLoadGEXF component, interface for parsers.json sigma plugin. Can be used within Sigma component.\nCan be composed with other plugins: on load it mounts all child components (e.g. other sigma plugins).\nChild's componentWillMount should be used to enable plugins on loaded graph.\n\n @param {string} path   path to the GEXF file\n @param {Function} onGraphLoaded        Optional callback for graph update\n\n[see sigma plugin page for more details](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.neo4j.cypher)\n\n**/\n\nclass LoadGEXF extends React.PureComponent {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.onLoad = () => {\n\t\t\tif (this.props.sigma) this.props.sigma.refresh();\n\t\t\tthis.setState({ loaded: true });\n\t\t\tif (this.props.onGraphLoaded) return this.props.onGraphLoaded();\n\t\t};\n\n\t\tthis.state = { loaded: false };\n\t}\n\n\tcomponentDidMount() {\n\t\tthis._load(this.props.path);\n\t}\n\n\tcomponentWillReceiveProps(props) {\n\t\t// reload only if path changes\n\t\tif (this.props.path !== props.path) {\n\t\t\tthis.setState({ loaded: false });\n\t\t\tthis._load(props.path);\n\t\t}\n\t}\n\n\trender() {\n\t\tif (!this.state.loaded) return null;\n\t\treturn React.createElement(\n\t\t\t'div',\n\t\t\tnull,\n\t\t\tembedProps(this.props.children, { sigma: this.props.sigma })\n\t\t);\n\t}\n\n\t_load(url) {\n\t\tsigma.parsers.gexf(this.props.path, this.props.sigma, this.onLoad);\n\t}\n}\n\nLoadGEXF.propTypes = {\n\tpath: require('prop-types').string.isRequired,\n\tonGraphLoaded: require('prop-types').func,\n\tchildren: require('prop-types').any,\n\tsigma: typeof Sigma === 'function' ? require('prop-types').instanceOf(Sigma) : require('prop-types').any\n};\nexport default LoadGEXF;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/LoadGEXF.js\n// module id = ./node_modules/react-sigma/es/LoadGEXF.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/main.js';\nimport '../sigma/parsers.json.js';\nimport { embedProps } from './tools';\n\n// TODO: make a superclass for loaders??\n\n/**\n\nLoadJSON component, interface for parsers.json sigma plugin. Can be used within Sigma component.\nCan be composed with other plugins: on load it mounts all child components (e.g. other sigma plugins).\nChild's componentWillMount should be used to enable plugins on loaded graph.\n\n @param {string} path   path to the JSON file\n @param {Function} onGraphLoaded        Optional callback for graph update\n\n[see sigma plugin page for more details](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.neo4j.cypher)\n\n**/\n\nclass LoadJSON extends React.PureComponent {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.onLoad = () => {\n\t\t\tif (this.props.sigma) this.props.sigma.refresh();\n\t\t\tthis.setState({ loaded: true });\n\t\t\tif (this.props.onGraphLoaded) return this.props.onGraphLoaded();\n\t\t};\n\n\t\tthis.state = { loaded: false };\n\t}\n\n\tcomponentDidMount() {\n\t\tthis._load(this.props.path);\n\t}\n\n\tcomponentWillReceiveProps(props) {\n\t\t// reload only if path changes\n\t\tif (this.props.path !== props.path) {\n\t\t\tthis.setState({ loaded: false });\n\t\t\tthis._load(props.path);\n\t\t}\n\t}\n\n\trender() {\n\t\tif (!this.state.loaded) return null;\n\t\treturn React.createElement(\n\t\t\t'div',\n\t\t\tnull,\n\t\t\tembedProps(this.props.children, { sigma: this.props.sigma })\n\t\t);\n\t}\n\n\t_load(url) {\n\t\tsigma.parsers.json(this.props.path, this.props.sigma, this.onLoad);\n\t}\n}\n\nLoadJSON.propTypes = {\n\tpath: require('prop-types').string.isRequired,\n\tonGraphLoaded: require('prop-types').func,\n\tchildren: require('prop-types').any,\n\tsigma: typeof Sigma === 'function' ? require('prop-types').instanceOf(Sigma) : require('prop-types').any\n};\nexport default LoadJSON;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/LoadJSON.js\n// module id = ./node_modules/react-sigma/es/LoadJSON.js\n// module chunks = 4","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport React from 'react';\nimport '../sigma/plugins.animate';\nimport '../sigma/layout.noverlap';\nimport ReactSigmaLayoutPlugin from './ReactSigmaLayoutPlugin';\n\n/**\n\nNOverlap component, starts noverlap sigma plugin once component is mounted.\nIt supposes that sigma graph is already in place, therefore component should not be\nmounted while graph is unavailable. It can be used within Sigma component if graph is\npreloaded, or within loader component, like LoadJSON.\n\n@param {number} [nodeMargin=5]    additional minimum space to apply around each and every node\n@param {number} [scaleNodes=1.2]  multiplier,  larger nodes will have more space around\n@param {number} [gridSize=20]   number of rows and columns to use when dividing the nodes up into cell\n@param {number} [permittedExpansion=1.1]  maximum ratio to apply to the bounding box\n@param {number} speed     larger value increases the speed at the cost of precision\n@param {number} maxIterations  iterations to run the algorithm for before stopping it\n@param {number} easing     camera easing type for camera transition\n@param {number} duration     duration of the transition for the easing method\n\nIt accepts all the parameters of sigma.layout.noverlap plugin described on its github page:\n[see sigma plugin page for more details](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.noverlap)\n\n@example\n<Sigma graph={data}>\n <NOverlap gridSize={10} maxIterations={100}/>\n</Sigma>\n\n**/\n\nconst NOverlap = props => {\n\tconst s = props.sigma;\n\tif (s) return React.createElement(ReactSigmaLayoutPlugin, _extends({\n\t\tstart: () => s.startNoverlap(),\n\t\tconfig: options => s.configNoverlap(options),\n\t\tstop: () => !!s && !!s.stopNoverlap && s.stopNoverlap() }, props));\n\treturn null;\n};\n\nNOverlap.propTypes = {\n\tnodes: require('prop-types').arrayOf(typeof Sigma$Node === 'function' ? require('prop-types').instanceOf(Sigma$Node) : require('prop-types').any),\n\tnodeMargin: require('prop-types').number,\n\tscaleNodes: require('prop-types').number,\n\tgridSize: require('prop-types').number,\n\tpermittedExpansion: require('prop-types').number,\n\tspeed: require('prop-types').number,\n\tmaxIterations: require('prop-types').number,\n\teasing: typeof Sigma$Easing === 'function' ? require('prop-types').instanceOf(Sigma$Easing) : require('prop-types').any,\n\tduration: require('prop-types').number,\n\tsigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any\n};\nexport default NOverlap;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/NOverlap.js\n// module id = ./node_modules/react-sigma/es/NOverlap.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/parsers.json.js';\nimport '../sigma/neo4j.cypher';\nimport NeoGraphItemsProducers from './NeoGraphItemsProducers';\nimport { embedProps } from './tools';\n\n;\n\n\n/**\n\nNeoCypher component, interface for neo4j.cypher sigma plugin. Can be used within Sigma component.\nCan be composed with other plugins: on load it mounts all child components (e.g. other sigma plugins).\nChild's componentWillMount should be used to enable plugins on loaded graph.\n\n @param {string} url    Neo4j instance REST API URL\n @param {string} user    Neo4j instance REST API user\n @param {string} password    Neo4j instance REST API password\n @param {string} query    Neo4j cypher query\n @param {NeoGraphItemsProducers} producers   Optional transformer for creating Sigma nodes and edges,\n                                    instance compatible with NeoGraphItemsProducers\n @param {Function} onGraphLoaded        Optional callback for graph update\n\n[see sigma plugin page for more details](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.neo4j.cypher)\n\n**/\n\nclass NeoCypher extends React.PureComponent {\n\n    constructor(props) {\n        super(props);\n\n        this.onLoad = () => {\n            this.setState({ loaded: true });\n            if (this.props.sigma) this.props.sigma.refresh();\n            if (this.props.onGraphLoaded) return this.props.onGraphLoaded();\n        };\n\n        this.state = { loaded: false };\n    }\n\n    componentDidMount() {\n        this._runQuery(this.props.query);\n    }\n\n    componentWillUpdate(props) {\n        // suppose url, user or password won't change for sigma instance, as well as sigma instance itself\n        if (this.props.query !== props.query) {\n            this.setState({ loaded: false });\n            this._runQuery(props.query);\n        }\n    }\n\n    render() {\n        if (!this.state.loaded) return null;\n        return React.createElement(\n            'div',\n            null,\n            embedProps(this.props.children, { sigma: this.props.sigma })\n        );\n    }\n\n    _runQuery(query) {\n        // TODO: add exception handling capability to Sigma Neo4j plugin\n        sigma.neo4j.cypher({ url: this.props.url, user: this.props.user, password: this.props.password }, query, this.props.sigma, this.onLoad, this.props.producers);\n    }\n}\n\nNeoCypher.defaultProps = {\n    producers: new NeoGraphItemsProducers()\n};\nNeoCypher.propTypes = {\n    url: require('prop-types').string.isRequired,\n    user: require('prop-types').string.isRequired,\n    password: require('prop-types').string.isRequired,\n    query: require('prop-types').string.isRequired,\n    producers: typeof ProducersInterface === 'function' ? require('prop-types').instanceOf(ProducersInterface).isRequired : require('prop-types').any.isRequired,\n    onGraphLoaded: require('prop-types').func,\n    children: require('prop-types').any,\n    sigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any\n};\nexport default NeoCypher;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/NeoCypher.js\n// module id = ./node_modules/react-sigma/es/NeoCypher.js\n// module chunks = 4","const palette = [\"#5DA5DA\", \"#60BD68\", \"#B2912F\", \"#F15854\", \"#DECF3F\", \"#FAA43A\", \"#B276B2\", \"#F17CB0\", \"#4D4D4D\"];\n\n/*\n\tDefault node and edge transformation for NeoCypher,\n\tclass has 2 functions: node() and edge() which transform data from Neo4j format into Sigma.\n\n\tAlso it iterates colors assignments from palette based on node.label and edge.type.\n*/\n\nclass NeoGraphItemsProducers {\n\tconstructor() {\n\t\tthis._currentColor = 0;\n\t\tthis._colorsMap = {};\n\t}\n\tnode(node) {\n\t\treturn {\n\t\t\tid: node.id,\n\t\t\tlabel: node.properties.name,\n\t\t\tx: Math.random(),\n\t\t\ty: Math.random(),\n\t\t\tsize: 1,\n\t\t\tcolor: this.colorsMap(node.labels[0]),\n\t\t\tneo4j_labels: node.labels,\n\t\t\tneo4j_data: node.properties\n\t\t};\n\t}\n\tedge(edge) {\n\t\treturn {\n\t\t\tid: edge.id,\n\t\t\tlabel: edge.type,\n\t\t\tsource: edge.startNode,\n\t\t\ttarget: edge.endNode,\n\t\t\tcolor: this.colorsMap(edge.type),\n\t\t\tneo4j_type: edge.type,\n\t\t\tneo4j_data: edge.properties\n\t\t};\n\t}\n\tcolorsMap(label) {\n\t\tlet color = this._colorsMap[label];\n\t\tif (!color) {\n\t\t\tcolor = palette[this._currentColor++ % palette.length];\n\t\t\tthis._colorsMap[label] = color;\n\t\t}\n\t\treturn color;\n\t}\n}\n\nexport default NeoGraphItemsProducers;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/NeoGraphItemsProducers.js\n// module id = ./node_modules/react-sigma/es/NeoGraphItemsProducers.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/nodes';\n\n/**\n\nNodeShapes component, interface for customShapes sigma plugin.\nIt supposes that sigma graph is already in place, therefore component should not be\nmounted until graph is available. It can be used within Sigma component if graph is\npreloaded, or within loader component, like LoadJSON.\n\nNote! this Component requires \"canvas\" renderer to work.\n\nExtra node properties:\n - node.type='shape-name' - node shape renderer e.g. node.type='cross'.\n - node.borderColor - e.g. node.borderColor='#FF3333'\nDetails on shapes configuration and possibility to apply images to nodes, please refer to\n[plugin page](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.renderers.customShapes#images).\n\nSee [plugin page](https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.renderers.customEdgeShapes)\nfor more datails on implementation.\n\n@param {string} default  set default sigma node renderer to be applied to nodes where type is not set\n\n\n@example\n```\n<Sigma renderer=\"canvas\" graph={{nodes:[\"id0\", \"id1\"], edges:[{id:\"e0\",source:\"id0\",target:\"id1\"}]}}>\n\t<NodeShapes default=\"star\"/>\n</Sigma>\n```\n\n@example\nSupported shapes\n```\ntype Sigma$Node$Shapes = \"def\" | \"pacman\" | \"star\" | \"equilateral\" | \"cross\" | \"diamond\" | \"circle\" | \"square\";\n```\n\n**/\n\nclass NodeShapes extends React.Component {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.render = () => null;\n\n\t\tif (this.props.sigma && this.props.default) this.props.sigma.settings({ defaultNodeType: this.props.default });\n\t}\n\n}\n\nNodeShapes.propTypes = {\n\tdefault: typeof Sigma$Node$Shapes === 'function' ? require('prop-types').instanceOf(Sigma$Node$Shapes) : require('prop-types').any,\n\tsigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any\n};\nexport default NodeShapes;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/NodeShapes.js\n// module id = ./node_modules/react-sigma/es/NodeShapes.js\n// module chunks = 4","import React from 'react';\nimport { embedProps } from './tools';\n\n/**\n\nRandomizeNodePositions component, sets random positions to all nodes.\nCan be used within Sigma component with predefined graph or within graph loader component.\n\n**/\n\nclass RandomizeNodePositions extends React.PureComponent {\n\n  constructor(props) {\n    super(props);\n    if (this.props.sigma) {\n      this.props.sigma.graph.nodes().forEach(n => {\n        n.x = Math.random();\n        n.y = Math.random();\n      });\n    }\n    if (this.props.sigma) this.props.sigma.refresh();\n  }\n\n  componentDidMount() {\n    if (this.props.sigma) this.props.sigma.refresh();\n  }\n\n  render() {\n    return React.createElement(\n      'div',\n      null,\n      embedProps(this.props.children, { sigma: this.props.sigma })\n    );\n  }\n\n}\n\nRandomizeNodePositions.propTypes = {\n  children: require('prop-types').any,\n  sigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any\n};\nexport default RandomizeNodePositions;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/RandomizeNodePositions.js\n// module id = ./node_modules/react-sigma/es/RandomizeNodePositions.js\n// module chunks = 4","import React from 'react';\nimport * as Utils from './Utils';\n\n/**\n\nReactSigmaLayoutPlugin is a base class for sigma plugins.\n\nUsage\n```\nconst NOverlap = (props: Props) => {\n\t\t\t\tconst s = props.sigma\n\t\t\t\tif(s)\n          return <ReactSigmaLayoutPlugin\n              start={()=>s.startNoverlap()}\n              config={options=>s.configNoverlap(options)}\n              stop={s.stopNoverlap()} {...props} />\n\t\t\t\treturn null\n\t\t\t}\n...\n<NOverlap easing=\"cubicInOut\"/>\n```\n**/\n\nclass ReactSigmaLayoutPlugin extends React.Component {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis._mounted = false;\n\n\t\tthis.render = () => null;\n\n\t\tthis.state = { running: false };\n\t}\n\n\tcomponentDidMount() {\n\t\tthis._start();\n\t\tthis._mounted = true;\n\t}\n\n\t// Change sigma status only after react rendering complete\n\tcomponentDidUpdate(prevProps, prevState) {\n\t\tif (prevState.running && !this.state.running && this._mounted) {\n\t\t\tif (this.props.sigma) this.props.sigma.refresh();\n\t\t} else if (Utils.propsChanged(prevProps, this.props)) {\n\t\t\tthis.props.stop();\n\t\t\tthis._start();\n\t\t}\n\t}\n\n\tcomponentWillUnmount() {\n\t\tthis._mounted = false;\n\t\tthis.props.stop();\n\t}\n\n\t//TODO: Render composition of child components after animation\n\n\n\t_start() {\n\t\tthis.props.config(ReactSigmaLayoutPlugin._stripOptions(this.props));\n\t\tlet listener = this.props.start();\n\n\t\tlistener.bind('stop', () => {\n\t\t\tthis._mounted && this.setState({ running: false });\n\t\t});\n\n\t\tthis.setState({ running: true });\n\t}\n\n\tstatic _stripOptions(props) {\n\t\tlet config = {};\n\t\tfor (let key in props) if (key !== \"start\" && key !== \"stop\" && key !== \"config\" && key !== \"sigma\" && key !== \"children\") config[key] = props[key];\n\t\treturn config;\n\t}\n}\n\nReactSigmaLayoutPlugin.propTypes = {\n\tconfig: require('prop-types').func.isRequired,\n\tstart: require('prop-types').func.isRequired,\n\tstop: require('prop-types').func.isRequired,\n\tsigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any\n};\nexport default ReactSigmaLayoutPlugin;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/ReactSigmaLayoutPlugin.js\n// module id = ./node_modules/react-sigma/es/ReactSigmaLayoutPlugin.js\n// module chunks = 4","import React from 'react';\nimport '../sigma/plugins.relativeSize';\n\n/**\n\nRelativeSize component, interface for RelativeSize sigma plugin.\nIt supposes that sigma graph is already in place, therefore component should not be\nmounted until graph is available. It can be used within Sigma component if graph is\npreloaded, or within loader component, like NeoCypher.\n\nSets nodes sizes corresponding its degree.\n\n @param {number} initialSize  start size for every node, will be multiplied by Math.sqrt(node.degree)\n\n**/\n\nclass RelativeSize extends React.Component {\n\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.render = () => null;\n\n\t\tsigma.plugins.relativeSize(this.props.sigma, this.props.initialSize);\n\t}\n\n}\n\nRelativeSize.propTypes = {\n\tinitialSize: require('prop-types').number.isRequired,\n\tsigma: typeof sigma === 'function' ? require('prop-types').instanceOf(sigma) : require('prop-types').any\n};\nexport default RelativeSize;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/RelativeSize.js\n// module id = ./node_modules/react-sigma/es/RelativeSize.js\n// module chunks = 4","import React from 'react';\nimport { embedProps } from './tools';\nimport '../sigma/main';\n\n/**\n *\n * Sigma - React.JS flow-typed interface for Sigma js library - fastest opensource rendering engine for network graphs.\n * Sigma makes it easy to publish networks on Web pages, and allows developers to integrate network exploration in\n * rich Web applications.\n *\n * Parameter types\n * ```\n * type Sigma$Graph$Data = {\n *   nodes: [Sigma$Node],\n *   edges: [Sigma$Edge]\n * };\n *\n * type Sigma$Node = {\n *   id: string,\n *   label?: string,\n *   x?: number,\n *   y?: number,\n *   size?: number,\n *   color?: color\n * };\n *\n * type Sigma$Edge = {\n *   id: string,\n *   source: string,\n *   target: string,\n *   label?: string,\n *   color?: color\n * };\n * ```\n *\n *\n * @signature `<Sigma graph={graph} settings={settings} onClickNode={func}.../>`\n *\n * @param {CSS} style   CSS style description for main div holding graph, should be specified in React format\n * @param {Sigma$Settings} settings     js object with sigma initialization options, for full list see [sigma settings page](https://github.com/jacomyal/sigma.js/wiki/Settings)\n * @param {string} renderer     can be \"webgl\" or \"canvas\"\n * @param {Sigma$Graph$Data} graph   js object with array of nodes and edges used to initialize sigma\n * @param {Sigma$ErrorHandler} onSigmaException      set sigma callback for sigma exceptions / errors\n * @param {Sigma$EventHandler} onClickNode      set sigma callback for \"clickNode\" event (see below)\n * @param {Sigma$EventHandler} onOverNode      set sigma callback for \"overNode\" event\n * @param {Sigma$EventHandler} onOutNode      set sigma callback for \"outNode\" event\n * @param {Sigma$EventHandler} onClickEdge     set sigma callback for \"clickEdge\" event\n * @param {Sigma$EventHandler} onOverEdge      set sigma callback for \"overEdge\" event\n * @param {Sigma$EventHandler} onOutEdge      set sigma callback for \"outEdge\" event\n *\n * @example\n * Can be composed with sigma sub-components using JSX syntax\n * <Sigma renderer=\"webgl\" style={{maxWidth:\"inherit\", height:\"400px\"}}\n *        settings={{drawEdges:false}}\n *        onOverNode={e => console.log(\"Mouse over node: \" + e.data.node.label)}>\n *        graph={{nodes:[\"id0\", \"id1\"], edges:[{id:\"e0\",source:\"id0\",target:\"id1\"}]}}>\n *   <RelativeSize initialSize={8}/>\n * </Sigma>\n *\n */\n\nclass Sigma extends React.PureComponent {\n\n  constructor(props) {\n    super(props);\n\n    this.initRenderer = container => {\n      if (container) {\n        let options = { container };\n        if (this.props.renderer) options.type = this.props.renderer;\n        this.sigmaRenderer = this.sigma.addRenderer(options);\n        this.sigma.refresh();\n        this.setState({ renderer: true });\n      } else if (this.sigmaRenderer) {\n        this.sigma.killRenderer(this.sigmaRenderer);\n        this.sigmaRenderer = null;\n        this.setState({ renderer: false });\n      }\n    };\n\n    this.state = { renderer: false };\n    let settings = this.props.settings ? this.props.settings : {};\n    this.sigma = new sigma({ settings });\n    Sigma.bindHandlers(this.props, this.sigma);\n    if (this.props.graph) {\n      try {\n        this.sigma.graph.read(this.props.graph);\n      } catch (e) {\n        if (this.props.onSigmaException) this.props.onSigmaException(e);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.sigma.kill();\n    this.sigmaRenderer = null;\n  }\n\n  render() {\n    let children = this.state.renderer ? embedProps(this.props.children, { sigma: this.sigma }) : null;\n    return React.createElement(\n      'div',\n      { ref: this.initRenderer, style: this.props.style },\n      children\n    );\n  }\n\n  /**\n  Initialize event handlers with sigma.\n  \n  Event handler function receives [Sigma Event](https://github.com/jacomyal/sigma.js/wiki/Events-API)\n  with the structure of following type:\n  ```\n  type Sigma$Event = {\n    data: {\n      node?: Neo4j$Node, //for node events is sigma node data\n      edge?: Neo4j$Edge, //for edge events is sigma edge data\n      captor: {   // information about event handler, for instance position on the page {clientX, clientY}\n        clientX: number,\n        clientY: number\n  }}}\n  \n  type Sigma$EventHandler = (node:Sigma$Event) => void\n  \n  ```\n  **/\n\n  static bindHandlers(handlers, sigma) {\n    [\"clickNode\", \"overNode\", \"outNode\", \"clickEdge\", \"overEdge\", \"outEdge\", \"clickStage\"].forEach(event => {\n      let handler = \"on\" + event[0].toUpperCase() + event.substr(1);\n      if (handlers[handler]) {\n        sigma.bind(event, handlers[handler]);\n      }\n    });\n  }\n}\n\nSigma.defaultProps = {\n  settings: {\n    defaultNodeColor: \"#3388AA\",\n    defaultLabelSize: 8,\n    defaultLabelColor: \"#777\",\n    labelThreshold: 12,\n    hoverFontStyle: \"text-size: 11\",\n    batchEdgesDrawing: true,\n    drawEdges: true,\n    drawEdgeLabels: false\n  },\n  style: {\n    maxWidth: \"inherit\",\n    height: \"400px\"\n  }\n};\nSigma.propTypes = {\n  settings: typeof Sigma$Settings === 'function' ? require('prop-types').instanceOf(Sigma$Settings).isRequired : require('prop-types').any.isRequired,\n  renderer: require('prop-types').oneOf(['webgl', 'canvas', 'svg']),\n  style: require('prop-types').object,\n  children: require('prop-types').any,\n  graph: typeof Sigma$Graph$Data === 'function' ? require('prop-types').instanceOf(Sigma$Graph$Data) : require('prop-types').any,\n  onSigmaException: require('prop-types').func,\n  onClickNode: require('prop-types').func,\n  onClickEdge: require('prop-types').func,\n  onOverNode: require('prop-types').func,\n  onOutNode: require('prop-types').func,\n  onOverEdge: require('prop-types').func,\n  onOutEdge: require('prop-types').func,\n  onClickStage: require('prop-types').func\n};\nexport default Sigma;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/Sigma.js\n// module id = ./node_modules/react-sigma/es/Sigma.js\n// module chunks = 4","import '../sigma/main';\nimport '../sigma/svg';\n\n/**\n  Component enables SVG renderer.\n**/\nfunction SigmaEnableSVG() {\n  return null;\n}\n\nexport default SigmaEnableSVG;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/SigmaEnableSVG.js\n// module id = ./node_modules/react-sigma/es/SigmaEnableSVG.js\n// module chunks = 4","import '../sigma/main';\nimport '../sigma/webgl';\n\n/**\n  Component enables WebGL renderer, setting it as default renderer if WebGL is supported by browser.\n**/\nfunction SigmaEnableWebGL() {\n  return null;\n}\n\nexport default SigmaEnableWebGL;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/SigmaEnableWebGL.js\n// module id = ./node_modules/react-sigma/es/SigmaEnableWebGL.js\n// module chunks = 4","export function propsChanged(prev, next) {\n\tfor (let key in prev) if (prev[key] !== next[key]) return true;\n\treturn false;\n}\n\nexport function sigmaGraphMerge(graph) {\n\tgraph.nodes.forEach(node => {\n\t\tif (!this.nodesIndex[node.id]) this.addNode(node);\n\t});\n\tgraph.edges.forEach(edge => {\n\t\tif (!this.edgesIndex[edge.id]) this.addEdge(edge);\n\t});\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/Utils.js\n// module id = ./node_modules/react-sigma/es/Utils.js\n// module chunks = 4","import _Sigma from './Sigma';\nexport { _Sigma as Sigma };\nimport _EdgeShapes from './EdgeShapes';\nexport { _EdgeShapes as EdgeShapes };\nimport _NodeShapes from './NodeShapes';\nexport { _NodeShapes as NodeShapes };\nimport _LoadJSON from './LoadJSON';\nexport { _LoadJSON as LoadJSON };\nimport _LoadGEXF from './LoadGEXF';\nexport { _LoadGEXF as LoadGEXF };\nimport _Filter from './Filter';\nexport { _Filter as Filter };\nimport _ForceAtlas from './ForceAtlas2';\nexport { _ForceAtlas as ForceAtlas2 };\nimport _RelativeSize from './RelativeSize';\nexport { _RelativeSize as RelativeSize };\nimport _NOverlap from './NOverlap';\nexport { _NOverlap as NOverlap };\nimport _NeoCypher from './NeoCypher';\nexport { _NeoCypher as NeoCypher };\nimport _NeoGraphItemsProducers from './NeoGraphItemsProducers';\nexport { _NeoGraphItemsProducers as NeoGraphItemsProducers };\nimport _RandomizeNodePositions from './RandomizeNodePositions';\nexport { _RandomizeNodePositions as RandomizeNodePositions };\nimport _SigmaEnableWebGL from './SigmaEnableWebGL';\nexport { _SigmaEnableWebGL as SigmaEnableWebGL };\nimport _SigmaEnableSVG from './SigmaEnableSVG';\nexport { _SigmaEnableSVG as SigmaEnableSVG };\n\n\nimport Sigma from './Sigma';\nexport default Sigma;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/index.js\n// module id = ./node_modules/react-sigma/es/index.js\n// module chunks = 4","import React from 'react';\n\nexport function embedProps(elements, extraProps) {\n  return React.Children.map(elements, element => React.cloneElement(element, extraProps));\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/es/tools.js\n// module id = ./node_modules/react-sigma/es/tools.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 80);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 21:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.dashed =\n    function(edge, source, target, context, settings) {\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.save();\n\n    context.setLineDash([8,3]);\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 22:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.dotted =\n    function(edge, source, target, context, settings) {\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.save();\n\n    context.setLineDash([2]);\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 23:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.parallel =\n    function(edge, source, target, context, settings) {\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        c,\n        d,\n        dist = sigma.utils.getDistance(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    // Intersection points of the source node circle:\n    c = sigma.utils.getCircleIntersection(sX, sY, size, tX, tY, dist);\n\n    // Intersection points of the target node circle:\n    d = sigma.utils.getCircleIntersection(tX, tY, size, sX, sY, dist);\n\n    context.save();\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(c.xi, c.yi);\n    context.lineTo(d.xi_prime, d.yi_prime);\n    context.closePath();\n    context.stroke();\n\n    context.beginPath();\n    context.moveTo(c.xi_prime, c.yi_prime);\n    context.lineTo(d.xi, d.yi);\n    context.closePath();\n    context.stroke();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.tapered =\n    function(edge, source, target, context, settings) {\n    // The goal is to draw a triangle where the target node is a point of\n    // the triangle, and the two other points are the intersection of the\n    // source circle and the circle (target, distance(source, target)).\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        prefix = settings('prefix') || '',\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        dist = sigma.utils.getDistance(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    // Intersection points:\n    var c = sigma.utils.getCircleIntersection(sX, sY, size, tX, tY, dist);\n\n    context.save();\n\n    // Turn transparency on:\n    context.globalAlpha = 0.65;\n\n    // Draw the triangle:\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(tX, tY);\n    context.lineTo(c.xi, c.yi);\n    context.lineTo(c.xi_prime, c.yi_prime);\n    context.closePath();\n    context.fill();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 25:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This method renders the edge as a dashed line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.dashed = function(edge, source, target, context, settings) {\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.save();\n\n    if (edge.active) {\n      context.strokeStyle = settings('edgeActiveColor') === 'edge' ?\n        (color || defaultEdgeColor) :\n        settings('defaultEdgeActiveColor');\n    }\n    else {\n      context.strokeStyle = color;\n    }\n\n    context.setLineDash([8,3]);\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 26:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This method renders the edge as a dotted line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.dotted = function(edge, source, target, context, settings) {\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.save();\n\n    if (edge.active) {\n      context.strokeStyle = settings('edgeActiveColor') === 'edge' ?\n        (color || defaultEdgeColor) :\n        settings('defaultEdgeActiveColor');\n    }\n    else {\n      context.strokeStyle = color;\n    }\n\n    context.setLineDash([2]);\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 27:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This method renders the edge as two parallel lines.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.parallel = function(edge, source, target, context, settings) {\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        c,\n        d,\n        dist = sigma.utils.getDistance(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    // Intersection points of the source node circle:\n    c = sigma.utils.getCircleIntersection(sX, sY, size, tX, tY, dist);\n\n    // Intersection points of the target node circle:\n    d = sigma.utils.getCircleIntersection(tX, tY, size, sX, sY, dist);\n\n    context.save();\n\n    if (edge.active) {\n      context.strokeStyle = settings('edgeActiveColor') === 'edge' ?\n        (color || defaultEdgeColor) :\n        settings('defaultEdgeActiveColor');\n    }\n    else {\n      context.strokeStyle = color;\n    }\n\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(c.xi, c.yi);\n    context.lineTo(d.xi_prime, d.yi_prime);\n    context.closePath();\n    context.stroke();\n\n    context.beginPath();\n    context.moveTo(c.xi_prime, c.yi_prime);\n    context.lineTo(d.xi, d.yi);\n    context.closePath();\n    context.stroke();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 28:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This method renders the edge as a tapered line.\n   * Danny Holten, Petra Isenberg, Jean-Daniel Fekete, and J. Van Wijk (2010)\n   * Performance Evaluation of Tapered, Curved, and Animated Directed-Edge\n   * Representations in Node-Link Graphs. Research Report, Sep 2010.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.tapered = function(edge, source, target, context, settings) {\n    // The goal is to draw a triangle where the target node is a point of\n    // the triangle, and the two other points are the intersection of the\n    // source circle and the circle (target, distance(source, target)).\n    var color = edge.active ?\n          edge.active_color || settings('defaultEdgeActiveColor') :\n          edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        prefix = settings('prefix') || '',\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        dist = sigma.utils.getDistance(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    // Intersection points:\n    var c = sigma.utils.getCircleIntersection(sX, sY, size, tX, tY, dist);\n\n    context.save();\n\n    if (edge.active) {\n      context.fillStyle = settings('edgeActiveColor') === 'edge' ?\n        (color || defaultEdgeColor) :\n        settings('defaultEdgeActiveColor');\n    }\n    else {\n      context.fillStyle = color;\n    }\n\n    // Turn transparency on:\n    context.globalAlpha = 0.65;\n\n    // Draw the triangle:\n    context.beginPath();\n    context.moveTo(tX, tY);\n    context.lineTo(c.xi, c.yi);\n    context.lineTo(c.xi_prime, c.yi_prime);\n    context.closePath();\n    context.fill();\n\n    context.restore();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 31:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.edges.labels');\n\n  /**\n   * This label renderer will just display the label on the curve of the edge.\n   * The label is rendered at half distance of the edge extremities, and is\n   * always oriented from left to right on the top side of the curve.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.labels.curve =\n    function(edge, source, target, context, settings) {\n    if (typeof edge.label !== 'string')\n      return;\n\n    var prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1;\n\n    if (size < settings('edgeLabelThreshold'))\n      return;\n\n    var fontSize,\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        dX = tX - sX,\n        dY = tY - sY,\n        sign = (sX < tX) ? 1 : -1,\n        cp = {},\n        c,\n        angle,\n        t = 0.5;  //length of the curve\n\n    if (source.id === target.id) {\n      cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);\n      c = sigma.utils.getPointOnBezierCurve(\n        t, sX, sY, tX, tY, cp.x1, cp.y1, cp.x2, cp.y2\n      );\n      angle = Math.atan2(1, 1); // 45°\n    } else {\n      cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n      c = sigma.utils.getPointOnQuadraticCurve(t, sX, sY, tX, tY, cp.x, cp.y);\n      angle = Math.atan2(dY * sign, dX * sign);\n    }\n\n    // The font size is sublineraly proportional to the edge size, in order to\n    // avoid very large labels on screen.\n    // This is achieved by f(x) = x * x^(-1/ a), where 'x' is the size and 'a'\n    // is the edgeLabelSizePowRatio. Notice that f(1) = 1.\n    // The final form is:\n    // f'(x) = b * x * x^(-1 / a), thus f'(1) = b. Application:\n    // fontSize = defaultEdgeLabelSize if edgeLabelSizePowRatio = 1\n    fontSize = (settings('edgeLabelSize') === 'fixed') ?\n      settings('defaultEdgeLabelSize') :\n      settings('defaultEdgeLabelSize') *\n      size *\n      Math.pow(size, -1 / settings('edgeLabelSizePowRatio'));\n\n    context.save();\n\n    \n    if (edge.active) {\n      context.font = [\n        settings('activeFontStyle'),\n        fontSize + 'px',\n        settings('activeFont') || settings('font')\n      ].join(' ');\n\n      context.fillStyle =\n        settings('edgeActiveColor') === 'edge' ?\n        (edge.active_color || settings('defaultEdgeActiveColor')) :\n        settings('defaultEdgeLabelActiveColor');\n    }\n    else {\n      context.font = [\n        settings('fontStyle'),\n        fontSize + 'px',\n        settings('font')\n      ].join(' ');\n\n      context.fillStyle =\n        (settings('edgeLabelColor') === 'edge') ?\n        (edge.color || settings('defaultEdgeColor')) :\n        settings('defaultEdgeLabelColor');\n    }\n\n    context.textAlign = 'center';\n    context.textBaseline = 'alphabetic';\n\n    context.translate(c.x, c.y);\n    context.rotate(angle);\n    context.fillText(\n      edge.label,\n      0,\n      (-size / 2) - 3\n    );\n\n    context.restore();\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 32:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.edges.labels');\n\n  /**\n   * This label renderer will just display the label on the curve of the edge.\n   * The label is rendered at half distance of the edge extremities, and is\n   * always oriented from left to right on the top side of the curve.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.labels.curvedArrow =\n    function(edge, source, target, context, settings) {\n    sigma.canvas.edges.labels.curve(edge, source, target, context, settings);\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 33:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.edges.labels');\n\n  /**\n   * This label renderer will just display the label on the line of the edge.\n   * The label is rendered at half distance of the edge extremities, and is\n   * always oriented from left to right on the top side of the line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.labels.def =\n    function(edge, source, target, context, settings) {\n    if (typeof edge.label !== 'string' || source == target)\n      return;\n\n    var prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1;\n\n    if (size < settings('edgeLabelThreshold'))\n      return;\n\n    if (0 === settings('edgeLabelSizePowRatio'))\n      throw '\"edgeLabelSizePowRatio\" must not be 0.';\n\n    var fontSize,\n        x = (source[prefix + 'x'] + target[prefix + 'x']) / 2,\n        y = (source[prefix + 'y'] + target[prefix + 'y']) / 2,\n        dX = target[prefix + 'x'] - source[prefix + 'x'],\n        dY = target[prefix + 'y'] - source[prefix + 'y'],\n        sign = (source[prefix + 'x'] < target[prefix + 'x']) ? 1 : -1,\n        angle = Math.atan2(dY * sign, dX * sign);\n\n    // The font size is sublineraly proportional to the edge size, in order to\n    // avoid very large labels on screen.\n    // This is achieved by f(x) = x * x^(-1/ a), where 'x' is the size and 'a'\n    // is the edgeLabelSizePowRatio. Notice that f(1) = 1.\n    // The final form is:\n    // f'(x) = b * x * x^(-1 / a), thus f'(1) = b. Application:\n    // fontSize = defaultEdgeLabelSize if edgeLabelSizePowRatio = 1\n    fontSize = (settings('edgeLabelSize') === 'fixed') ?\n      settings('defaultEdgeLabelSize') :\n      settings('defaultEdgeLabelSize') *\n      size *\n      Math.pow(size, -1 / settings('edgeLabelSizePowRatio'));\n\n    context.save();\n\n    if (edge.active) {\n      context.font = [\n        settings('activeFontStyle'),\n        fontSize + 'px',\n        settings('activeFont') || settings('font')\n      ].join(' ');\n\n      context.fillStyle =\n        settings('edgeActiveColor') === 'edge' ?\n        (edge.active_color || settings('defaultEdgeActiveColor')) :\n        settings('defaultEdgeLabelActiveColor');\n    }\n    else {\n      context.font = [\n        settings('fontStyle'),\n        fontSize + 'px',\n        settings('font')\n      ].join(' ');\n\n      context.fillStyle =\n        (settings('edgeLabelColor') === 'edge') ?\n        (edge.color || settings('defaultEdgeColor')) :\n        settings('defaultEdgeLabelColor');\n    }\n\n    context.textAlign = 'center';\n    context.textBaseline = 'alphabetic';\n\n    context.translate(x, y);\n    context.rotate(angle);\n    context.fillText(\n      edge.label,\n      0,\n      (-size / 2) - 3\n    );\n\n    context.restore();\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 49:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.arrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    size = (edge.hover) ?\n      settings('edgeHoverSizeRatio') * size : size;\n    var aSize = size * 2.5,\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 50:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curve =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 51:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        d,\n        aSize,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aSize = size * 2.5;\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aSize = size * 2.5;\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 53:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),\n        aX = sX + (tX - sX) * (d - aSize - tSize) / d,\n        aY = sY + (tY - sY) * (d - aSize - tSize) / d,\n        vX = (tX - sX) * aSize / d,\n        vY = (tY - sY) * aSize / d;\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    context.lineTo(\n      aX,\n      aY\n    );\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 54:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curve = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        sSize = source[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'];\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, tX, tY);\n    }\n    context.stroke();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 55:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * This edge renderer will display edges as curves with arrow heading.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.curvedArrow =\n    function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor'),\n        cp = {},\n        size = edge[prefix + 'size'] || 1,\n        tSize = target[prefix + 'size'],\n        sX = source[prefix + 'x'],\n        sY = source[prefix + 'y'],\n        tX = target[prefix + 'x'],\n        tY = target[prefix + 'y'],\n        aSize = Math.max(size * 2.5, settings('minArrowSize')),\n        d,\n        aX,\n        aY,\n        vX,\n        vY;\n\n    cp = (source.id === target.id) ?\n      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :\n      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);\n\n    if (source.id === target.id) {\n      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));\n      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;\n      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x1) * aSize / d;\n      vY = (tY - cp.y1) * aSize / d;\n    }\n    else {\n      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));\n      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;\n      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;\n      vX = (tX - cp.x) * aSize / d;\n      vY = (tY - cp.y) * aSize / d;\n    }\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(sX, sY);\n    if (source.id === target.id) {\n      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);\n    } else {\n      context.quadraticCurveTo(cp.x, cp.y, aX, aY);\n    }\n    context.stroke();\n\n    context.fillStyle = color;\n    context.beginPath();\n    context.moveTo(aX + vX, aY + vY);\n    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);\n    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);\n    context.lineTo(aX + vX, aY + vY);\n    context.closePath();\n    context.fill();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 80:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_canvas_sigma_canvas_edges_curve_js__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_canvas_sigma_canvas_edges_curve_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_canvas_sigma_canvas_edges_curve_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_canvas_sigma_canvas_edges_arrow_js__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_canvas_sigma_canvas_edges_arrow_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_canvas_sigma_canvas_edges_arrow_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_canvas_sigma_canvas_edges_curvedArrow_js__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_canvas_sigma_canvas_edges_curvedArrow_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_canvas_sigma_canvas_edges_curvedArrow_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_curve_js__ = __webpack_require__(50);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_curve_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_curve_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_arrow_js__ = __webpack_require__(49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_arrow_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_arrow_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_curvedArrow_js__ = __webpack_require__(51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_curvedArrow_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_curvedArrow_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_dashed_js__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_dashed_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_dashed_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_dotted_js__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_dotted_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_dotted_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_parallel_js__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_parallel_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_parallel_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_tapered_js__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_tapered_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edgehovers_tapered_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_dashed_js__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_dashed_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_dashed_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_dotted_js__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_dotted_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_dotted_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_parallel_js__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_parallel_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_parallel_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_tapered_js__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_tapered_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_sigma_react_plugins_sigma_renderers_customEdgeShapes_sigma_canvas_edges_tapered_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_def_js__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_curve_js__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_curve_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_curve_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_curvedArrow_js__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_curvedArrow_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_sigma_react_plugins_sigma_renderers_edgeLabels_sigma_canvas_edges_labels_curvedArrow_js__);\n//base library\n\n\n\n\n\n\n//plugins\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/edges.js\n// module id = ./node_modules/react-sigma/sigma/edges.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 134);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 134:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(15);\nmodule.exports = __webpack_require__(16);\n\n\n/***/ }),\n\n/***/ 15:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  /**\n   * Sigma ForceAtlas2.5 Supervisor\n   * ===============================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.1\n   */\n  var _root = this;\n\n  /**\n   * Feature detection\n   * ------------------\n   */\n  var webWorkers = 'Worker' in _root;\n\n  /**\n   * Supervisor Object\n   * ------------------\n   */\n  function Supervisor(sigInst, options) {\n    var _this = this,\n        workerFn = sigInst.getForceAtlas2Worker &&\n          sigInst.getForceAtlas2Worker();\n\n    options = options || {};\n\n    // _root URL Polyfill\n    _root.URL = _root.URL || _root.webkitURL;\n\n    // Properties\n    this.sigInst = sigInst;\n    this.graph = this.sigInst.graph;\n    this.ppn = 10;\n    this.ppe = 3;\n    this.config = {};\n    this.shouldUseWorker =\n      options.worker === false ? false : true && webWorkers;\n    this.workerUrl = options.workerUrl;\n\n    // State\n    this.started = false;\n    this.running = false;\n\n    // Web worker or classic DOM events?\n    if (this.shouldUseWorker) {\n      if (!this.workerUrl) {\n        var blob = this.makeBlob(workerFn);\n        this.worker = new Worker(URL.createObjectURL(blob));\n      }\n      else {\n        this.worker = new Worker(this.workerUrl);\n      }\n\n      // Post Message Polyfill\n      this.worker.postMessage =\n        this.worker.webkitPostMessage || this.worker.postMessage;\n    }\n    else {\n\n      eval(workerFn);\n    }\n\n    // Worker message receiver\n    this.msgName = (this.worker) ? 'message' : 'newCoords';\n    this.listener = function(e) {\n\n      // Retrieving data\n      _this.nodesByteArray = new Float32Array(e.data.nodes);\n\n      // If ForceAtlas2 is running, we act accordingly\n      if (_this.running) {\n\n        // Applying layout\n        _this.applyLayoutChanges();\n\n        // Send data back to worker and loop\n        _this.sendByteArrayToWorker();\n\n        // Rendering graph\n        _this.sigInst.refresh();\n      }\n    };\n\n    (this.worker || document).addEventListener(this.msgName, this.listener);\n\n    // Filling byteArrays\n    this.graphToByteArrays();\n\n    // Binding on kill to properly terminate layout when parent is killed\n    sigInst.bind('kill', function() {\n      sigInst.killForceAtlas2();\n    });\n  }\n\n  Supervisor.prototype.makeBlob = function(workerFn) {\n    var blob;\n\n    try {\n      blob = new Blob([workerFn], {type: 'application/javascript'});\n    }\n    catch (e) {\n      _root.BlobBuilder = _root.BlobBuilder ||\n                          _root.WebKitBlobBuilder ||\n                          _root.MozBlobBuilder;\n\n      blob = new BlobBuilder();\n      blob.append(workerFn);\n      blob = blob.getBlob();\n    }\n\n    return blob;\n  };\n\n  Supervisor.prototype.graphToByteArrays = function() {\n    var nodes = this.graph.nodes(),\n        edges = this.graph.edges(),\n        nbytes = nodes.length * this.ppn,\n        ebytes = edges.length * this.ppe,\n        nIndex = {},\n        i,\n        j,\n        l;\n\n    // Allocating Byte arrays with correct nb of bytes\n    this.nodesByteArray = new Float32Array(nbytes);\n    this.edgesByteArray = new Float32Array(ebytes);\n\n    // Iterate through nodes\n    for (i = j = 0, l = nodes.length; i < l; i++) {\n\n      // Populating index\n      nIndex[nodes[i].id] = j;\n\n      // Populating byte array\n      this.nodesByteArray[j] = nodes[i].x;\n      this.nodesByteArray[j + 1] = nodes[i].y;\n      this.nodesByteArray[j + 2] = 0;\n      this.nodesByteArray[j + 3] = 0;\n      this.nodesByteArray[j + 4] = 0;\n      this.nodesByteArray[j + 5] = 0;\n      this.nodesByteArray[j + 6] = 1 + this.graph.degree(nodes[i].id);\n      this.nodesByteArray[j + 7] = 1;\n      this.nodesByteArray[j + 8] = nodes[i].size;\n      this.nodesByteArray[j + 9] = 0;\n      j += this.ppn;\n    }\n\n    // Iterate through edges\n    for (i = j = 0, l = edges.length; i < l; i++) {\n      this.edgesByteArray[j] = nIndex[edges[i].source];\n      this.edgesByteArray[j + 1] = nIndex[edges[i].target];\n      this.edgesByteArray[j + 2] = edges[i].weight || 0;\n      j += this.ppe;\n    }\n  };\n\n  // TODO: make a better send function\n  Supervisor.prototype.applyLayoutChanges = function() {\n    var nodes = this.graph.nodes(),\n        j = 0,\n        realIndex;\n\n    // Moving nodes\n    for (var i = 0, l = this.nodesByteArray.length; i < l; i += this.ppn) {\n      nodes[j].x = this.nodesByteArray[i];\n      nodes[j].y = this.nodesByteArray[i + 1];\n      j++;\n    }\n  };\n\n  Supervisor.prototype.sendByteArrayToWorker = function(action) {\n    var content = {\n      action: action || 'loop',\n      nodes: this.nodesByteArray.buffer\n    };\n\n    var buffers = [this.nodesByteArray.buffer];\n\n    if (action === 'start') {\n      content.config = this.config || {};\n      content.edges = this.edgesByteArray.buffer;\n      buffers.push(this.edgesByteArray.buffer);\n    }\n\n    if (this.shouldUseWorker)\n      this.worker.postMessage(content, buffers);\n    else\n      _root.postMessage(content, '*');\n  };\n\n  Supervisor.prototype.start = function() {\n    if (this.running)\n      return;\n\n    this.running = true;\n\n    // Do not refresh edgequadtree during layout:\n    var k,\n        c;\n    for (k in this.sigInst.cameras) {\n      c = this.sigInst.cameras[k];\n      c.edgequadtree._enabled = false;\n    }\n\n    if (!this.started) {\n\n      // Sending init message to worker\n      this.sendByteArrayToWorker('start');\n      this.started = true;\n    }\n    else {\n      this.sendByteArrayToWorker();\n    }\n  };\n\n  Supervisor.prototype.stop = function() {\n    if (!this.running)\n      return;\n\n    // Allow to refresh edgequadtree:\n    var k,\n        c,\n        bounds;\n    for (k in this.sigInst.cameras) {\n      c = this.sigInst.cameras[k];\n      c.edgequadtree._enabled = true;\n\n      // Find graph boundaries:\n      bounds = sigma.utils.getBoundaries(\n        this.graph,\n        c.readPrefix\n      );\n\n      // Refresh edgequadtree:\n      if (c.settings('drawEdges') && c.settings('enableEdgeHovering'))\n        c.edgequadtree.index(this.sigInst.graph, {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n    }\n\n    this.running = false;\n  };\n\n  Supervisor.prototype.killWorker = function() {\n    if (this.worker) {\n      this.worker.terminate();\n    }\n    else {\n      _root.postMessage({action: 'kill'}, '*');\n      document.removeEventListener(this.msgName, this.listener);\n    }\n  };\n\n  Supervisor.prototype.configure = function(config) {\n\n    // Setting configuration\n    this.config = config;\n\n    if (!this.started)\n      return;\n\n    var data = {action: 'config', config: this.config};\n\n    if (this.shouldUseWorker)\n      this.worker.postMessage(data);\n    else\n      _root.postMessage(data, '*');\n  };\n\n  /**\n   * Interface\n   * ----------\n   */\n  sigma.prototype.startForceAtlas2 = function(config) {\n\n    // Create supervisor if undefined\n    if (!this.supervisor)\n      this.supervisor = new Supervisor(this, config);\n\n    // Configuration provided?\n    if (config)\n      this.supervisor.configure(config);\n\n    // Start algorithm\n    this.supervisor.start();\n\n    return this;\n  };\n\n  sigma.prototype.stopForceAtlas2 = function() {\n    if (!this.supervisor)\n      return this;\n\n    // Pause algorithm\n    this.supervisor.stop();\n\n    return this;\n  };\n\n  sigma.prototype.killForceAtlas2 = function() {\n    if (!this.supervisor)\n      return this;\n\n    // Stop Algorithm\n    this.supervisor.stop();\n\n    // Kill Worker\n    this.supervisor.killWorker();\n\n    // Kill supervisor\n    this.supervisor = null;\n\n    return this;\n  };\n\n  sigma.prototype.configForceAtlas2 = function(config) {\n    if (!this.supervisor)\n      this.supervisor = new Supervisor(this, config);\n\n    this.supervisor.configure(config);\n\n    return this;\n  };\n\n  sigma.prototype.isForceAtlas2Running = function(config) {\n    return !!this.supervisor && this.supervisor.running;\n  };\n}).call(window);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 16:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma ForceAtlas2.5 Webworker\n   * ==============================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Algorithm author: Mathieu Jacomy @ Sciences Po Medialab & WebAtlas\n   * Version: 1.0.3\n   */\n\n  var _root = this,\n      inWebWorker = !('document' in _root);\n\n  /**\n   * Worker Function Wrapper\n   * ------------------------\n   *\n   * The worker has to be wrapped into a single stringified function\n   * to be passed afterwards as a BLOB object to the supervisor.\n   */\n  var Worker = function(undefined) {\n    'use strict';\n\n    /**\n     * Worker settings and properties\n     */\n    var W = {\n\n      // Properties\n      ppn: 10,\n      ppe: 3,\n      ppr: 9,\n      maxForce: 10,\n      iterations: 0,\n      converged: false,\n\n      // Possible to change through config\n      settings: {\n        linLogMode: false,\n        outboundAttractionDistribution: false,\n        adjustSizes: false,\n        edgeWeightInfluence: 0,\n        scalingRatio: 1,\n        strongGravityMode: false,\n        gravity: 1,\n        slowDown: 1,\n        barnesHutOptimize: false,\n        barnesHutTheta: 0.5,\n        startingIterations: 1,\n        iterationsPerRender: 1\n      }\n    };\n\n    var NodeMatrix,\n        EdgeMatrix,\n        RegionMatrix;\n\n    /**\n     * Helpers\n     */\n    function extend() {\n      var i,\n          k,\n          res = {},\n          l = arguments.length;\n\n      for (i = l - 1; i >= 0; i--)\n        for (k in arguments[i])\n          res[k] = arguments[i][k];\n      return res;\n    }\n\n    function __emptyObject(obj) {\n      var k;\n\n      for (k in obj)\n        if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n          delete obj[k];\n\n      return obj;\n    }\n\n    /**\n     * Matrices properties accessors\n     */\n    var nodeProperties = {\n      x: 0,\n      y: 1,\n      dx: 2,\n      dy: 3,\n      old_dx: 4,\n      old_dy: 5,\n      mass: 6,\n      convergence: 7,\n      size: 8,\n      fixed: 9\n    };\n\n    var edgeProperties = {\n      source: 0,\n      target: 1,\n      weight: 2\n    };\n\n    var regionProperties = {\n      node: 0,\n      centerX: 1,\n      centerY: 2,\n      size: 3,\n      nextSibling: 4,\n      firstChild: 5,\n      mass: 6,\n      massCenterX: 7,\n      massCenterY: 8\n    };\n\n    function np(i, p) {\n\n      // DEBUG: safeguards\n      if ((i % W.ppn) !== 0)\n        throw 'np: non correct (' + i + ').';\n      if (i !== parseInt(i))\n        throw 'np: non int.';\n\n      if (p in nodeProperties)\n        return i + nodeProperties[p];\n      else\n        throw 'ForceAtlas2.Worker - ' +\n              'Inexistant node property given (' + p + ').';\n    }\n\n    function ep(i, p) {\n\n      // DEBUG: safeguards\n      if ((i % W.ppe) !== 0)\n        throw 'ep: non correct (' + i + ').';\n      if (i !== parseInt(i))\n        throw 'ep: non int.';\n\n      if (p in edgeProperties)\n        return i + edgeProperties[p];\n      else\n        throw 'ForceAtlas2.Worker - ' +\n              'Inexistant edge property given (' + p + ').';\n    }\n\n    function rp(i, p) {\n\n      // DEBUG: safeguards\n      if ((i % W.ppr) !== 0)\n        throw 'rp: non correct (' + i + ').';\n      if (i !== parseInt(i))\n        throw 'rp: non int.';\n\n      if (p in regionProperties)\n        return i + regionProperties[p];\n      else\n        throw 'ForceAtlas2.Worker - ' +\n              'Inexistant region property given (' + p + ').';\n    }\n\n    // DEBUG\n    function nan(v) {\n      if (isNaN(v))\n        throw 'NaN alert!';\n    }\n\n\n    /**\n     * Algorithm initialization\n     */\n\n    function init(nodes, edges, config) {\n      config = config || {};\n      var i, l;\n\n      // Matrices\n      NodeMatrix = nodes;\n      EdgeMatrix = edges;\n\n      // Length\n      W.nodesLength = NodeMatrix.length;\n      W.edgesLength = EdgeMatrix.length;\n\n      // Merging configuration\n      configure(config);\n    }\n\n    function configure(o) {\n      W.settings = extend(o, W.settings);\n    }\n\n    /**\n     * Algorithm pass\n     */\n\n    // MATH: get distances stuff and power 2 issues\n    function pass() {\n      var a, i, j, l, r, n, n1, n2, e, w, g, k, m;\n\n      var outboundAttCompensation,\n          coefficient,\n          xDist,\n          yDist,\n          ewc,\n          mass,\n          distance,\n          size,\n          factor;\n\n      // 1) Initializing layout data\n      //-----------------------------\n\n      // Resetting positions & computing max values\n      for (n = 0; n < W.nodesLength; n += W.ppn) {\n        NodeMatrix[np(n, 'old_dx')] = NodeMatrix[np(n, 'dx')];\n        NodeMatrix[np(n, 'old_dy')] = NodeMatrix[np(n, 'dy')];\n        NodeMatrix[np(n, 'dx')] = 0;\n        NodeMatrix[np(n, 'dy')] = 0;\n      }\n\n      // If outbound attraction distribution, compensate\n      if (W.settings.outboundAttractionDistribution) {\n        outboundAttCompensation = 0;\n        for (n = 0; n < W.nodesLength; n += W.ppn) {\n          outboundAttCompensation += NodeMatrix[np(n, 'mass')];\n        }\n\n        outboundAttCompensation /= W.nodesLength;\n      }\n\n\n      // 1.bis) Barnes-Hut computation\n      //------------------------------\n\n      if (W.settings.barnesHutOptimize) {\n\n        var minX = Infinity,\n            maxX = -Infinity,\n            minY = Infinity,\n            maxY = -Infinity,\n            q, q0, q1, q2, q3;\n\n        // Setting up\n        // RegionMatrix = new Float32Array(W.nodesLength / W.ppn * 4 * W.ppr);\n        RegionMatrix = [];\n\n        // Computing min and max values\n        for (n = 0; n < W.nodesLength; n += W.ppn) {\n          minX = Math.min(minX, NodeMatrix[np(n, 'x')]);\n          maxX = Math.max(maxX, NodeMatrix[np(n, 'x')]);\n          minY = Math.min(minY, NodeMatrix[np(n, 'y')]);\n          maxY = Math.max(maxY, NodeMatrix[np(n, 'y')]);\n        }\n\n        // Build the Barnes Hut root region\n        RegionMatrix[rp(0, 'node')] = -1;\n        RegionMatrix[rp(0, 'centerX')] = (minX + maxX) / 2;\n        RegionMatrix[rp(0, 'centerY')] = (minY + maxY) / 2;\n        RegionMatrix[rp(0, 'size')] = Math.max(maxX - minX, maxY - minY);\n        RegionMatrix[rp(0, 'nextSibling')] = -1;\n        RegionMatrix[rp(0, 'firstChild')] = -1;\n        RegionMatrix[rp(0, 'mass')] = 0;\n        RegionMatrix[rp(0, 'massCenterX')] = 0;\n        RegionMatrix[rp(0, 'massCenterY')] = 0;\n\n        // Add each node in the tree\n        l = 1;\n        for (n = 0; n < W.nodesLength; n += W.ppn) {\n\n          // Current region, starting with root\n          r = 0;\n\n          while (true) {\n            // Are there sub-regions?\n\n            // We look at first child index\n            if (RegionMatrix[rp(r, 'firstChild')] >= 0) {\n\n              // There are sub-regions\n\n              // We just iterate to find a \"leave\" of the tree\n              // that is an empty region or a region with a single node\n              // (see next case)\n\n              // Find the quadrant of n\n              if (NodeMatrix[np(n, 'x')] < RegionMatrix[rp(r, 'centerX')]) {\n\n                if (NodeMatrix[np(n, 'y')] < RegionMatrix[rp(r, 'centerY')]) {\n\n                  // Top Left quarter\n                  q = RegionMatrix[rp(r, 'firstChild')];\n                }\n                else {\n\n                  // Bottom Left quarter\n                  q = RegionMatrix[rp(r, 'firstChild')] + W.ppr;\n                }\n              }\n              else {\n                if (NodeMatrix[np(n, 'y')] < RegionMatrix[rp(r, 'centerY')]) {\n\n                  // Top Right quarter\n                  q = RegionMatrix[rp(r, 'firstChild')] + W.ppr * 2;\n                }\n                else {\n\n                  // Bottom Right quarter\n                  q = RegionMatrix[rp(r, 'firstChild')] + W.ppr * 3;\n                }\n              }\n\n              // Update center of mass and mass (we only do it for non-leave regions)\n              RegionMatrix[rp(r, 'massCenterX')] =\n                (RegionMatrix[rp(r, 'massCenterX')] * RegionMatrix[rp(r, 'mass')] +\n                 NodeMatrix[np(n, 'x')] * NodeMatrix[np(n, 'mass')]) /\n                (RegionMatrix[rp(r, 'mass')] + NodeMatrix[np(n, 'mass')]);\n\n              RegionMatrix[rp(r, 'massCenterY')] =\n                (RegionMatrix[rp(r, 'massCenterY')] * RegionMatrix[rp(r, 'mass')] +\n                 NodeMatrix[np(n, 'y')] * NodeMatrix[np(n, 'mass')]) /\n                (RegionMatrix[rp(r, 'mass')] + NodeMatrix[np(n, 'mass')]);\n\n              RegionMatrix[rp(r, 'mass')] += NodeMatrix[np(n, 'mass')];\n\n              // Iterate on the right quadrant\n              r = q;\n              continue;\n            }\n            else {\n\n              // There are no sub-regions: we are in a \"leave\"\n\n              // Is there a node in this leave?\n              if (RegionMatrix[rp(r, 'node')] < 0) {\n\n                // There is no node in region:\n                // we record node n and go on\n                RegionMatrix[rp(r, 'node')] = n;\n                break;\n              }\n              else {\n\n                // There is a node in this region\n\n                // We will need to create sub-regions, stick the two\n                // nodes (the old one r[0] and the new one n) in two\n                // subregions. If they fall in the same quadrant,\n                // we will iterate.\n\n                // Create sub-regions\n                RegionMatrix[rp(r, 'firstChild')] = l * W.ppr;\n                w = RegionMatrix[rp(r, 'size')] / 2;  // new size (half)\n\n                // NOTE: we use screen coordinates\n                // from Top Left to Bottom Right\n\n                // Top Left sub-region\n                g = RegionMatrix[rp(r, 'firstChild')];\n\n                RegionMatrix[rp(g, 'node')] = -1;\n                RegionMatrix[rp(g, 'centerX')] = RegionMatrix[rp(r, 'centerX')] - w;\n                RegionMatrix[rp(g, 'centerY')] = RegionMatrix[rp(r, 'centerY')] - w;\n                RegionMatrix[rp(g, 'size')] = w;\n                RegionMatrix[rp(g, 'nextSibling')] = g + W.ppr;\n                RegionMatrix[rp(g, 'firstChild')] = -1;\n                RegionMatrix[rp(g, 'mass')] = 0;\n                RegionMatrix[rp(g, 'massCenterX')] = 0;\n                RegionMatrix[rp(g, 'massCenterY')] = 0;\n\n                // Bottom Left sub-region\n                g += W.ppr;\n                RegionMatrix[rp(g, 'node')] = -1;\n                RegionMatrix[rp(g, 'centerX')] = RegionMatrix[rp(r, 'centerX')] - w;\n                RegionMatrix[rp(g, 'centerY')] = RegionMatrix[rp(r, 'centerY')] + w;\n                RegionMatrix[rp(g, 'size')] = w;\n                RegionMatrix[rp(g, 'nextSibling')] = g + W.ppr;\n                RegionMatrix[rp(g, 'firstChild')] = -1;\n                RegionMatrix[rp(g, 'mass')] = 0;\n                RegionMatrix[rp(g, 'massCenterX')] = 0;\n                RegionMatrix[rp(g, 'massCenterY')] = 0;\n\n                // Top Right sub-region\n                g += W.ppr;\n                RegionMatrix[rp(g, 'node')] = -1;\n                RegionMatrix[rp(g, 'centerX')] = RegionMatrix[rp(r, 'centerX')] + w;\n                RegionMatrix[rp(g, 'centerY')] = RegionMatrix[rp(r, 'centerY')] - w;\n                RegionMatrix[rp(g, 'size')] = w;\n                RegionMatrix[rp(g, 'nextSibling')] = g + W.ppr;\n                RegionMatrix[rp(g, 'firstChild')] = -1;\n                RegionMatrix[rp(g, 'mass')] = 0;\n                RegionMatrix[rp(g, 'massCenterX')] = 0;\n                RegionMatrix[rp(g, 'massCenterY')] = 0;\n\n                // Bottom Right sub-region\n                g += W.ppr;\n                RegionMatrix[rp(g, 'node')] = -1;\n                RegionMatrix[rp(g, 'centerX')] = RegionMatrix[rp(r, 'centerX')] + w;\n                RegionMatrix[rp(g, 'centerY')] = RegionMatrix[rp(r, 'centerY')] + w;\n                RegionMatrix[rp(g, 'size')] = w;\n                RegionMatrix[rp(g, 'nextSibling')] = RegionMatrix[rp(r, 'nextSibling')];\n                RegionMatrix[rp(g, 'firstChild')] = -1;\n                RegionMatrix[rp(g, 'mass')] = 0;\n                RegionMatrix[rp(g, 'massCenterX')] = 0;\n                RegionMatrix[rp(g, 'massCenterY')] = 0;\n\n                l += 4;\n\n                // Now the goal is to find two different sub-regions\n                // for the two nodes: the one previously recorded (r[0])\n                // and the one we want to add (n)\n\n                // Find the quadrant of the old node\n                if (NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'x')] < RegionMatrix[rp(r, 'centerX')]) {\n                  if (NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'y')] < RegionMatrix[rp(r, 'centerY')]) {\n\n                    // Top Left quarter\n                    q = RegionMatrix[rp(r, 'firstChild')];\n                  }\n                  else {\n\n                    // Bottom Left quarter\n                    q = RegionMatrix[rp(r, 'firstChild')] + W.ppr;\n                  }\n                }\n                else {\n                  if (NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'y')] < RegionMatrix[rp(r, 'centerY')]) {\n\n                    // Top Right quarter\n                    q = RegionMatrix[rp(r, 'firstChild')] + W.ppr * 2;\n                  }\n                  else {\n\n                    // Bottom Right quarter\n                    q = RegionMatrix[rp(r, 'firstChild')] + W.ppr * 3;\n                  }\n                }\n\n                // We remove r[0] from the region r, add its mass to r and record it in q\n                RegionMatrix[rp(r, 'mass')] = NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'mass')];\n                RegionMatrix[rp(r, 'massCenterX')] = NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'x')];\n                RegionMatrix[rp(r, 'massCenterY')] = NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'y')];\n\n                RegionMatrix[rp(q, 'node')] = RegionMatrix[rp(r, 'node')];\n                RegionMatrix[rp(r, 'node')] = -1;\n\n                // Find the quadrant of n\n                if (NodeMatrix[np(n, 'x')] < RegionMatrix[rp(r, 'centerX')]) {\n                  if (NodeMatrix[np(n, 'y')] < RegionMatrix[rp(r, 'centerY')]) {\n\n                    // Top Left quarter\n                    q2 = RegionMatrix[rp(r, 'firstChild')];\n                  }\n                  else {\n                    // Bottom Left quarter\n                    q2 = RegionMatrix[rp(r, 'firstChild')] + W.ppr;\n                  }\n                }\n                else {\n                  if(NodeMatrix[np(n, 'y')] < RegionMatrix[rp(r, 'centerY')]) {\n\n                    // Top Right quarter\n                    q2 = RegionMatrix[rp(r, 'firstChild')] + W.ppr * 2;\n                  }\n                  else {\n\n                    // Bottom Right quarter\n                    q2 = RegionMatrix[rp(r, 'firstChild')] + W.ppr * 3;\n                  }\n                }\n\n                if (q === q2) {\n\n                  // If both nodes are in the same quadrant,\n                  // we have to try it again on this quadrant\n                  r = q;\n                  continue;\n                }\n\n                // If both quadrants are different, we record n\n                // in its quadrant\n                RegionMatrix[rp(q2, 'node')] = n;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n\n      // 2) Repulsion\n      //--------------\n      // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n      if (W.settings.barnesHutOptimize) {\n        coefficient = W.settings.scalingRatio;\n\n        // Applying repulsion through regions\n        for (n = 0; n < W.nodesLength; n += W.ppn) {\n\n          // Computing leaf quad nodes iteration\n\n          r = 0; // Starting with root region\n          while (true) {\n\n            if (RegionMatrix[rp(r, 'firstChild')] >= 0) {\n\n              // The region has sub-regions\n\n              // We run the Barnes Hut test to see if we are at the right distance\n              distance = Math.sqrt(\n                (Math.pow(NodeMatrix[np(n, 'x')] - RegionMatrix[rp(r, 'massCenterX')], 2)) +\n                (Math.pow(NodeMatrix[np(n, 'y')] - RegionMatrix[rp(r, 'massCenterY')], 2))\n              );\n\n              if (2 * RegionMatrix[rp(r, 'size')] / distance < W.settings.barnesHutTheta) {\n\n                // We treat the region as a single body, and we repulse\n\n                xDist = NodeMatrix[np(n, 'x')] - RegionMatrix[rp(r, 'massCenterX')];\n                yDist = NodeMatrix[np(n, 'y')] - RegionMatrix[rp(r, 'massCenterY')];\n\n                if (W.settings.adjustSizes) {\n\n                  //-- Linear Anti-collision Repulsion\n                  if (distance > 0) {\n                    factor = coefficient * NodeMatrix[np(n, 'mass')] *\n                      RegionMatrix[rp(r, 'mass')] / distance / distance;\n\n                    NodeMatrix[np(n, 'dx')] += xDist * factor;\n                    NodeMatrix[np(n, 'dy')] += yDist * factor;\n                  }\n                  else if (distance < 0) {\n                    factor = -coefficient * NodeMatrix[np(n, 'mass')] *\n                      RegionMatrix[rp(r, 'mass')] / distance;\n\n                    NodeMatrix[np(n, 'dx')] += xDist * factor;\n                    NodeMatrix[np(n, 'dy')] += yDist * factor;\n                  }\n                }\n                else {\n\n                  //-- Linear Repulsion\n                  if (distance > 0) {\n                    factor = coefficient * NodeMatrix[np(n, 'mass')] *\n                      RegionMatrix[rp(r, 'mass')] / distance / distance;\n\n                    NodeMatrix[np(n, 'dx')] += xDist * factor;\n                    NodeMatrix[np(n, 'dy')] += yDist * factor;\n                  }\n                }\n\n                // When this is done, we iterate. We have to look at the next sibling.\n                if (RegionMatrix[rp(r, 'nextSibling')] < 0)\n                  break;  // No next sibling: we have finished the tree\n                r = RegionMatrix[rp(r, 'nextSibling')];\n                continue;\n\n              }\n              else {\n\n                // The region is too close and we have to look at sub-regions\n                r = RegionMatrix[rp(r, 'firstChild')];\n                continue;\n              }\n\n            }\n            else {\n\n              // The region has no sub-region\n              // If there is a node r[0] and it is not n, then repulse\n\n              if (RegionMatrix[rp(r, 'node')] >= 0 && RegionMatrix[rp(r, 'node')] !== n) {\n                xDist = NodeMatrix[np(n, 'x')] - NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'x')];\n                yDist = NodeMatrix[np(n, 'y')] - NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'y')];\n\n                distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n                if (W.settings.adjustSizes) {\n\n                  //-- Linear Anti-collision Repulsion\n                  if (distance > 0) {\n                    factor = coefficient * NodeMatrix[np(n, 'mass')] *\n                      NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'mass')] / distance / distance;\n\n                    NodeMatrix[np(n, 'dx')] += xDist * factor;\n                    NodeMatrix[np(n, 'dy')] += yDist * factor;\n                  }\n                  else if (distance < 0) {\n                    factor = -coefficient * NodeMatrix[np(n, 'mass')] *\n                      NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'mass')] / distance;\n\n                    NodeMatrix[np(n, 'dx')] += xDist * factor;\n                    NodeMatrix[np(n, 'dy')] += yDist * factor;\n                  }\n                }\n                else {\n\n                  //-- Linear Repulsion\n                  if (distance > 0) {\n                    factor = coefficient * NodeMatrix[np(n, 'mass')] *\n                      NodeMatrix[np(RegionMatrix[rp(r, 'node')], 'mass')] / distance / distance;\n\n                    NodeMatrix[np(n, 'dx')] += xDist * factor;\n                    NodeMatrix[np(n, 'dy')] += yDist * factor;\n                  }\n                }\n\n              }\n\n              // When this is done, we iterate. We have to look at the next sibling.\n              if (RegionMatrix[rp(r, 'nextSibling')] < 0)\n                break;  // No next sibling: we have finished the tree\n              r = RegionMatrix[rp(r, 'nextSibling')];\n              continue;\n            }\n          }\n        }\n      }\n      else {\n        coefficient = W.settings.scalingRatio;\n\n        // Square iteration\n        for (n1 = 0; n1 < W.nodesLength; n1 += W.ppn) {\n          for (n2 = 0; n2 < n1; n2 += W.ppn) {\n\n            // Common to both methods\n            xDist = NodeMatrix[np(n1, 'x')] - NodeMatrix[np(n2, 'x')];\n            yDist = NodeMatrix[np(n1, 'y')] - NodeMatrix[np(n2, 'y')];\n\n            if (W.settings.adjustSizes) {\n\n              //-- Anticollision Linear Repulsion\n              distance = Math.sqrt(xDist * xDist + yDist * yDist) -\n                NodeMatrix[np(n1, 'size')] -\n                NodeMatrix[np(n2, 'size')];\n\n              if (distance > 0) {\n                factor = coefficient *\n                  NodeMatrix[np(n1, 'mass')] *\n                  NodeMatrix[np(n2, 'mass')] /\n                  distance / distance;\n\n                // Updating nodes' dx and dy\n                NodeMatrix[np(n1, 'dx')] += xDist * factor;\n                NodeMatrix[np(n1, 'dy')] += yDist * factor;\n\n                NodeMatrix[np(n2, 'dx')] += xDist * factor;\n                NodeMatrix[np(n2, 'dy')] += yDist * factor;\n              }\n              else if (distance < 0) {\n                factor = 100 * coefficient *\n                  NodeMatrix[np(n1, 'mass')] *\n                  NodeMatrix[np(n2, 'mass')];\n\n                // Updating nodes' dx and dy\n                NodeMatrix[np(n1, 'dx')] += xDist * factor;\n                NodeMatrix[np(n1, 'dy')] += yDist * factor;\n\n                NodeMatrix[np(n2, 'dx')] -= xDist * factor;\n                NodeMatrix[np(n2, 'dy')] -= yDist * factor;\n              }\n            }\n            else {\n\n              //-- Linear Repulsion\n              distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n              if (distance > 0) {\n                factor = coefficient *\n                  NodeMatrix[np(n1, 'mass')] *\n                  NodeMatrix[np(n2, 'mass')] /\n                  distance / distance;\n\n                // Updating nodes' dx and dy\n                NodeMatrix[np(n1, 'dx')] += xDist * factor;\n                NodeMatrix[np(n1, 'dy')] += yDist * factor;\n\n                NodeMatrix[np(n2, 'dx')] -= xDist * factor;\n                NodeMatrix[np(n2, 'dy')] -= yDist * factor;\n              }\n            }\n          }\n        }\n      }\n\n\n      // 3) Gravity\n      //------------\n      g = W.settings.gravity / W.settings.scalingRatio;\n      coefficient = W.settings.scalingRatio;\n      for (n = 0; n < W.nodesLength; n += W.ppn) {\n        factor = 0;\n\n        // Common to both methods\n        xDist = NodeMatrix[np(n, 'x')];\n        yDist = NodeMatrix[np(n, 'y')];\n        distance = Math.sqrt(\n          Math.pow(xDist, 2) + Math.pow(yDist, 2)\n        );\n\n        if (W.settings.strongGravityMode) {\n\n          //-- Strong gravity\n          if (distance > 0)\n            factor = coefficient * NodeMatrix[np(n, 'mass')] * g;\n        }\n        else {\n\n          //-- Linear Anti-collision Repulsion n\n          if (distance > 0)\n            factor = coefficient * NodeMatrix[np(n, 'mass')] * g / distance;\n        }\n\n        // Updating node's dx and dy\n        NodeMatrix[np(n, 'dx')] -= xDist * factor;\n        NodeMatrix[np(n, 'dy')] -= yDist * factor;\n      }\n\n\n\n      // 4) Attraction\n      //---------------\n      coefficient = 1 *\n        (W.settings.outboundAttractionDistribution ?\n          outboundAttCompensation :\n          1);\n\n      // TODO: simplify distance\n      // TODO: coefficient is always used as -c --> optimize?\n      for (e = 0; e < W.edgesLength; e += W.ppe) {\n        n1 = EdgeMatrix[ep(e, 'source')];\n        n2 = EdgeMatrix[ep(e, 'target')];\n        w = EdgeMatrix[ep(e, 'weight')];\n\n        // Edge weight influence\n        ewc = Math.pow(w, W.settings.edgeWeightInfluence);\n\n        // Common measures\n        xDist = NodeMatrix[np(n1, 'x')] - NodeMatrix[np(n2, 'x')];\n        yDist = NodeMatrix[np(n1, 'y')] - NodeMatrix[np(n2, 'y')];\n\n        // Applying attraction to nodes\n        if (W.settings.adjustSizes) {\n\n          distance = Math.sqrt(\n            (Math.pow(xDist, 2) + Math.pow(yDist, 2)) -\n            NodeMatrix[np(n1, 'size')] -\n            NodeMatrix[np(n2, 'size')]\n          );\n\n          if (W.settings.linLogMode) {\n            if (W.settings.outboundAttractionDistribution) {\n\n              //-- LinLog Degree Distributed Anti-collision Attraction\n              if (distance > 0) {\n                factor = -coefficient * ewc * Math.log(1 + distance) /\n                distance /\n                NodeMatrix[np(n1, 'mass')];\n              }\n            }\n            else {\n\n              //-- LinLog Anti-collision Attraction\n              if (distance > 0) {\n                factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n              }\n            }\n          }\n          else {\n            if (W.settings.outboundAttractionDistribution) {\n\n              //-- Linear Degree Distributed Anti-collision Attraction\n              if (distance > 0) {\n                factor = -coefficient * ewc / NodeMatrix[np(n1, 'mass')];\n              }\n            }\n            else {\n\n              //-- Linear Anti-collision Attraction\n              if (distance > 0) {\n                factor = -coefficient * ewc;\n              }\n            }\n          }\n        }\n        else {\n\n          distance = Math.sqrt(\n            Math.pow(xDist, 2) + Math.pow(yDist, 2)\n          );\n\n          if (W.settings.linLogMode) {\n            if (W.settings.outboundAttractionDistribution) {\n\n              //-- LinLog Degree Distributed Attraction\n              if (distance > 0) {\n                factor = -coefficient * ewc * Math.log(1 + distance) /\n                  distance /\n                  NodeMatrix[np(n1, 'mass')];\n              }\n            }\n            else {\n\n              //-- LinLog Attraction\n              if (distance > 0)\n                factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n            }\n          }\n          else {\n            if (W.settings.outboundAttractionDistribution) {\n\n              //-- Linear Attraction Mass Distributed\n              // NOTE: Distance is set to 1 to override next condition\n              distance = 1;\n              factor = -coefficient * ewc / NodeMatrix[np(n1, 'mass')];\n            }\n            else {\n\n              //-- Linear Attraction\n              // NOTE: Distance is set to 1 to override next condition\n              distance = 1;\n              factor = -coefficient * ewc;\n            }\n          }\n        }\n\n        // Updating nodes' dx and dy\n        // TODO: if condition or factor = 1?\n        if (distance > 0) {\n\n          // Updating nodes' dx and dy\n          NodeMatrix[np(n1, 'dx')] += xDist * factor;\n          NodeMatrix[np(n1, 'dy')] += yDist * factor;\n\n          NodeMatrix[np(n2, 'dx')] -= xDist * factor;\n          NodeMatrix[np(n2, 'dy')] -= yDist * factor;\n        }\n      }\n\n\n      // 5) Apply Forces\n      //-----------------\n      var force,\n          swinging,\n          traction,\n          nodespeed;\n\n      // MATH: sqrt and square distances\n      if (W.settings.adjustSizes) {\n\n        for (n = 0; n < W.nodesLength; n += W.ppn) {\n          if (!NodeMatrix[np(n, 'fixed')]) {\n            force = Math.sqrt(\n              Math.pow(NodeMatrix[np(n, 'dx')], 2) +\n              Math.pow(NodeMatrix[np(n, 'dy')], 2)\n            );\n\n            if (force > W.maxForce) {\n              NodeMatrix[np(n, 'dx')] =\n                NodeMatrix[np(n, 'dx')] * W.maxForce / force;\n              NodeMatrix[np(n, 'dy')] =\n                NodeMatrix[np(n, 'dy')] * W.maxForce / force;\n            }\n\n            swinging = NodeMatrix[np(n, 'mass')] *\n              Math.sqrt(\n                (NodeMatrix[np(n, 'old_dx')] - NodeMatrix[np(n, 'dx')]) *\n                (NodeMatrix[np(n, 'old_dx')] - NodeMatrix[np(n, 'dx')]) +\n                (NodeMatrix[np(n, 'old_dy')] - NodeMatrix[np(n, 'dy')]) *\n                (NodeMatrix[np(n, 'old_dy')] - NodeMatrix[np(n, 'dy')])\n              );\n\n            traction = Math.sqrt(\n              (NodeMatrix[np(n, 'old_dx')] + NodeMatrix[np(n, 'dx')]) *\n              (NodeMatrix[np(n, 'old_dx')] + NodeMatrix[np(n, 'dx')]) +\n              (NodeMatrix[np(n, 'old_dy')] + NodeMatrix[np(n, 'dy')]) *\n              (NodeMatrix[np(n, 'old_dy')] + NodeMatrix[np(n, 'dy')])\n            ) / 2;\n\n            nodespeed =\n              0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n            // Updating node's positon\n            NodeMatrix[np(n, 'x')] =\n              NodeMatrix[np(n, 'x')] + NodeMatrix[np(n, 'dx')] *\n              (nodespeed / W.settings.slowDown);\n            NodeMatrix[np(n, 'y')] =\n              NodeMatrix[np(n, 'y')] + NodeMatrix[np(n, 'dy')] *\n              (nodespeed / W.settings.slowDown);\n          }\n        }\n      }\n      else {\n\n        for (n = 0; n < W.nodesLength; n += W.ppn) {\n          if (!NodeMatrix[np(n, 'fixed')]) {\n\n            swinging = NodeMatrix[np(n, 'mass')] *\n              Math.sqrt(\n                (NodeMatrix[np(n, 'old_dx')] - NodeMatrix[np(n, 'dx')]) *\n                (NodeMatrix[np(n, 'old_dx')] - NodeMatrix[np(n, 'dx')]) +\n                (NodeMatrix[np(n, 'old_dy')] - NodeMatrix[np(n, 'dy')]) *\n                (NodeMatrix[np(n, 'old_dy')] - NodeMatrix[np(n, 'dy')])\n              );\n\n            traction = Math.sqrt(\n              (NodeMatrix[np(n, 'old_dx')] + NodeMatrix[np(n, 'dx')]) *\n              (NodeMatrix[np(n, 'old_dx')] + NodeMatrix[np(n, 'dx')]) +\n              (NodeMatrix[np(n, 'old_dy')] + NodeMatrix[np(n, 'dy')]) *\n              (NodeMatrix[np(n, 'old_dy')] + NodeMatrix[np(n, 'dy')])\n            ) / 2;\n\n            nodespeed = NodeMatrix[np(n, 'convergence')] *\n              Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n            // Updating node convergence\n            NodeMatrix[np(n, 'convergence')] =\n              Math.min(1, Math.sqrt(\n                nodespeed *\n                (Math.pow(NodeMatrix[np(n, 'dx')], 2) +\n                 Math.pow(NodeMatrix[np(n, 'dy')], 2)) /\n                (1 + Math.sqrt(swinging))\n              ));\n\n            // Updating node's positon\n            NodeMatrix[np(n, 'x')] =\n              NodeMatrix[np(n, 'x')] + NodeMatrix[np(n, 'dx')] *\n              (nodespeed / W.settings.slowDown);\n            NodeMatrix[np(n, 'y')] =\n              NodeMatrix[np(n, 'y')] + NodeMatrix[np(n, 'dy')] *\n              (nodespeed / W.settings.slowDown);\n          }\n        }\n      }\n\n      // Counting one more iteration\n      W.iterations++;\n    }\n\n    /**\n     * Message reception & sending\n     */\n\n    // Sending data back to the supervisor\n    var sendNewCoords;\n\n    if (typeof window !== 'undefined' && window.document) {\n\n      // From same document as sigma\n      sendNewCoords = function() {\n        var e;\n\n        if (document.createEvent) {\n          e = document.createEvent('Event');\n          e.initEvent('newCoords', true, false);\n        }\n        else {\n          e = document.createEventObject();\n          e.eventType = 'newCoords';\n        }\n\n        e.eventName = 'newCoords';\n        e.data = {\n          nodes: NodeMatrix.buffer\n        };\n        requestAnimationFrame(function() {\n          document.dispatchEvent(e);\n        });\n      };\n    }\n    else {\n\n      // From a WebWorker\n      sendNewCoords = function() {\n        self.postMessage(\n          {nodes: NodeMatrix.buffer},\n          [NodeMatrix.buffer]\n        );\n      };\n    }\n\n    // Algorithm run\n    function run(n) {\n      for (var i = 0; i < n; i++)\n        pass();\n      sendNewCoords();\n    }\n\n    // On supervisor message\n    var listener = function(e) {\n      switch (e.data.action) {\n        case 'start':\n          init(\n            new Float32Array(e.data.nodes),\n            new Float32Array(e.data.edges),\n            e.data.config\n          );\n\n          // First iteration(s)\n          run(W.settings.startingIterations);\n          break;\n\n        case 'loop':\n          NodeMatrix = new Float32Array(e.data.nodes);\n          run(W.settings.iterationsPerRender);\n          break;\n\n        case 'config':\n\n          // Merging new settings\n          configure(e.data.config);\n          break;\n\n        case 'kill':\n\n          // Deleting context for garbage collection\n          __emptyObject(W);\n          NodeMatrix = null;\n          EdgeMatrix = null;\n          RegionMatrix = null;\n          self.removeEventListener('message', listener);\n          break;\n\n        default:\n      }\n    };\n\n    // Adding event listener\n    self.addEventListener('message', listener);\n  };\n\n\n  /**\n   * Exporting\n   * ----------\n   *\n   * Crush the worker function and make it accessible by sigma's instances so\n   * the supervisor can call it.\n   */\n  function crush(fnString) {\n    var pattern,\n        i,\n        l;\n\n    var np = [\n      'x',\n      'y',\n      'dx',\n      'dy',\n      'old_dx',\n      'old_dy',\n      'mass',\n      'convergence',\n      'size',\n      'fixed'\n    ];\n\n    var ep = [\n      'source',\n      'target',\n      'weight'\n    ];\n\n    var rp = [\n      'node',\n      'centerX',\n      'centerY',\n      'size',\n      'nextSibling',\n      'firstChild',\n      'mass',\n      'massCenterX',\n      'massCenterY'\n    ];\n\n    // rp\n    // NOTE: Must go first\n    for (i = 0, l = rp.length; i < l; i++) {\n      pattern = new RegExp('rp\\\\(([^,]*), \\'' + rp[i] + '\\'\\\\)', 'g');\n      fnString = fnString.replace(\n        pattern,\n        (i === 0) ? '$1' : '$1 + ' + i\n      );\n    }\n\n    // np\n    for (i = 0, l = np.length; i < l; i++) {\n      pattern = new RegExp('np\\\\(([^,]*), \\'' + np[i] + '\\'\\\\)', 'g');\n      fnString = fnString.replace(\n        pattern,\n        (i === 0) ? '$1' : '$1 + ' + i\n      );\n    }\n\n    // ep\n    for (i = 0, l = ep.length; i < l; i++) {\n      pattern = new RegExp('ep\\\\(([^,]*), \\'' + ep[i] + '\\'\\\\)', 'g');\n      fnString = fnString.replace(\n        pattern,\n        (i === 0) ? '$1' : '$1 + ' + i\n      );\n    }\n\n    return fnString;\n  }\n\n  // Exporting\n  function getWorkerFn() {\n    var fnString = crush ? crush(Worker.toString()) : Worker.toString();\n    return ';(' + fnString + ').call(this);';\n  }\n\n  if (inWebWorker) {\n\n    // We are in a webworker, so we launch the Worker function\n    eval(getWorkerFn());\n  }\n  else {\n\n    // We are requesting the worker from sigma, we retrieve it therefore\n    if (typeof sigma === 'undefined')\n      throw 'sigma is not declared';\n\n    sigma.prototype.getForceAtlas2Worker = getWorkerFn;\n  }\n}).call(window);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/layout.forceAtlas2.js\n// module id = ./node_modules/react-sigma/sigma/layout.forceAtlas2.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 125);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 125:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw new Error('sigma is not declared');\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.layout.noverlap');\n\n  /**\n   * Noverlap Layout\n   * ===============================\n   *\n   * Author: @apitts / Andrew Pitts\n   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)\n   * Acknowledgement: @sheyman / Sébastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)\n   * Version: 0.1\n   */\n\n  var settings = {\n    speed: 3,\n    scaleNodes: 1.2,\n    nodeMargin: 5.0,\n    gridSize: 20,\n    permittedExpansion: 1.1,\n    rendererIndex: 0,\n    maxIterations: 500\n  };\n\n  var _instance = {};\n\n  /**\n   * Event emitter Object\n   * ------------------\n   */\n  var _eventEmitter = {};\n\n   /**\n   * Noverlap Object\n   * ------------------\n   */\n  function Noverlap() {\n    var self = this;\n\n    this.init = function (sigInst, options) {\n      options = options || {};\n\n      // Properties\n      this.sigInst = sigInst;\n      this.config = sigma.utils.extend(options, settings);\n      this.easing = options.easing;\n      this.duration = options.duration;\n\n      if (options.nodes) {\n        this.nodes = options.nodes;\n        delete options.nodes;\n      }\n\n      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {\n        throw new Error('sigma.plugins.animate is not declared');\n      }\n\n      // State\n      this.running = false;\n    };\n\n    /**\n     * Single layout iteration.\n     */\n    this.atomicGo = function () {\n      if (!this.running || this.iterCount < 1) return false;\n\n      var nodes = this.nodes || this.sigInst.graph.nodes(),\n          nodesCount = nodes.length,\n          i,\n          n,\n          n1,\n          n2,\n          xmin = Infinity,\n          xmax = -Infinity,\n          ymin = Infinity,\n          ymax = -Infinity,\n          xwidth,\n          yheight,\n          xcenter,\n          ycenter,\n          grid,\n          row,\n          col,\n          minXBox,\n          maxXBox,\n          minYBox,\n          maxYBox,\n          adjacentNodes,\n          subRow,\n          subCol,\n          nxmin,\n          nxmax,\n          nymin,\n          nymax;\n\n      this.iterCount--;\n      this.running = false;\n\n      for (i=0; i < nodesCount; i++) {\n        n = nodes[i];\n        n.dn.dx = 0;\n        n.dn.dy = 0;\n\n        //Find the min and max for both x and y across all nodes\n        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );\n\n      }\n\n      xwidth = xmax - xmin;\n      yheight = ymax - ymin;\n      xcenter = (xmin + xmax) / 2;\n      ycenter = (ymin + ymax) / 2;\n      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;\n      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;\n      ymin = ycenter - self.config.permittedExpansion*yheight / 2;\n      ymax = ycenter + self.config.permittedExpansion*yheight / 2;\n\n      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid\n\n      for(row = 0; row < self.config.gridSize; row++) {\n        grid[row] = {};\n        for(col = 0; col < self.config.gridSize; col++) {\n          grid[row][col] = [];\n        }\n      }\n\n      //Place nodes in grid\n      for (i=0; i < nodesCount; i++) {\n        n = nodes[i];\n\n        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);\n\n        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );\n        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );\n        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );\n        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );\n        for(col = minXBox; col <= maxXBox; col++) {\n          for(row = minYBox; row <= maxYBox; row++) {\n            grid[row][col].push(n.id);\n          }\n        }\n      }\n\n\n      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes\n\n      for(row = 0; row < self.config.gridSize; row++) {\n        for(col = 0; col < self.config.gridSize; col++) {\n          grid[row][col].forEach(function(nodeId) {\n            if(!adjacentNodes[nodeId]) {\n              adjacentNodes[nodeId] = [];\n            }\n            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {\n              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {\n                grid[subRow][subCol].forEach(function(subNodeId) {\n                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {\n                    adjacentNodes[nodeId].push(subNodeId);\n                  }\n                });\n              }\n            }\n          });\n        }\n      }\n\n      //If two nodes overlap then repulse them\n      for (i=0; i < nodesCount; i++) {\n        n1 = nodes[i];\n        adjacentNodes[n1.id].forEach(function(nodeId) {\n          var n2 = self.sigInst.graph.nodes(nodeId);\n          var xDist = n2.dn_x - n1.dn_x;\n          var yDist = n2.dn_y - n1.dn_y;\n          var dist = Math.sqrt(xDist*xDist + yDist*yDist);\n          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));\n          if(collision) {\n            self.running = true;\n            if(dist > 0) {\n              n2.dn.dx += xDist / dist * (1 + n1.dn_size);\n              n2.dn.dy += yDist / dist * (1 + n1.dn_size);\n            } else {\n              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());\n              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());\n            }\n          }\n        });\n      }\n\n      for (i=0; i < nodesCount; i++) {\n        n = nodes[i];\n        if(!n.fixed) {\n          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;\n          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;\n        }\n      }\n\n      if(this.running && this.iterCount < 1) {\n        this.running = false;\n      }\n\n      return this.running;\n    };\n\n    this.go = function () {\n      this.iterCount = this.config.maxIterations;\n\n      while (this.running) {\n        this.atomicGo();\n      };\n\n      this.stop();\n    };\n\n    this.start = function() {\n      if (this.running) return;\n\n      var nodes = this.sigInst.graph.nodes();\n\n      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;\n\n      this.running = true;\n\n      // Init nodes\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].dn_x = nodes[i][prefix + 'x'];\n        nodes[i].dn_y = nodes[i][prefix + 'y'];\n        nodes[i].dn_size = nodes[i][prefix + 'size'];\n        nodes[i].dn = {\n          dx: 0,\n          dy: 0\n        };\n      }\n      _eventEmitter[self.sigInst.id].dispatchEvent('start');\n      this.go();\n    };\n\n    this.stop = function() {\n      var nodes = this.sigInst.graph.nodes();\n\n      this.running = false;\n\n      if (this.easing) {\n        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');\n        sigma.plugins.animate(\n          self.sigInst,\n          {\n            x: 'dn_x',\n            y: 'dn_y'\n          },\n          {\n            easing: self.easing,\n            onComplete: function() {\n              self.sigInst.refresh();\n              for (var i = 0; i < nodes.length; i++) {\n                nodes[i].dn = null;\n                nodes[i].dn_x = null;\n                nodes[i].dn_y = null;\n              }\n              _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n            },\n            duration: self.duration\n          }\n        );\n      }\n      else {\n        // Apply changes\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].x = nodes[i].dn_x;\n          nodes[i].y = nodes[i].dn_y;\n        }\n\n        this.sigInst.refresh();\n\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].dn = null;\n          nodes[i].dn_x = null;\n          nodes[i].dn_y = null;\n        }\n        _eventEmitter[self.sigInst.id].dispatchEvent('stop');\n      }\n    };\n\n    this.kill = function() {\n      this.sigInst = null;\n      this.config = null;\n      this.easing = null;\n    };\n  };\n\n  /**\n   * Interface\n   * ----------\n   */\n\n  /**\n   * Configure the layout algorithm.\n\n   * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameter in the settings\n   * object:\n   *\n   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision\n   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes\n   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size\n   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.\n   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation\n   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration\n   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.\n   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the\n   *                                            quadraticInOut easing from this package will be used instead.\n   *   {?number}            duration            The duration of the animation. If not specified, the \"animationsTime\" setting value of the sigma instance will be used instead.\n   *\n   *\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n  sigma.prototype.configNoverlap = function(config) {\n\n    var sigInst = this;\n\n    if (!config) throw new Error('Missing argument: \"config\"');\n\n    // Create instance if undefined\n    if (!_instance[sigInst.id]) {\n      _instance[sigInst.id] = new Noverlap();\n\n      _eventEmitter[sigInst.id] = {};\n      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);\n\n      // Binding on kill to clear the references\n      sigInst.bind('kill', function() {\n        _instance[sigInst.id].kill();\n        _instance[sigInst.id] = null;\n        _eventEmitter[sigInst.id] = null;\n      });\n    }\n\n    _instance[sigInst.id].init(sigInst, config);\n\n    return _eventEmitter[sigInst.id];\n  };\n\n  /**\n   * Start the layout algorithm. It will use the existing configuration if no\n   * new configuration is passed.\n\n   * Recognized options:\n   * **********************\n   * Here is the exhaustive list of every accepted parameter in the settings\n   * object\n   *\n   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision\n   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes\n   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size\n   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.\n   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation\n   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration\n   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.\n   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the\n   *                                            quadraticInOut easing from this package will be used instead.\n   *   {?number}            duration            The duration of the animation. If not specified, the \"animationsTime\" setting value of the sigma instance will be used instead.\n   *\n   *\n   *\n   * @param  {object} config  The optional configuration object.\n   *\n   * @return {sigma.classes.dispatcher} Returns an event emitter.\n   */\n\n  sigma.prototype.startNoverlap = function(config) {\n\n    var sigInst = this;\n\n    if (config) {\n      this.configNoverlap(sigInst, config);\n    }\n\n    _instance[sigInst.id].start();\n\n    return _eventEmitter[sigInst.id];\n  };\n\n  /**\n   * Returns true if the layout has started and is not completed.\n   *\n   * @return {boolean}\n   */\n  sigma.prototype.isNoverlapRunning = function() {\n\n    var sigInst = this;\n\n    return !!_instance[sigInst.id] && _instance[sigInst.id].running;\n  };\n\n}).call(this);\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/layout.noverlap.js\n// module id = ./node_modules/react-sigma/sigma/layout.noverlap.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 81);\n/******/ })\n/************************************************************************/\n/******/ (Array(34).concat([\n/* 34 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.mouse = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // MOUSE MANAGEMENT:\n        // *****************\n        // The mouse position when the user starts dragging:\n        _startMouseX,\n        _startMouseY,\n\n        _isMouseDown,\n        _isMoving,\n        _hasDragged,\n        _downStartTime,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);\n    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);\n    _target.addEventListener('mousewheel', _wheelHandler, false);\n    _target.addEventListener('mousemove', _moveHandler, false);\n    _target.addEventListener('mousedown', _downHandler, false);\n    _target.addEventListener('click', _clickHandler, false);\n    _target.addEventListener('mouseout', _outHandler, false);\n    document.addEventListener('mouseup', _upHandler, false);\n\n\n\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'click');\n      _target.removeEventListener('DOMMouseScroll', _wheelHandler);\n      _target.removeEventListener('mousewheel', _wheelHandler);\n      _target.removeEventListener('mousemove', _moveHandler);\n      _target.removeEventListener('mousedown', _downHandler);\n      _target.removeEventListener('click', _clickHandler);\n      _target.removeEventListener('mouseout', _outHandler);\n      document.removeEventListener('mouseup', _upHandler);\n    };\n\n\n\n\n    // MOUSE EVENTS:\n    // *************\n\n    /**\n     * The handler listening to the 'move' mouse event. It will effectively\n     * drag the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _moveHandler(e) {\n      var x,\n          y,\n          pos;\n\n      // Dispatch event:\n      if (_settings('mouseEnabled')) {\n        _self.dispatchEvent('mousemove',\n          sigma.utils.mouseCoords(e));\n\n        if (_isMouseDown) {\n          _isMoving = true;\n          _hasDragged = true;\n\n          if (_movingTimeoutId)\n            clearTimeout(_movingTimeoutId);\n\n          _movingTimeoutId = setTimeout(function() {\n            _isMoving = false;\n          }, _settings('dragTimeout'));\n\n          sigma.misc.animation.killAll(_camera);\n\n          _camera.isMoving = true;\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - _startMouseX,\n            sigma.utils.getY(e) - _startMouseY,\n            true\n          );\n\n          x = _startCameraX - pos.x;\n          y = _startCameraY - pos.y;\n\n          if (x !== _camera.x || y !== _camera.y) {\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _camera.goTo({\n              x: x,\n              y: y\n            });\n          }\n\n          if (e.preventDefault)\n            e.preventDefault();\n          else\n            e.returnValue = false;\n\n          e.stopPropagation();\n          return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'up' mouse event. It will stop dragging the\n     * graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _upHandler(e) {\n      if (_settings('mouseEnabled') && _isMouseDown) {\n        _isMouseDown = false;\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _camera.isMoving = false;\n\n        var x = sigma.utils.getX(e),\n            y = sigma.utils.getY(e);\n\n        if (_isMoving) {\n          sigma.misc.animation.killAll(_camera);\n          sigma.misc.animation.camera(\n            _camera,\n            {\n              x: _camera.x +\n                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),\n              y: _camera.y +\n                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)\n            },\n            {\n              easing: 'quadraticOut',\n              duration: _settings('mouseInertiaDuration')\n            }\n          );\n        } else if (\n          _startMouseX !== x ||\n          _startMouseY !== y\n        )\n          _camera.goTo({\n            x: _camera.x,\n            y: _camera.y\n          });\n\n        _self.dispatchEvent('mouseup',\n          sigma.utils.mouseCoords(e));\n\n        // Update _isMoving flag:\n        _isMoving = false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'down' mouse event. It will start observing\n     * the mouse position for dragging the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _downHandler(e) {\n      if (_settings('mouseEnabled')) {\n        _startCameraX = _camera.x;\n        _startCameraY = _camera.y;\n\n        _lastCameraX = _camera.x;\n        _lastCameraY = _camera.y;\n\n        _startMouseX = sigma.utils.getX(e);\n        _startMouseY = sigma.utils.getY(e);\n\n        _hasDragged = false;\n        _downStartTime = (new Date()).getTime();\n\n        switch (e.which) {\n          case 2:\n            // Middle mouse button pressed\n            // Do nothing.\n            break;\n          case 3:\n            // Right mouse button pressed\n            _self.dispatchEvent('rightclick',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n            break;\n          // case 1:\n          default:\n            // Left mouse button pressed\n            _isMouseDown = true;\n\n            _self.dispatchEvent('mousedown',\n              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'out' mouse event. It will just redispatch\n     * the event.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _outHandler(e) {\n      if (_settings('mouseEnabled'))\n        _self.dispatchEvent('mouseout');\n    }\n\n    /**\n     * The handler listening to the 'click' mouse event. It will redispatch the\n     * click event, but with normalized X and Y coordinates.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _clickHandler(e) {\n      if (_settings('mouseEnabled')) {\n        var event = sigma.utils.mouseCoords(e);\n        event.isDragging =\n          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;\n        _self.dispatchEvent('click', event);\n      }\n\n      if (e.preventDefault)\n        e.preventDefault();\n      else\n        e.returnValue = false;\n\n      e.stopPropagation();\n      return false;\n    }\n\n    /**\n     * The handler listening to the double click custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _doubleClickHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (_settings('mouseEnabled')) {\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        _self.dispatchEvent('doubleclick',\n            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration')\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the 'wheel' mouse event. It will basically zoom\n     * in or not into the graph.\n     *\n     * @param {event} e A mouse event.\n     */\n    function _wheelHandler(e) {\n      var pos,\n          ratio,\n          animation,\n          wheelDelta = sigma.utils.getDelta(e);\n\n      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {\n        ratio = wheelDelta > 0 ?\n          1 / _settings('zoomingRatio') :\n          _settings('zoomingRatio');\n\n        pos = _camera.cameraPosition(\n          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,\n          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,\n          true\n        );\n\n        animation = {\n          duration: _settings('mouseZoomDuration')\n        };\n\n        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.captors');\n\n  /**\n   * The user inputs default captor. It deals with mouse events, keyboards\n   * events and touch events.\n   *\n   * @param  {DOMElement}   target   The DOM element where the listeners will be\n   *                                 bound.\n   * @param  {camera}       camera   The camera related to the target.\n   * @param  {configurable} settings The settings function.\n   * @return {sigma.captor}          The fresh new captor instance.\n   */\n  sigma.captors.touch = function(target, camera, settings) {\n    var _self = this,\n        _target = target,\n        _camera = camera,\n        _settings = settings,\n\n        // CAMERA MANAGEMENT:\n        // ******************\n        // The camera position when the user starts dragging:\n        _startCameraX,\n        _startCameraY,\n        _startCameraAngle,\n        _startCameraRatio,\n\n        // The latest stage position:\n        _lastCameraX,\n        _lastCameraY,\n        _lastCameraAngle,\n        _lastCameraRatio,\n\n        // TOUCH MANAGEMENT:\n        // *****************\n        // Touches that are down:\n        _downTouches = [],\n\n        _startTouchX0,\n        _startTouchY0,\n        _startTouchX1,\n        _startTouchY1,\n        _startTouchAngle,\n        _startTouchDistance,\n\n        _touchMode,\n\n        _isMoving,\n        _doubleTap,\n        _movingTimeoutId;\n\n    sigma.classes.dispatcher.extend(this);\n\n    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);\n    _target.addEventListener('touchstart', _handleStart, false);\n    _target.addEventListener('touchend', _handleLeave, false);\n    _target.addEventListener('touchcancel', _handleLeave, false);\n    _target.addEventListener('touchleave', _handleLeave, false);\n    _target.addEventListener('touchmove', _handleMove, false);\n\n    function position(e) {\n      var offset = sigma.utils.getOffset(_target);\n\n      return {\n        x: e.pageX - offset.left,\n        y: e.pageY - offset.top\n      };\n    }\n\n    /**\n     * This method unbinds every handlers that makes the captor work.\n     */\n    this.kill = function() {\n      sigma.utils.unbindDoubleClick(_target, 'touchstart');\n      _target.addEventListener('touchstart', _handleStart);\n      _target.addEventListener('touchend', _handleLeave);\n      _target.addEventListener('touchcancel', _handleLeave);\n      _target.addEventListener('touchleave', _handleLeave);\n      _target.addEventListener('touchmove', _handleMove);\n    };\n\n    // TOUCH EVENTS:\n    // *************\n    /**\n     * The handler listening to the 'touchstart' event. It will set the touch\n     * mode (\"_touchMode\") and start observing the user touch moves.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleStart(e) {\n      if (_settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            pos0,\n            pos1;\n\n        _downTouches = e.touches;\n\n        switch (_downTouches.length) {\n          case 1:\n            _camera.isMoving = true;\n            _touchMode = 1;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            pos0 = position(_downTouches[0]);\n            _startTouchX0 = pos0.x;\n            _startTouchY0 = pos0.y;\n\n            break;\n          case 2:\n            _camera.isMoving = true;\n            _touchMode = 2;\n\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            _lastCameraX = _camera.x;\n            _lastCameraY = _camera.y;\n\n            _startCameraAngle = _camera.angle;\n            _startCameraRatio = _camera.ratio;\n\n            _startCameraX = _camera.x;\n            _startCameraY = _camera.y;\n\n            _startTouchX0 = x0;\n            _startTouchY0 = y0;\n            _startTouchX1 = x1;\n            _startTouchY1 = y1;\n\n            _startTouchAngle = Math.atan2(\n              _startTouchY1 - _startTouchY0,\n              _startTouchX1 - _startTouchX0\n            );\n            _startTouchDistance = Math.sqrt(\n              (_startTouchY1 - _startTouchY0) *\n                (_startTouchY1 - _startTouchY0) +\n              (_startTouchX1 - _startTouchX0) *\n                (_startTouchX1 - _startTouchX0)\n            );\n\n            e.preventDefault();\n            return false;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'\n     * event. It will update the touch mode if there are still at least one\n     * finger, and stop dragging else.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleLeave(e) {\n      if (_settings('touchEnabled')) {\n        _downTouches = e.touches;\n        var inertiaRatio = _settings('touchInertiaRatio');\n\n        if (_movingTimeoutId) {\n          _isMoving = false;\n          clearTimeout(_movingTimeoutId);\n        }\n\n        switch (_touchMode) {\n          case 2:\n            if (e.touches.length === 1) {\n              _handleStart(e);\n\n              e.preventDefault();\n              break;\n            }\n            /* falls through */\n          case 1:\n            _camera.isMoving = false;\n            _self.dispatchEvent('stopDrag');\n\n            if (_isMoving) {\n              _doubleTap = false;\n              sigma.misc.animation.camera(\n                _camera,\n                {\n                  x: _camera.x +\n                    inertiaRatio * (_camera.x - _lastCameraX),\n                  y: _camera.y +\n                    inertiaRatio * (_camera.y - _lastCameraY)\n                },\n                {\n                  easing: 'quadraticOut',\n                  duration: _settings('touchInertiaDuration')\n                }\n              );\n            }\n\n            _isMoving = false;\n            _touchMode = 0;\n            break;\n        }\n      }\n    }\n\n    /**\n     * The handler listening to the 'touchmove' event. It will effectively drag\n     * the graph, and eventually zooms and turn it if the user is using two\n     * fingers.\n     *\n     * @param {event} e A touch event.\n     */\n    function _handleMove(e) {\n      if (!_doubleTap && _settings('touchEnabled')) {\n        var x0,\n            x1,\n            y0,\n            y1,\n            cos,\n            sin,\n            end,\n            pos0,\n            pos1,\n            diff,\n            start,\n            dAngle,\n            dRatio,\n            newStageX,\n            newStageY,\n            newStageRatio,\n            newStageAngle;\n\n        _downTouches = e.touches;\n        _isMoving = true;\n\n        if (_movingTimeoutId)\n          clearTimeout(_movingTimeoutId);\n\n        _movingTimeoutId = setTimeout(function() {\n          _isMoving = false;\n        }, _settings('dragTimeout'));\n\n        switch (_touchMode) {\n          case 1:\n            pos0 = position(_downTouches[0]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n\n            diff = _camera.cameraPosition(\n              x0 - _startTouchX0,\n              y0 - _startTouchY0,\n              true\n            );\n\n            newStageX = _startCameraX - diff.x;\n            newStageY = _startCameraY - diff.y;\n\n            if (newStageX !== _camera.x || newStageY !== _camera.y) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY\n              });\n\n              _self.dispatchEvent('mousemove',\n                sigma.utils.mouseCoords(e, pos0.x, pos0.y));\n\n              _self.dispatchEvent('drag');\n            }\n            break;\n          case 2:\n            pos0 = position(_downTouches[0]);\n            pos1 = position(_downTouches[1]);\n            x0 = pos0.x;\n            y0 = pos0.y;\n            x1 = pos1.x;\n            y1 = pos1.y;\n\n            start = _camera.cameraPosition(\n              (_startTouchX0 + _startTouchX1) / 2 -\n                sigma.utils.getCenter(e).x,\n              (_startTouchY0 + _startTouchY1) / 2 -\n                sigma.utils.getCenter(e).y,\n              true\n            );\n            end = _camera.cameraPosition(\n              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,\n              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,\n              true\n            );\n\n            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;\n            dRatio = Math.sqrt(\n              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)\n            ) / _startTouchDistance;\n\n            // Translation:\n            x0 = start.x;\n            y0 = start.y;\n\n            // Homothetic transformation:\n            newStageRatio = _startCameraRatio / dRatio;\n            x0 = x0 * dRatio;\n            y0 = y0 * dRatio;\n\n            // Rotation:\n            newStageAngle = _startCameraAngle - dAngle;\n            cos = Math.cos(-dAngle);\n            sin = Math.sin(-dAngle);\n            x1 = x0 * cos + y0 * sin;\n            y1 = y0 * cos - x0 * sin;\n            x0 = x1;\n            y0 = y1;\n\n            // Finalize:\n            newStageX = x0 - end.x + _startCameraX;\n            newStageY = y0 - end.y + _startCameraY;\n\n            if (\n              newStageRatio !== _camera.ratio ||\n              newStageAngle !== _camera.angle ||\n              newStageX !== _camera.x ||\n              newStageY !== _camera.y\n            ) {\n              _lastCameraX = _camera.x;\n              _lastCameraY = _camera.y;\n              _lastCameraAngle = _camera.angle;\n              _lastCameraRatio = _camera.ratio;\n\n              _camera.goTo({\n                x: newStageX,\n                y: newStageY,\n                angle: newStageAngle,\n                ratio: newStageRatio\n              });\n\n              _self.dispatchEvent('drag');\n            }\n\n            break;\n        }\n\n        e.preventDefault();\n        return false;\n      }\n    }\n\n    /**\n     * The handler listening to the double tap custom event. It will\n     * basically zoom into the graph.\n     *\n     * @param {event} e A touch event.\n     */\n    function _doubleTapHandler(e) {\n      var pos,\n          ratio,\n          animation;\n\n      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {\n        _doubleTap = true;\n\n        ratio = 1 / _settings('doubleClickZoomingRatio');\n\n        pos = position(e.touches[0]);\n        _self.dispatchEvent('doubleclick',\n          sigma.utils.mouseCoords(e, pos.x, pos.y));\n\n        if (_settings('doubleClickEnabled')) {\n          pos = _camera.cameraPosition(\n            pos.x - sigma.utils.getCenter(e).x,\n            pos.y - sigma.utils.getCenter(e).y,\n            true\n          );\n\n          animation = {\n            duration: _settings('doubleClickZoomDuration'),\n            onComplete: function() {\n              _doubleTap = false;\n            }\n          };\n\n          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);\n        }\n\n        if (e.preventDefault)\n          e.preventDefault();\n        else\n          e.returnValue = false;\n\n        e.stopPropagation();\n        return false;\n      }\n    }\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.classes');\n\n  /**\n   * The camera constructor. It just initializes its attributes and methods.\n   *\n   * @param  {string}       id       The id.\n   * @param  {sigma.classes.graph}  graph    The graph.\n   * @param  {configurable} settings The settings function.\n   * @param  {?object}      options  Eventually some overriding options.\n   * @return {camera}                Returns the fresh new camera instance.\n   */\n  sigma.classes.camera = function(id, graph, settings, options) {\n    sigma.classes.dispatcher.extend(this);\n\n    Object.defineProperty(this, 'graph', {\n      value: graph\n    });\n    Object.defineProperty(this, 'id', {\n      value: id\n    });\n    Object.defineProperty(this, 'readPrefix', {\n      value: 'read_cam' + id + ':'\n    });\n    Object.defineProperty(this, 'prefix', {\n      value: 'cam' + id + ':'\n    });\n\n    this.x = 0;\n    this.y = 0;\n    this.ratio = 1;\n    this.angle = 0;\n    this.isAnimated = false;\n    this.settings = (typeof options === 'object' && options) ?\n      settings.embedObject(options) :\n      settings;\n  };\n\n  /**\n   * Updates the camera position.\n   *\n   * @param  {object} coordinates The new coordinates object.\n   * @return {camera}             Returns the camera.\n   */\n  sigma.classes.camera.prototype.goTo = function(coordinates) {\n    if (!this.settings('enableCamera'))\n      return this;\n\n    var i,\n        l,\n        c = coordinates || {},\n        keys = ['x', 'y', 'ratio', 'angle'];\n\n    for (i = 0, l = keys.length; i < l; i++)\n      if (c[keys[i]] !== undefined) {\n        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))\n          this[keys[i]] = c[keys[i]];\n        else\n          throw 'Value for \"' + keys[i] + '\" is not a number.';\n      }\n\n    this.dispatchEvent('coordinatesUpdated');\n    return this;\n  };\n\n  /**\n   * This method takes a graph and computes for each node and edges its\n   * coordinates relatively to the center of the camera. Basically, it will\n   * compute the coordinates that will be used by the graphic renderers.\n   *\n   * Since it should be possible to use different cameras and different\n   * renderers, it is possible to specify a prefix to put before the new\n   * coordinates (to get something like \"node.camera1_x\")\n   *\n   * @param  {?string} read    The prefix of the coordinates to read.\n   * @param  {?string} write   The prefix of the coordinates to write.\n   * @param  {?object} options Eventually an object of options. Those can be:\n   *                           - A restricted nodes array.\n   *                           - A restricted edges array.\n   *                           - A width.\n   *                           - A height.\n   * @return {camera}        Returns the camera.\n   */\n  sigma.classes.camera.prototype.applyView = function(read, write, options) {\n    options = options || {};\n    write = write !== undefined ? write : this.prefix;\n    read = read !== undefined ? read : this.readPrefix;\n\n    var nodes = options.nodes || this.graph.nodes(),\n        edges = options.edges || this.graph.edges();\n\n    var i,\n        l,\n        node,\n        relCos = Math.cos(this.angle) / this.ratio,\n        relSin = Math.sin(this.angle) / this.ratio,\n        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),\n        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),\n        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,\n        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;\n\n    for (i = 0, l = nodes.length; i < l; i++) {\n      node = nodes[i];\n      node[write + 'x'] =\n        (node[read + 'x'] || 0) * relCos +\n        (node[read + 'y'] || 0) * relSin +\n        xOffset;\n      node[write + 'y'] =\n        (node[read + 'y'] || 0) * relCos -\n        (node[read + 'x'] || 0) * relSin +\n        yOffset;\n      node[write + 'size'] =\n        (node[read + 'size'] || 0) /\n        nodeRatio;\n    }\n\n    for (i = 0, l = edges.length; i < l; i++) {\n      edges[i][write + 'size'] =\n        (edges[i][read + 'size'] || 0) /\n        edgeRatio;\n    }\n\n    return this;\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * camera to the frame of the graph.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    camera.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    camera.\n   * @return {object}   The point coordinates in the frame of the graph.\n   */\n  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: (x * cos + y * sin) / this.ratio + X,\n      y: (y * cos - x * sin) / this.ratio + Y\n    };\n  };\n\n  /**\n   * This function converts the coordinates of a point from the frame of the\n   * graph to the frame of the camera.\n   *\n   * @param  {number} x The X coordinate of the point in the frame of the\n   *                    graph.\n   * @param  {number} y The Y coordinate of the point in the frame of the\n   *                    graph.\n   * @return {object}   The point coordinates in the frame of the camera.\n   */\n  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {\n    var X = 0,\n        Y = 0,\n        cos = Math.cos(this.angle),\n        sin = Math.sin(this.angle);\n\n    // Revert the origin differential vector:\n    if (!vector) {\n      X = - (this.x * cos + this.y * sin) / this.ratio;\n      Y = - (this.y * cos - this.x * sin) / this.ratio;\n    }\n\n    return {\n      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,\n      y: ((y - Y) * cos + (x - X) * sin) * this.ratio\n    };\n  };\n\n  /**\n   * This method returns the transformation matrix of the camera. This is\n   * especially useful to apply the camera view directly in shaders, in case of\n   * WebGL rendering.\n   *\n   * @return {array} The transformation matrix.\n   */\n  sigma.classes.camera.prototype.getMatrix = function() {\n    var scale = sigma.utils.matrices.scale(1 / this.ratio),\n        rotation = sigma.utils.matrices.rotation(this.angle),\n        translation = sigma.utils.matrices.translation(-this.x, -this.y),\n        matrix = sigma.utils.matrices.multiply(\n          translation,\n          sigma.utils.matrices.multiply(\n            rotation,\n            scale\n          )\n        );\n\n    return matrix;\n  };\n\n  /**\n   * Taking a width and a height as parameters, this method returns the\n   * coordinates of the rectangle representing the camera on screen, in the\n   * graph's referentiel.\n   *\n   * To keep displaying labels of nodes going out of the screen, the method\n   * keeps a margin around the screen in the returned rectangle.\n   *\n   * @param  {number} width  The width of the screen.\n   * @param  {number} height The height of the screen.\n   * @return {object}        The rectangle as x1, y1, x2 and y2, representing\n   *                         two opposite points.\n   */\n  sigma.classes.camera.prototype.getRectangle = function(width, height) {\n    var widthVect = this.cameraPosition(width, 0, true),\n        heightVect = this.cameraPosition(0, height, true),\n        centerVect = this.cameraPosition(width / 2, height / 2, true),\n        marginX = this.cameraPosition(width / 4, 0, true).x,\n        marginY = this.cameraPosition(0, height / 4, true).y;\n\n    return {\n      x1: this.x - centerVect.x - marginX,\n      y1: this.y - centerVect.y - marginY,\n      x2: this.x - centerVect.x + marginX + widthVect.x,\n      y2: this.y - centerVect.y - marginY + widthVect.y,\n      height: Math.sqrt(\n        Math.pow(heightVect.x, 2) +\n        Math.pow(heightVect.y + 2 * marginY, 2)\n      )\n    };\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  /**\n   * This utils aims to facilitate the manipulation of each instance setting.\n   * Using a function instead of an object brings two main advantages: First,\n   * it will be easier in the future to catch settings updates through a\n   * function than an object. Second, giving it a full object will \"merge\" it\n   * to the settings object properly, keeping us to have to always add a loop.\n   *\n   * @return {configurable} The \"settings\" function.\n   */\n  var configurable = function() {\n    var i,\n        l,\n        data = {},\n        datas = Array.prototype.slice.call(arguments, 0);\n\n    /**\n     * The method to use to set or get any property of this instance.\n     *\n     * @param  {string|object}    a1 If it is a string and if a2 is undefined,\n     *                               then it will return the corresponding\n     *                               property. If it is a string and if a2 is\n     *                               set, then it will set a2 as the property\n     *                               corresponding to a1, and return this. If\n     *                               it is an object, then each pair string +\n     *                               object(or any other type) will be set as a\n     *                               property.\n     * @param  {*?}               a2 The new property corresponding to a1 if a1\n     *                               is a string.\n     * @return {*|configurable}      Returns itself or the corresponding\n     *                               property.\n     *\n     * Polymorphism:\n     * *************\n     * Here are some basic use examples:\n     *\n     *  > settings = new configurable();\n     *  > settings('mySetting', 42);\n     *  > settings('mySetting'); // Logs: 42\n     *  > settings('mySetting', 123);\n     *  > settings('mySetting'); // Logs: 123\n     *  > settings({mySetting: 456});\n     *  > settings('mySetting'); // Logs: 456\n     *\n     * Also, it is possible to use the function as a fallback:\n     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'\n     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456\n     */\n    var settings = function(a1, a2) {\n      var o,\n          i,\n          l,\n          k;\n\n      if (arguments.length === 1 && typeof a1 === 'string') {\n        if (data[a1] !== undefined)\n          return data[a1];\n        for (i = 0, l = datas.length; i < l; i++)\n          if (datas[i][a1] !== undefined)\n            return datas[i][a1];\n        return undefined;\n      } else if (typeof a1 === 'object' && typeof a2 === 'string') {\n        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);\n      } else {\n        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};\n\n        if (typeof a1 === 'string')\n          o[a1] = a2;\n\n        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)\n          data[k[i]] = o[k[i]];\n\n        return this;\n      }\n    };\n\n    /**\n     * This method returns a new configurable function, with new objects\n     *\n     * @param  {object*}  Any number of objects to search in.\n     * @return {function} Returns the function. Check its documentation to know\n     *                    more about how it works.\n     */\n    settings.embedObjects = function() {\n      var args = datas.concat(\n        data\n      ).concat(\n        Array.prototype.splice.call(arguments, 0)\n      );\n\n      return configurable.apply({}, args);\n    };\n\n    // Initialize\n    for (i = 0, l = arguments.length; i < l; i++)\n      settings(arguments[i]);\n\n    return settings;\n  };\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.configurable = configurable;\n  } else if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = configurable;\n    exports.configurable = configurable;\n  } else\n    this.configurable = configurable;\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  /**\n   * Dispatcher constructor.\n   *\n   * @return {dispatcher} The new dispatcher instance.\n   */\n  var dispatcher = function() {\n    Object.defineProperty(this, '_handlers', {\n      value: {}\n    });\n  };\n\n\n\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string}           events  The name of the event (or the events\n   *                                    separated by spaces).\n   * @param  {function(Object)} handler The handler to bind.\n   * @return {dispatcher}               Returns the instance itself.\n   */\n  dispatcher.prototype.bind = function(events, handler) {\n    var i,\n        l,\n        event,\n        eArray;\n\n    if (\n      arguments.length === 1 &&\n      typeof arguments[0] === 'object'\n    )\n      for (events in arguments[0])\n        this.bind(events, arguments[0][events]);\n    else if (\n      arguments.length === 2 &&\n      typeof arguments[1] === 'function'\n    ) {\n      eArray = typeof events === 'string' ? events.split(' ') : events;\n\n      for (i = 0, l = eArray.length; i !== l; i += 1) {\n        event = eArray[i];\n\n        // Check that event is not '':\n        if (!event)\n          continue;\n\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        this._handlers[event].push({\n          handler: handler\n        });\n      }\n    } else\n      throw 'bind: Wrong arguments.';\n\n    return this;\n  };\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {dispatcher}                Returns the instance itself.\n   */\n  dispatcher.prototype.unbind = function(events, handler) {\n    var i,\n        n,\n        j,\n        m,\n        k,\n        a,\n        event,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    if (!arguments.length) {\n      for (k in this._handlers)\n        delete this._handlers[k];\n      return this;\n    }\n\n    if (handler) {\n      for (i = 0, n = eArray.length; i !== n; i += 1) {\n        event = eArray[i];\n        if (this._handlers[event]) {\n          a = [];\n          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)\n            if (this._handlers[event][j].handler !== handler)\n              a.push(this._handlers[event][j]);\n\n          this._handlers[event] = a;\n        }\n\n        if (this._handlers[event] && this._handlers[event].length === 0)\n          delete this._handlers[event];\n      }\n    } else\n      for (i = 0, n = eArray.length; i !== n; i += 1)\n        delete this._handlers[eArray[i]];\n\n    return this;\n  };\n\n  /**\n   * Executes each handler bound to the event\n   *\n   * @param  {string}     events The name of the event (or the events separated\n   *                             by spaces).\n   * @param  {?object}    data   The content of the event (optional).\n   * @return {dispatcher}        Returns the instance itself.\n   */\n  dispatcher.prototype.dispatchEvent = function(events, data) {\n    var i,\n        n,\n        j,\n        m,\n        a,\n        event,\n        eventName,\n        self = this,\n        eArray = typeof events === 'string' ? events.split(' ') : events;\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, n = eArray.length; i !== n; i += 1) {\n      eventName = eArray[i];\n\n      if (this._handlers[eventName]) {\n        event = self.getEvent(eventName, data);\n        a = [];\n\n        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {\n          this._handlers[eventName][j].handler(event);\n          if (!this._handlers[eventName][j].one)\n            a.push(this._handlers[eventName][j]);\n        }\n\n        this._handlers[eventName] = a;\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Return an event object.\n   *\n   * @param  {string}  events The name of the event.\n   * @param  {?object} data   The content of the event (optional).\n   * @return {object}         Returns the instance itself.\n   */\n  dispatcher.prototype.getEvent = function(event, data) {\n    return {\n      type: event,\n      data: data || {},\n      target: this\n    };\n  };\n\n  /**\n   * A useful function to deal with inheritance. It will make the target\n   * inherit the prototype of the class dispatcher as well as its constructor.\n   *\n   * @param {object} target The target.\n   */\n  dispatcher.extend = function(target, args) {\n    var k;\n\n    for (k in dispatcher.prototype)\n      if (dispatcher.prototype.hasOwnProperty(k))\n        target[k] = dispatcher.prototype[k];\n\n    dispatcher.apply(target, args);\n  };\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.dispatcher = dispatcher;\n  } else if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = dispatcher;\n    exports.dispatcher = dispatcher;\n  } else\n    this.dispatcher = dispatcher;\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module for edges\n   * ===============================\n   *\n   * Author: Sébastien Heymann,\n   *   from the quad of Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge with x1, y1, x2, y2 and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph edge with at least two points\n     *                  (x1, y1), (x2, y2) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    lineToSquare: function(e) {\n      if (e.y1 < e.y2) {\n        // (e.x1, e.y1) on top\n        if (e.x1 < e.x2) {\n          // (e.x1, e.y1) on left\n          return {\n            x1: e.x1 - e.size,\n            y1: e.y1 - e.size,\n            x2: e.x2 + e.size,\n            y2: e.y1 - e.size,\n            height: e.y2 - e.y1 + e.size * 2\n          };\n        }\n        // (e.x1, e.y1) on right\n        return {\n          x1: e.x2 - e.size,\n          y1: e.y1 - e.size,\n          x2: e.x1 + e.size,\n          y2: e.y1 - e.size,\n          height: e.y2 - e.y1 + e.size * 2\n        };\n      }\n\n      // (e.x2, e.y2) on top\n      if (e.x1 < e.x2) {\n        // (e.x1, e.y1) on left\n        return {\n          x1: e.x1 - e.size,\n          y1: e.y2 - e.size,\n          x2: e.x2 + e.size,\n          y2: e.y2 - e.size,\n          height: e.y1 - e.y2 + e.size * 2\n        };\n      }\n      // (e.x2, e.y2) on right\n      return {\n        x1: e.x2 - e.size,\n        y1: e.y2 - e.size,\n        x2: e.x1 + e.size,\n        y2: e.y2 - e.size,\n        height: e.y1 - e.y2 + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,\n     * control point and size into an axis-aligned square.\n     *\n     * @param  {object} e  A graph edge with at least two points\n     *                     (x1, y1), (x2, y2) and a size.\n     * @param  {object} cp A control point (x,y).\n     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.\n     */\n    quadraticCurveToSquare: function(e, cp) {\n      var pt = sigma.utils.getPointOnQuadraticCurve(\n        0.5,\n        e.x1,\n        e.y1,\n        e.x2,\n        e.y2,\n        cp.x,\n        cp.y\n      );\n\n      // Bounding box of the two points and the point at the middle of the\n      // curve:\n      var minX = Math.min(e.x1, e.x2, pt.x),\n          maxX = Math.max(e.x1, e.x2, pt.x),\n          minY = Math.min(e.y1, e.y2, pt.y),\n          maxY = Math.max(e.y1, e.y2, pt.y);\n\n      return {\n        x1: minX - e.size,\n        y1: minY - e.size,\n        x2: maxX + e.size,\n        y2: minY - e.size,\n        height: maxY - minY + e.size * 2\n      };\n    },\n\n    /**\n     * Transforms a graph self loop into an axis-aligned square.\n     *\n     * @param  {object} n A graph node with a point (x, y) and a size.\n     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.\n     */\n    selfLoopToSquare: function(n) {\n      // Fitting to the curve is too costly, we compute a larger bounding box\n      // using the control points:\n      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);\n\n      // Bounding box of the point and the two control points:\n      var minX = Math.min(n.x, cp.x1, cp.x2),\n          maxX = Math.max(n.x, cp.x1, cp.x2),\n          minY = Math.min(n.y, cp.y1, cp.y2),\n          maxY = Math.max(n.y, cp.y1, cp.y2);\n\n      return {\n        x1: minX - n.size,\n        y1: minY - n.size,\n        x2: maxX + n.size,\n        y2: minY - n.size,\n        height: maxY - minY + n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 40,\n      maxLevel: maxLevel || 8,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The edgequad API as exposed to sigma.\n   */\n\n  /**\n   * The edgequad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree     Property holding the quadtree object.\n   * property {object} _geom     Exposition of the _geom namespace for testing.\n   * property {object} _cache    Cache for the area method.\n   * property {boolean} _enabled Can index and retreive elements.\n   */\n  var edgequad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n    this._enabled = true;\n  };\n\n  /**\n   * Index a graph by inserting its edges into the quadtree.\n   *\n   * @param  {object} graph   A graph instance.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for edge geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  edgequad.prototype.index = function(graph, params) {\n    if (!this._enabled)\n      return this._tree;\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.edgequad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '',\n        cp,\n        source,\n        target,\n        n,\n        e;\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    var edges = graph.edges();\n\n    // Inserting graph edges into the tree\n    for (var i = 0, l = edges.length; i < l; i++) {\n      source = graph.nodes(edges[i].source);\n      target = graph.nodes(edges[i].target);\n      e = {\n        x1: source[prefix + 'x'],\n        y1: source[prefix + 'y'],\n        x2: target[prefix + 'x'],\n        y2: target[prefix + 'y'],\n        size: edges[i][prefix + 'size'] || 0\n      };\n\n      // Inserting edge\n      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {\n        if (source.id === target.id) {\n          n = {\n            x: source[prefix + 'x'],\n            y: source[prefix + 'y'],\n            size: source[prefix + 'size'] || 0\n          };\n          _quadInsert(\n            edges[i],\n            _geom.selfLoopToSquare(n),\n            this._tree);\n        }\n        else {\n          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);\n          _quadInsert(\n            edges[i],\n            _geom.quadraticCurveToSquare(e, cp),\n            this._tree);\n        }\n      }\n      else {\n        _quadInsert(\n          edges[i],\n          _geom.lineToSquare(e),\n          this._tree);\n      }\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph edges held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.point = function(x, y) {\n    if (!this._enabled)\n      return [];\n\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph edges within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of edges retrieved.\n   */\n  edgequad.prototype.area = function(rect) {\n    if (!this._enabled)\n      return [];\n\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving edges\n    var edges = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var edgesArray = [];\n    for (var i in edges)\n      edgesArray.push(edges[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = edgesArray;\n\n    return edgesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.edgequad = edgequad;\n  } else if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = edgequad;\n    exports.edgequad = edgequad;\n  } else\n    this.edgequad = edgequad;\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  var _methods = Object.create(null),\n      _indexes = Object.create(null),\n      _initBindings = Object.create(null),\n      _methodBindings = Object.create(null),\n      _methodBeforeBindings = Object.create(null),\n      _defaultSettings = {\n        immutable: true,\n        clone: true\n      },\n      _defaultSettingsFunction = function(key) {\n        return _defaultSettings[key];\n      };\n\n  /**\n   * The graph constructor. It initializes the data and the indexes, and binds\n   * the custom indexes and methods to its own scope.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {boolean} clone     Indicates if the data have to be cloned in methods\n   *                       to add nodes or edges.\n   *   {boolean} immutable Indicates if nodes \"id\" values and edges \"id\",\n   *                       \"source\" and \"target\" values must be set as\n   *                       immutable.\n   *\n   * @param  {?configurable} settings Eventually a settings function.\n   * @return {graph}                  The new graph instance.\n   */\n  var graph = function(settings) {\n    var k,\n        fn,\n        data;\n\n    /**\n     * DATA:\n     * *****\n     * Every data that is callable from graph methods are stored in this \"data\"\n     * object. This object will be served as context for all these methods,\n     * and it is possible to add other type of data in it.\n     */\n    data = {\n      /**\n       * SETTINGS FUNCTION:\n       * ******************\n       */\n      settings: settings || _defaultSettingsFunction,\n\n      /**\n       * MAIN DATA:\n       * **********\n       */\n      nodesArray: [],\n      edgesArray: [],\n\n      /**\n       * GLOBAL INDEXES:\n       * ***************\n       * These indexes just index data by ids.\n       */\n      nodesIndex: Object.create(null),\n      edgesIndex: Object.create(null),\n\n      /**\n       * LOCAL INDEXES:\n       * **************\n       * These indexes refer from node to nodes. Each key is an id, and each\n       * value is the array of the ids of related nodes.\n       */\n      inNeighborsIndex: Object.create(null),\n      outNeighborsIndex: Object.create(null),\n      allNeighborsIndex: Object.create(null),\n\n      inNeighborsCount: Object.create(null),\n      outNeighborsCount: Object.create(null),\n      allNeighborsCount: Object.create(null)\n    };\n\n    // Execute bindings:\n    for (k in _initBindings)\n      _initBindings[k].call(data);\n\n    // Add methods to both the scope and the data objects:\n    for (k in _methods) {\n      fn = __bindGraphMethod(k, data, _methods[k]);\n      this[k] = fn;\n      data[k] = fn;\n    }\n  };\n\n\n\n\n  /**\n   * A custom tool to bind methods such that function that are bound to it will\n   * be executed anytime the method is called.\n   *\n   * @param  {string}   methodName The name of the method to bind.\n   * @param  {object}   scope      The scope where the method must be executed.\n   * @param  {function} fn         The method itself.\n   * @return {function}            The new method.\n   */\n  function __bindGraphMethod(methodName, scope, fn) {\n    var result = function() {\n      var k,\n          res;\n\n      // Execute \"before\" bound functions:\n      for (k in _methodBeforeBindings[methodName])\n        _methodBeforeBindings[methodName][k].apply(scope, arguments);\n\n      // Apply the method:\n      res = fn.apply(scope, arguments);\n\n      // Execute bound functions:\n      for (k in _methodBindings[methodName])\n        _methodBindings[methodName][k].apply(scope, arguments);\n\n      // Return res:\n      return res;\n    };\n\n    return result;\n  }\n\n  /**\n   * This custom tool function removes every pair key/value from an hash. The\n   * goal is to avoid creating a new object while some other references are\n   * still hanging in some scopes...\n   *\n   * @param  {object} obj The object to empty.\n   * @return {object}     The empty object.\n   */\n  function __emptyObject(obj) {\n    var k;\n\n    for (k in obj)\n      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))\n        delete obj[k];\n\n    return obj;\n  }\n\n\n\n\n  /**\n   * This global method adds a method that will be bound to the futurly created\n   * graph instances.\n   *\n   * Since these methods will be bound to their scope when the instances are\n   * created, it does not use the prototype. Because of that, methods have to\n   * be added before instances are created to make them available.\n   *\n   * Here is an example:\n   *\n   *  > graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesArray.length;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *\n   * @param  {string}   methodName The name of the method.\n   * @param  {function} fn         The method itself.\n   * @return {object}              The global graph constructor.\n   */\n  graph.addMethod = function(methodName, fn) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length !== 2\n    )\n      throw 'addMethod: Wrong arguments.';\n\n    if (_methods[methodName] || graph[methodName])\n      throw 'The method \"' + methodName + '\" already exists.';\n\n    _methods[methodName] = fn;\n    _methodBindings[methodName] = Object.create(null);\n    _methodBeforeBindings[methodName] = Object.create(null);\n\n    return this;\n  };\n\n  /**\n   * This global method returns true if the method has already been added, and\n   * false else.\n   *\n   * Here are some examples:\n   *\n   *  > graph.hasMethod('addNode'); // returns true\n   *  > graph.hasMethod('hasMethod'); // returns true\n   *  > graph.hasMethod('unexistingMethod'); // returns false\n   *\n   * @param  {string}  methodName The name of the method.\n   * @return {boolean}            The result.\n   */\n  graph.hasMethod = function(methodName) {\n    return !!(_methods[methodName] || graph[methodName]);\n  };\n\n  /**\n   * This global methods attaches a function to a method. Anytime the specified\n   * method is called, the attached function is called right after, with the\n   * same arguments and in the same scope. The attached function is called\n   * right before if the last argument is true, unless the method is the graph\n   * constructor.\n   *\n   * To attach a function to the graph constructor, use 'constructor' as the\n   * method name (first argument).\n   *\n   * The main idea is to have a clean way to keep custom indexes up to date,\n   * for instance:\n   *\n   *  > var timesAddNodeCalled = 0;\n   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {\n   *  >   timesAddNodeCalled++;\n   *  > });\n   *  >\n   *  > var myGraph = new graph();\n   *  > console.log(timesAddNodeCalled); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(timesAddNodeCalled); // outputs 2\n   *\n   * The idea for calling a function before is to provide pre-processors, for\n   * instance:\n   *\n   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };\n   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {\n   *  >   n.color = colorPalette[n.category];\n   *  > }, true);\n   *  >\n   *  > var myGraph = new graph();\n   *  > myGraph.addNode({ id: 'n0', category: 'Person' });\n   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'\n   *\n   * @param  {string}   methodName The name of the related method or\n   *                               \"constructor\".\n   * @param  {string}   key        The key to identify the function to attach.\n   * @param  {function} fn         The function to bind.\n   * @param  {boolean}  before     If true the function is called right before.\n   * @return {object}              The global graph constructor.\n   */\n  graph.attach = function(methodName, key, fn, before) {\n    if (\n      typeof methodName !== 'string' ||\n      typeof key !== 'string' ||\n      typeof fn !== 'function' ||\n      arguments.length < 3 ||\n      arguments.length > 4\n    )\n      throw 'attach: Wrong arguments.';\n\n    var bindings;\n\n    if (methodName === 'constructor')\n      bindings = _initBindings;\n    else {\n      if (before) {\n        if (!_methodBeforeBindings[methodName])\n        throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBeforeBindings[methodName];\n      }\n      else {\n        if (!_methodBindings[methodName])\n          throw 'The method \"' + methodName + '\" does not exist.';\n\n        bindings = _methodBindings[methodName];\n      }\n    }\n\n    if (bindings[key])\n      throw 'A function \"' + key + '\" is already attached ' +\n            'to the method \"' + methodName + '\".';\n\n    bindings[key] = fn;\n\n    return this;\n  };\n\n  /**\n   * Alias of attach(methodName, key, fn, true).\n   */\n  graph.attachBefore = function(methodName, key, fn) {\n    return this.attach(methodName, key, fn, true);\n  };\n\n  /**\n   * This methods is just an helper to deal with custom indexes. It takes as\n   * arguments the name of the index and an object containing all the different\n   * functions to bind to the methods.\n   *\n   * Here is a basic example, that creates an index to keep the number of nodes\n   * in the current graph. It also adds a method to provide a getter on that\n   * new index:\n   *\n   *  > sigma.classes.graph.addIndex('nodesCount', {\n   *  >   constructor: function() {\n   *  >     this.nodesCount = 0;\n   *  >   },\n   *  >   addNode: function() {\n   *  >     this.nodesCount++;\n   *  >   },\n   *  >   dropNode: function() {\n   *  >     this.nodesCount--;\n   *  >   }\n   *  > });\n   *  >\n   *  > sigma.classes.graph.addMethod('getNodesCount', function() {\n   *  >   return this.nodesCount;\n   *  > });\n   *  >\n   *  > var myGraph = new sigma.classes.graph();\n   *  > console.log(myGraph.getNodesCount()); // outputs 0\n   *  >\n   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });\n   *  > console.log(myGraph.getNodesCount()); // outputs 2\n   *\n   * @param  {string} name     The name of the index.\n   * @param  {object} bindings The object containing the functions to bind.\n   * @return {object}          The global graph constructor.\n   */\n  graph.addIndex = function(name, bindings) {\n    if (\n      typeof name !== 'string' ||\n      Object(bindings) !== bindings ||\n      arguments.length !== 2\n    )\n      throw 'addIndex: Wrong arguments.';\n\n    if (_indexes[name])\n      throw 'The index \"' + name + '\" already exists.';\n\n    var k;\n\n    // Store the bindings:\n    _indexes[name] = bindings;\n\n    // Attach the bindings:\n    for (k in bindings)\n      if (typeof bindings[k] !== 'function')\n        throw 'The bindings must be functions.';\n      else\n        graph.attach(k, name, bindings[k]);\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method adds a node to the graph. The node must be an object, with a\n   * string under the key \"id\". Except for this, it is possible to add any\n   * other attribute, that will be preserved all along the manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the node will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id will be defined as immutable.\n   *\n   * @param  {object} node The node to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addNode', function(node) {\n    // Check that the node is an object and has an id:\n    if (Object(node) !== node || arguments.length !== 1)\n      throw 'addNode: Wrong arguments.';\n\n    if (typeof node.id !== 'string' && typeof node.id !== 'number')\n      throw 'The node must have a string or number id.';\n\n    if (this.nodesIndex[node.id])\n      throw 'The node \"' + node.id + '\" already exists.';\n\n    var k,\n        id = node.id,\n        validNode = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in node)\n        if (k !== 'id')\n          validNode[k] = node[k];\n    } else\n      validNode = node;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable'))\n      Object.defineProperty(validNode, 'id', {\n        value: id,\n        enumerable: true\n      });\n    else\n      validNode.id = id;\n\n    // Add empty containers for edges indexes:\n    this.inNeighborsIndex[id] = Object.create(null);\n    this.outNeighborsIndex[id] = Object.create(null);\n    this.allNeighborsIndex[id] = Object.create(null);\n\n    this.inNeighborsCount[id] = 0;\n    this.outNeighborsCount[id] = 0;\n    this.allNeighborsCount[id] = 0;\n\n    // Add the node to indexes:\n    this.nodesArray.push(validNode);\n    this.nodesIndex[validNode.id] = validNode;\n\n    // Return the current instance:\n    return this;\n  });\n\n  /**\n   * This method adds an edge to the graph. The edge must be an object, with a\n   * string under the key \"id\", and strings under the keys \"source\" and\n   * \"target\" that design existing nodes. Except for this, it is possible to\n   * add any other attribute, that will be preserved all along the\n   * manipulations.\n   *\n   * If the graph option \"clone\" has a truthy value, the edge will be cloned\n   * when added to the graph. Also, if the graph option \"immutable\" has a\n   * truthy value, its id, source and target will be defined as immutable.\n   *\n   * @param  {object} edge The edge to add.\n   * @return {object}      The graph instance.\n   */\n  graph.addMethod('addEdge', function(edge) {\n    // Check that the edge is an object and has an id:\n    if (Object(edge) !== edge || arguments.length !== 1)\n      throw 'addEdge: Wrong arguments.';\n\n    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')\n      throw 'The edge must have a string or number id.';\n\n    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||\n        !this.nodesIndex[edge.source])\n      throw 'The edge source must have an existing node id.';\n\n    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||\n        !this.nodesIndex[edge.target])\n      throw 'The edge target must have an existing node id.';\n\n    if (this.edgesIndex[edge.id])\n      throw 'The edge \"' + edge.id + '\" already exists.';\n\n    var k,\n        validEdge = Object.create(null);\n\n    // Check the \"clone\" option:\n    if (this.settings('clone')) {\n      for (k in edge)\n        if (k !== 'id' && k !== 'source' && k !== 'target')\n          validEdge[k] = edge[k];\n    } else\n      validEdge = edge;\n\n    // Check the \"immutable\" option:\n    if (this.settings('immutable')) {\n      Object.defineProperty(validEdge, 'id', {\n        value: edge.id,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'source', {\n        value: edge.source,\n        enumerable: true\n      });\n\n      Object.defineProperty(validEdge, 'target', {\n        value: edge.target,\n        enumerable: true\n      });\n    } else {\n      validEdge.id = edge.id;\n      validEdge.source = edge.source;\n      validEdge.target = edge.target;\n    }\n\n    // Add the edge to indexes:\n    this.edgesArray.push(validEdge);\n    this.edgesIndex[validEdge.id] = validEdge;\n\n    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])\n      this.inNeighborsIndex[validEdge.target][validEdge.source] =\n        Object.create(null);\n    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n      validEdge;\n\n    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])\n      this.outNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])\n      this.allNeighborsIndex[validEdge.source][validEdge.target] =\n        Object.create(null);\n    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =\n      validEdge;\n\n    if (validEdge.target !== validEdge.source) {\n      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])\n        this.allNeighborsIndex[validEdge.target][validEdge.source] =\n          Object.create(null);\n      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =\n        validEdge;\n    }\n\n    // Keep counts up to date:\n    this.inNeighborsCount[validEdge.target]++;\n    this.outNeighborsCount[validEdge.source]++;\n    this.allNeighborsCount[validEdge.target]++;\n    this.allNeighborsCount[validEdge.source]++;\n\n    return this;\n  });\n\n  /**\n   * This method drops a node from the graph. It also removes each edge that is\n   * bound to it, through the dropEdge method. An error is thrown if the node\n   * does not exist.\n   *\n   * @param  {string} id The node id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropNode', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropNode: Wrong arguments.';\n\n    if (!this.nodesIndex[id])\n      throw 'The node \"' + id + '\" does not exist.';\n\n    var i, k, l;\n\n    // Remove the node from indexes:\n    delete this.nodesIndex[id];\n    for (i = 0, l = this.nodesArray.length; i < l; i++)\n      if (this.nodesArray[i].id === id) {\n        this.nodesArray.splice(i, 1);\n        break;\n      }\n\n    // Remove related edges:\n    for (i = this.edgesArray.length - 1; i >= 0; i--)\n      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)\n        this.dropEdge(this.edgesArray[i].id);\n\n    // Remove related edge indexes:\n    delete this.inNeighborsIndex[id];\n    delete this.outNeighborsIndex[id];\n    delete this.allNeighborsIndex[id];\n\n    delete this.inNeighborsCount[id];\n    delete this.outNeighborsCount[id];\n    delete this.allNeighborsCount[id];\n\n    for (k in this.nodesIndex) {\n      delete this.inNeighborsIndex[k][id];\n      delete this.outNeighborsIndex[k][id];\n      delete this.allNeighborsIndex[k][id];\n    }\n\n    return this;\n  });\n\n  /**\n   * This method drops an edge from the graph. An error is thrown if the edge\n   * does not exist.\n   *\n   * @param  {string} id The edge id.\n   * @return {object}    The graph instance.\n   */\n  graph.addMethod('dropEdge', function(id) {\n    // Check that the arguments are valid:\n    if ((typeof id !== 'string' && typeof id !== 'number') ||\n        arguments.length !== 1)\n      throw 'dropEdge: Wrong arguments.';\n\n    if (!this.edgesIndex[id])\n      throw 'The edge \"' + id + '\" does not exist.';\n\n    var i, l, edge;\n\n    // Remove the edge from indexes:\n    edge = this.edgesIndex[id];\n    delete this.edgesIndex[id];\n    for (i = 0, l = this.edgesArray.length; i < l; i++)\n      if (this.edgesArray[i].id === id) {\n        this.edgesArray.splice(i, 1);\n        break;\n      }\n\n    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];\n    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)\n      delete this.inNeighborsIndex[edge.target][edge.source];\n\n    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)\n      delete this.outNeighborsIndex[edge.source][edge.target];\n\n    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];\n    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)\n      delete this.allNeighborsIndex[edge.source][edge.target];\n\n    if (edge.target !== edge.source) {\n      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];\n      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)\n        delete this.allNeighborsIndex[edge.target][edge.source];\n    }\n\n    this.inNeighborsCount[edge.target]--;\n    this.outNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.source]--;\n    this.allNeighborsCount[edge.target]--;\n\n    return this;\n  });\n\n  /**\n   * This method destroys the current instance. It basically empties each index\n   * and methods attached to the graph.\n   */\n  graph.addMethod('kill', function() {\n    // Delete arrays:\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n    delete this.nodesArray;\n    delete this.edgesArray;\n\n    // Delete indexes:\n    delete this.nodesIndex;\n    delete this.edgesIndex;\n    delete this.inNeighborsIndex;\n    delete this.outNeighborsIndex;\n    delete this.allNeighborsIndex;\n    delete this.inNeighborsCount;\n    delete this.outNeighborsCount;\n    delete this.allNeighborsCount;\n  });\n\n  /**\n   * This method empties the nodes and edges arrays, as well as the different\n   * indexes.\n   *\n   * @return {object} The graph instance.\n   */\n  graph.addMethod('clear', function() {\n    this.nodesArray.length = 0;\n    this.edgesArray.length = 0;\n\n    // Due to GC issues, I prefer not to create new object. These objects are\n    // only available from the methods and attached functions, but still, it is\n    // better to prevent ghost references to unrelevant data...\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.edgesIndex);\n    __emptyObject(this.nodesIndex);\n    __emptyObject(this.inNeighborsIndex);\n    __emptyObject(this.outNeighborsIndex);\n    __emptyObject(this.allNeighborsIndex);\n    __emptyObject(this.inNeighborsCount);\n    __emptyObject(this.outNeighborsCount);\n    __emptyObject(this.allNeighborsCount);\n\n    return this;\n  });\n\n  /**\n   * This method reads an object and adds the nodes and edges, through the\n   * proper methods \"addNode\" and \"addEdge\".\n   *\n   * Here is an example:\n   *\n   *  > var myGraph = new graph();\n   *  > myGraph.read({\n   *  >   nodes: [\n   *  >     { id: 'n0' },\n   *  >     { id: 'n1' }\n   *  >   ],\n   *  >   edges: [\n   *  >     {\n   *  >       id: 'e0',\n   *  >       source: 'n0',\n   *  >       target: 'n1'\n   *  >     }\n   *  >   ]\n   *  > });\n   *  >\n   *  > console.log(\n   *  >   myGraph.nodes().length,\n   *  >   myGraph.edges().length\n   *  > ); // outputs 2 1\n   *\n   * @param  {object} g The graph object.\n   * @return {object}   The graph instance.\n   */\n  graph.addMethod('read', function(g) {\n    var i,\n        a,\n        l;\n\n    a = g.nodes || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addNode(a[i]);\n\n    a = g.edges || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addEdge(a[i]);\n\n    return this;\n  });\n\n  /**\n   * This methods returns one or several nodes, depending on how it is called.\n   *\n   * To get the array of nodes, call \"nodes\" without argument. To get a\n   * specific node, call it with the id of the node. The get multiple node,\n   * call it with an array of ids, and it will return the array of nodes, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related node or array of nodes.\n   */\n  graph.addMethod('nodes', function(v) {\n    // Clone the array of nodes and return it:\n    if (!arguments.length)\n      return this.nodesArray.slice(0);\n\n    // Return the related node:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.nodesIndex[v];\n\n    // Return an array of the related node:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.nodesIndex[v[i]]);\n        else\n          throw 'nodes: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'nodes: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns the degree of one or several nodes, depending on how\n   * it is called. It is also possible to get incoming or outcoming degrees\n   * instead by specifying 'in' or 'out' as a second argument.\n   *\n   * @param  {string|array} v     One id, an array of ids.\n   * @param  {?string}      which Which degree is required. Values are 'in',\n   *                              'out', and by default the normal degree.\n   * @return {number|array}       The related degree or array of degrees.\n   */\n  graph.addMethod('degree', function(v, which) {\n    // Check which degree is required:\n    which = {\n      'in': this.inNeighborsCount,\n      'out': this.outNeighborsCount\n    }[which || ''] || this.allNeighborsCount;\n\n    // Return the related node:\n    if (typeof v === 'string' || typeof v === 'number')\n      return which[v];\n\n    // Return an array of the related node:\n    if (Object.prototype.toString.call(v) === '[object Array]') {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(which[v[i]]);\n        else\n          throw 'degree: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'degree: Wrong arguments.';\n  });\n\n  /**\n   * This methods returns one or several edges, depending on how it is called.\n   *\n   * To get the array of edges, call \"edges\" without argument. To get a\n   * specific edge, call it with the id of the edge. The get multiple edge,\n   * call it with an array of ids, and it will return the array of edges, in\n   * the same order.\n   *\n   * @param  {?(string|array)} v Eventually one id, an array of ids.\n   * @return {object|array}      The related edge or array of edges.\n   */\n  graph.addMethod('edges', function(v) {\n    // Clone the array of edges and return it:\n    if (!arguments.length)\n      return this.edgesArray.slice(0);\n\n    // Return the related edge:\n    if (arguments.length === 1 &&\n        (typeof v === 'string' || typeof v === 'number'))\n      return this.edgesIndex[v];\n\n    // Return an array of the related edge:\n    if (\n      arguments.length === 1 &&\n      Object.prototype.toString.call(v) === '[object Array]'\n    ) {\n      var i,\n          l,\n          a = [];\n\n      for (i = 0, l = v.length; i < l; i++)\n        if (typeof v[i] === 'string' || typeof v[i] === 'number')\n          a.push(this.edgesIndex[v[i]]);\n        else\n          throw 'edges: Wrong arguments.';\n\n      return a;\n    }\n\n    throw 'edges: Wrong arguments.';\n  });\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof sigma !== 'undefined') {\n    sigma.classes = sigma.classes || Object.create(null);\n    sigma.classes.graph = graph;\n  } else if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = graph;\n    exports.graph = graph;\n  } else\n    this.graph = graph;\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * Sigma Quadtree Module\n   * =====================\n   *\n   * Author: Guillaume Plique (Yomguithereal)\n   * Version: 0.2\n   */\n\n\n\n  /**\n   * Quad Geometric Operations\n   * -------------------------\n   *\n   * A useful batch of geometric operations used by the quadtree.\n   */\n\n  var _geom = {\n\n    /**\n     * Transforms a graph node with x, y and size into an\n     * axis-aligned square.\n     *\n     * @param  {object} A graph node with at least a point (x, y) and a size.\n     * @return {object} A square: two points (x1, y1), (x2, y2) and height.\n     */\n    pointToSquare: function(n) {\n      return {\n        x1: n.x - n.size,\n        y1: n.y - n.size,\n        x2: n.x + n.size,\n        y2: n.y - n.size,\n        height: n.size * 2\n      };\n    },\n\n    /**\n     * Checks whether a rectangle is axis-aligned.\n     *\n     * @param  {object}  A rectangle defined by two points\n     *                   (x1, y1) and (x2, y2).\n     * @return {boolean} True if the rectangle is axis-aligned.\n     */\n    isAxisAligned: function(r) {\n      return r.x1 === r.x2 || r.y1 === r.y2;\n    },\n\n    /**\n     * Compute top points of an axis-aligned rectangle. This is useful in\n     * cases when the rectangle has been rotated (left, right or bottom up) and\n     * later operations need to know the top points.\n     *\n     * @param  {object} An axis-aligned rectangle defined by two points\n     *                  (x1, y1), (x2, y2) and height.\n     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.\n     */\n    axisAlignedTopPoints: function(r) {\n\n      // Basic\n      if (r.y1 === r.y2 && r.x1 < r.x2)\n        return r;\n\n      // Rotated to right\n      if (r.x1 === r.x2 && r.y2 > r.y1)\n        return {\n          x1: r.x1 - r.height, y1: r.y1,\n          x2: r.x1, y2: r.y1,\n          height: r.height\n        };\n\n      // Rotated to left\n      if (r.x1 === r.x2 && r.y2 < r.y1)\n        return {\n          x1: r.x1, y1: r.y2,\n          x2: r.x2 + r.height, y2: r.y2,\n          height: r.height\n        };\n\n      // Bottom's up\n      return {\n        x1: r.x2, y1: r.y1 - r.height,\n        x2: r.x1, y2: r.y1 - r.height,\n        height: r.height\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower left corner from its top points.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerLeftCoor: function(r) {\n      var width = (\n        Math.sqrt(\n          Math.pow(r.x2 - r.x1, 2) +\n          Math.pow(r.y2 - r.y1, 2)\n        )\n      );\n\n      return {\n        x: r.x1 - (r.y2 - r.y1) * r.height / width,\n        y: r.y1 + (r.x2 - r.x1) * r.height / width\n      };\n    },\n\n    /**\n     * Get coordinates of a rectangle's lower right corner from its top points\n     * and its lower left corner.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @param  {object} A corner's coordinates (x, y).\n     * @return {object} Coordinates of the corner (x, y).\n     */\n    lowerRightCoor: function(r, llc) {\n      return {\n        x: llc.x - r.x1 + r.x2,\n        y: llc.y - r.y1 + r.y2\n      };\n    },\n\n    /**\n     * Get the coordinates of all the corners of a rectangle from its top point.\n     *\n     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).\n     * @return {array}  An array of the four corners' coordinates (x, y).\n     */\n    rectangleCorners: function(r) {\n      var llc = this.lowerLeftCoor(r),\n          lrc = this.lowerRightCoor(r, llc);\n\n      return [\n        {x: r.x1, y: r.y1},\n        {x: r.x2, y: r.y2},\n        {x: llc.x, y: llc.y},\n        {x: lrc.x, y: lrc.y}\n      ];\n    },\n\n    /**\n     * Split a square defined by its boundaries into four.\n     *\n     * @param  {object} Boundaries of the square (x, y, width, height).\n     * @return {array}  An array containing the four new squares, themselves\n     *                  defined by an array of their four corners (x, y).\n     */\n    splitSquare: function(b) {\n      return [\n        [\n          {x: b.x, y: b.y},\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y},\n          {x: b.x + b.width, y: b.y},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2}\n        ],\n        [\n          {x: b.x, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x, y: b.y + b.height},\n          {x: b.x + b.width / 2, y: b.y + b.height}\n        ],\n        [\n          {x: b.x + b.width / 2, y: b.y + b.height / 2},\n          {x: b.x + b.width, y: b.y + b.height / 2},\n          {x: b.x + b.width / 2, y: b.y + b.height},\n          {x: b.x + b.width, y: b.y + b.height}\n        ]\n      ];\n    },\n\n    /**\n     * Compute the four axis between corners of rectangle A and corners of\n     * rectangle B. This is needed later to check an eventual collision.\n     *\n     * @param  {array} An array of rectangle A's four corners (x, y).\n     * @param  {array} An array of rectangle B's four corners (x, y).\n     * @return {array} An array of four axis defined by their coordinates (x,y).\n     */\n    axis: function(c1, c2) {\n      return [\n        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},\n        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},\n        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},\n        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}\n      ];\n    },\n\n    /**\n     * Project a rectangle's corner on an axis.\n     *\n     * @param  {object} Coordinates of a corner (x, y).\n     * @param  {object} Coordinates of an axis (x, y).\n     * @return {object} The projection defined by coordinates (x, y).\n     */\n    projection: function(c, a) {\n      var l = (\n        (c.x * a.x + c.y * a.y) /\n        (Math.pow(a.x, 2) + Math.pow(a.y, 2))\n      );\n\n      return {\n        x: l * a.x,\n        y: l * a.y\n      };\n    },\n\n    /**\n     * Check whether two rectangles collide on one particular axis.\n     *\n     * @param  {object}   An axis' coordinates (x, y).\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide on the axis.\n     */\n    axisCollision: function(a, c1, c2) {\n      var sc1 = [],\n          sc2 = [];\n\n      for (var ci = 0; ci < 4; ci++) {\n        var p1 = this.projection(c1[ci], a),\n            p2 = this.projection(c2[ci], a);\n\n        sc1.push(p1.x * a.x + p1.y * a.y);\n        sc2.push(p2.x * a.x + p2.y * a.y);\n      }\n\n      var maxc1 = Math.max.apply(Math, sc1),\n          maxc2 = Math.max.apply(Math, sc2),\n          minc1 = Math.min.apply(Math, sc1),\n          minc2 = Math.min.apply(Math, sc2);\n\n      return (minc2 <= maxc1 && maxc2 >= minc1);\n    },\n\n    /**\n     * Check whether two rectangles collide on each one of their four axis. If\n     * all axis collide, then the two rectangles do collide on the plane.\n     *\n     * @param  {array}    Rectangle A's corners.\n     * @param  {array}    Rectangle B's corners.\n     * @return {boolean}  True if the rectangles collide.\n     */\n    collision: function(c1, c2) {\n      var axis = this.axis(c1, c2),\n          col = true;\n\n      for (var i = 0; i < 4; i++)\n        col = col && this.axisCollision(axis[i], c1, c2);\n\n      return col;\n    }\n  };\n\n\n  /**\n   * Quad Functions\n   * ------------\n   *\n   * The Quadtree functions themselves.\n   * For each of those functions, we consider that in a splitted quad, the\n   * index of each node is the following:\n   * 0: top left\n   * 1: top right\n   * 2: bottom left\n   * 3: bottom right\n   *\n   * Moreover, the hereafter quad's philosophy is to consider that if an element\n   * collides with more than one nodes, this element belongs to each of the\n   * nodes it collides with where other would let it lie on a higher node.\n   */\n\n  /**\n   * Get the index of the node containing the point in the quad\n   *\n   * @param  {object}  point      A point defined by coordinates (x, y).\n   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).\n   * @return {integer}            The index of the node containing the point.\n   */\n  function _quadIndex(point, quadBounds) {\n    var xmp = quadBounds.x + quadBounds.width / 2,\n        ymp = quadBounds.y + quadBounds.height / 2,\n        top = (point.y < ymp),\n        left = (point.x < xmp);\n\n    if (top) {\n      if (left)\n        return 0;\n      else\n        return 1;\n    }\n    else {\n      if (left)\n        return 2;\n      else\n        return 3;\n    }\n  }\n\n  /**\n   * Get a list of indexes of nodes containing an axis-aligned rectangle\n   *\n   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),\n   *                               (x2, y2) and height.\n   * @param  {array}   quadCorners An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadIndexes(rectangle, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if ((rectangle.x2 >= quadCorners[i][0].x) &&\n          (rectangle.x1 <= quadCorners[i][1].x) &&\n          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&\n          (rectangle.y1 <= quadCorners[i][2].y))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Get a list of indexes of nodes containing a non-axis-aligned rectangle\n   *\n   * @param  {array}  corners      An array containing each corner of the\n   *                               rectangle defined by its coordinates (x, y).\n   * @param  {array}  quadCorners  An array of the quad nodes' corners.\n   * @return {array}               An array of indexes containing one to\n   *                               four integers.\n   */\n  function _quadCollision(corners, quadCorners) {\n    var indexes = [];\n\n    // Iterating through quads\n    for (var i = 0; i < 4; i++)\n      if (_geom.collision(corners, quadCorners[i]))\n        indexes.push(i);\n\n    return indexes;\n  }\n\n  /**\n   * Subdivide a quad by creating a node at a precise index. The function does\n   * not generate all four nodes not to potentially create unused nodes.\n   *\n   * @param  {integer}  index The index of the node to create.\n   * @param  {object}   quad  The quad object to subdivide.\n   * @return {object}         A new quad representing the node created.\n   */\n  function _quadSubdivide(index, quad) {\n    var next = quad.level + 1,\n        subw = Math.round(quad.bounds.width / 2),\n        subh = Math.round(quad.bounds.height / 2),\n        qx = Math.round(quad.bounds.x),\n        qy = Math.round(quad.bounds.y),\n        x,\n        y;\n\n    switch (index) {\n      case 0:\n        x = qx;\n        y = qy;\n        break;\n      case 1:\n        x = qx + subw;\n        y = qy;\n        break;\n      case 2:\n        x = qx;\n        y = qy + subh;\n        break;\n      case 3:\n        x = qx + subw;\n        y = qy + subh;\n        break;\n    }\n\n    return _quadTree(\n      {x: x, y: y, width: subw, height: subh},\n      next,\n      quad.maxElements,\n      quad.maxLevel\n    );\n  }\n\n  /**\n   * Recursively insert an element into the quadtree. Only points\n   * with size, i.e. axis-aligned squares, may be inserted with this\n   * method.\n   *\n   * @param  {object}  el         The element to insert in the quadtree.\n   * @param  {object}  sizedPoint A sized point defined by two top points\n   *                              (x1, y1), (x2, y2) and height.\n   * @param  {object}  quad       The quad in which to insert the element.\n   * @return {undefined}          The function does not return anything.\n   */\n  function _quadInsert(el, sizedPoint, quad) {\n    if (quad.level < quad.maxLevel) {\n\n      // Searching appropriate quads\n      var indexes = _quadIndexes(sizedPoint, quad.corners);\n\n      // Iterating\n      for (var i = 0, l = indexes.length; i < l; i++) {\n\n        // Subdividing if necessary\n        if (quad.nodes[indexes[i]] === undefined)\n          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);\n\n        // Recursion\n        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);\n      }\n    }\n    else {\n\n      // Pushing the element in a leaf node\n      quad.elements.push(el);\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements held by the node containing the\n   * searched point.\n   *\n   * @param  {object}  point The searched point (x, y).\n   * @param  {object}  quad  The searched quad.\n   * @return {array}         An array of elements contained in the relevant\n   *                         node.\n   */\n  function _quadRetrievePoint(point, quad) {\n    if (quad.level < quad.maxLevel) {\n      var index = _quadIndex(point, quad.bounds);\n\n      // If node does not exist we return an empty list\n      if (quad.nodes[index] !== undefined) {\n        return _quadRetrievePoint(point, quad.nodes[index]);\n      }\n      else {\n        return [];\n      }\n    }\n    else {\n      return quad.elements;\n    }\n  }\n\n  /**\n   * Recursively retrieve every elements contained within an rectangular area\n   * that may or may not be axis-aligned.\n   *\n   * @param  {object|array} rectData       The searched area defined either by\n   *                                       an array of four corners (x, y) in\n   *                                       the case of a non-axis-aligned\n   *                                       rectangle or an object with two top\n   *                                       points (x1, y1), (x2, y2) and height.\n   * @param  {object}       quad           The searched quad.\n   * @param  {function}     collisionFunc  The collision function used to search\n   *                                       for node indexes.\n   * @param  {array?}       els            The retrieved elements.\n   * @return {array}                       An array of elements contained in the\n   *                                       area.\n   */\n  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {\n    els = els || {};\n\n    if (quad.level < quad.maxLevel) {\n      var indexes = collisionFunc(rectData, quad.corners);\n\n      for (var i = 0, l = indexes.length; i < l; i++)\n        if (quad.nodes[indexes[i]] !== undefined)\n          _quadRetrieveArea(\n            rectData,\n            quad.nodes[indexes[i]],\n            collisionFunc,\n            els\n          );\n    } else\n      for (var j = 0, m = quad.elements.length; j < m; j++)\n        if (els[quad.elements[j].id] === undefined)\n          els[quad.elements[j].id] = quad.elements[j];\n\n    return els;\n  }\n\n  /**\n   * Creates the quadtree object itself.\n   *\n   * @param  {object}   bounds       The boundaries of the quad defined by an\n   *                                 origin (x, y), width and heigth.\n   * @param  {integer}  level        The level of the quad in the tree.\n   * @param  {integer}  maxElements  The max number of element in a leaf node.\n   * @param  {integer}  maxLevel     The max recursion level of the tree.\n   * @return {object}                The quadtree object.\n   */\n  function _quadTree(bounds, level, maxElements, maxLevel) {\n    return {\n      level: level || 0,\n      bounds: bounds,\n      corners: _geom.splitSquare(bounds),\n      maxElements: maxElements || 20,\n      maxLevel: maxLevel || 4,\n      elements: [],\n      nodes: []\n    };\n  }\n\n\n  /**\n   * Sigma Quad Constructor\n   * ----------------------\n   *\n   * The quad API as exposed to sigma.\n   */\n\n  /**\n   * The quad core that will become the sigma interface with the quadtree.\n   *\n   * property {object} _tree  Property holding the quadtree object.\n   * property {object} _geom  Exposition of the _geom namespace for testing.\n   * property {object} _cache Cache for the area method.\n   */\n  var quad = function() {\n    this._geom = _geom;\n    this._tree = null;\n    this._cache = {\n      query: false,\n      result: false\n    };\n  };\n\n  /**\n   * Index a graph by inserting its nodes into the quadtree.\n   *\n   * @param  {array}  nodes   An array of nodes to index.\n   * @param  {object} params  An object of parameters with at least the quad\n   *                          bounds.\n   * @return {object}         The quadtree object.\n   *\n   * Parameters:\n   * ----------\n   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)\n   *                         width and heigth.\n   * prefix:      {string?}  a prefix for node geometric attributes.\n   * maxElements: {integer?} the max number of elements in a leaf node.\n   * maxLevel:    {integer?} the max recursion level of the tree.\n   */\n  quad.prototype.index = function(nodes, params) {\n\n    // Enforcing presence of boundaries\n    if (!params.bounds)\n      throw 'sigma.classes.quad.index: bounds information not given.';\n\n    // Prefix\n    var prefix = params.prefix || '';\n\n    // Building the tree\n    this._tree = _quadTree(\n      params.bounds,\n      0,\n      params.maxElements,\n      params.maxLevel\n    );\n\n    // Inserting graph nodes into the tree\n    for (var i = 0, l = nodes.length; i < l; i++) {\n\n      // Inserting node\n      _quadInsert(\n        nodes[i],\n        _geom.pointToSquare({\n          x: nodes[i][prefix + 'x'],\n          y: nodes[i][prefix + 'y'],\n          size: nodes[i][prefix + 'size']\n        }),\n        this._tree\n      );\n    }\n\n    // Reset cache:\n    this._cache = {\n      query: false,\n      result: false\n    };\n\n    // remove?\n    return this._tree;\n  };\n\n  /**\n   * Retrieve every graph nodes held by the quadtree node containing the\n   * searched point.\n   *\n   * @param  {number} x of the point.\n   * @param  {number} y of the point.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.point = function(x, y) {\n    return this._tree ?\n      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :\n      [];\n  };\n\n  /**\n   * Retrieve every graph nodes within a rectangular area. The methods keep the\n   * last area queried in cache for optimization reason and will act differently\n   * for the same reason if the area is axis-aligned or not.\n   *\n   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)\n   *                  and height.\n   * @return {array}  An array of nodes retrieved.\n   */\n  quad.prototype.area = function(rect) {\n    var serialized = JSON.stringify(rect),\n        collisionFunc,\n        rectData;\n\n    // Returning cache?\n    if (this._cache.query === serialized)\n      return this._cache.result;\n\n    // Axis aligned ?\n    if (_geom.isAxisAligned(rect)) {\n      collisionFunc = _quadIndexes;\n      rectData = _geom.axisAlignedTopPoints(rect);\n    }\n    else {\n      collisionFunc = _quadCollision;\n      rectData = _geom.rectangleCorners(rect);\n    }\n\n    // Retrieving nodes\n    var nodes = this._tree ?\n      _quadRetrieveArea(\n        rectData,\n        this._tree,\n        collisionFunc\n      ) :\n      [];\n\n    // Object to array\n    var nodesArray = [];\n    for (var i in nodes)\n      nodesArray.push(nodes[i]);\n\n    // Caching\n    this._cache.query = serialized;\n    this._cache.result = nodesArray;\n\n    return nodesArray;\n  };\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined') {\n    this.sigma.classes = this.sigma.classes || {};\n    this.sigma.classes.quad = quad;\n  } else if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = quad;\n    exports.quad = quad;\n  } else\n    this.quad = quad;\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n/**\n * conrad.js is a tiny JavaScript jobs scheduler,\n *\n * Version: 0.1.0\n * Sources: http://github.com/jacomyal/conrad.js\n * Doc:     http://github.com/jacomyal/conrad.js#readme\n *\n * License:\n * --------\n * Copyright © 2013 Alexis Jacomy, Sciences-Po médialab\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * The Software is provided \"as is\", without warranty of any kind, express or\n * implied, including but not limited to the warranties of merchantability,\n * fitness for a particular purpose and noninfringement. In no event shall the\n * authors or copyright holders be liable for any claim, damages or other\n * liability, whether in an action of contract, tort or otherwise, arising\n * from, out of or in connection with the software or the use or other dealings\n * in the Software.\n */\n(function(global) {\n  'use strict';\n\n  // Check that conrad.js has not been loaded yet:\n  if (global.conrad)\n    throw new Error('conrad already exists');\n\n\n  /**\n   * PRIVATE VARIABLES:\n   * ******************\n   */\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Number}\n   */\n  var _lastFrameTime;\n\n  /**\n   * A flag indicating whether conrad is running or not.\n   *\n   * @type {Boolean}\n   */\n  var _isRunning = false;\n\n  /**\n   * The hash of registered jobs. Each job must at least have a unique ID\n   * under the key \"id\" and a function under the key \"job\". This hash\n   * contains each running job and each waiting job.\n   *\n   * @type {Object}\n   */\n  var _jobs = {};\n\n  /**\n   * The hash of currently running jobs.\n   *\n   * @type {Object}\n   */\n  var _runningJobs = {};\n\n  /**\n   * The array of currently running jobs, sorted by priority.\n   *\n   * @type {Array}\n   */\n  var _sortedByPriorityJobs = [];\n\n  /**\n   * The array of currently waiting jobs.\n   *\n   * @type {Object}\n   */\n  var _waitingJobs = {};\n\n  /**\n   * The array of finished jobs. They are stored in an array, since two jobs\n   * with the same \"id\" can happen at two different times.\n   *\n   * @type {Array}\n   */\n  var _doneJobs = [];\n\n  /**\n   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called\n   * with several jobs, conrad must be started only at the end. This flag keeps\n   * me from duplicating the code that effectively adds a job.\n   *\n   * @type {Boolean}\n   */\n  var _noStart = false;\n\n  /**\n   * An hash containing some global settings about how conrad.js should\n   * behave.\n   *\n   * @type {Object}\n   */\n  var _parameters = {\n    frameDuration: 20,\n    history: true\n  };\n\n  /**\n   * This object contains every handlers bound to conrad events. It does not\n   * requirea any DOM implementation, since the events are all JavaScript.\n   *\n   * @type {Object}\n   */\n  var _handlers = Object.create(null);\n\n\n  /**\n   * PRIVATE FUNCTIONS:\n   * ******************\n   */\n\n  /**\n   * Will execute the handler everytime that the indicated event (or the\n   * indicated events) will be triggered.\n   *\n   * @param  {string|array|object} events  The name of the event (or the events\n   *                                       separated by spaces).\n   * @param  {function(Object)}    handler The handler to bind.\n   * @return {Object}                      Returns conrad.\n   */\n  function _bind(events, handler) {\n    var i,\n        i_end,\n        event,\n        eArray;\n\n    if (!arguments.length)\n      return;\n    else if (\n      arguments.length === 1 &&\n      Object(arguments[0]) === arguments[0]\n    )\n      for (events in arguments[0])\n        _bind(events, arguments[0][events]);\n    else if (arguments.length > 1) {\n      eArray =\n        Array.isArray(events) ?\n          events :\n          events.split(/ /);\n\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n\n        if (!_handlers[event])\n          _handlers[event] = [];\n\n        // Using an object instead of directly the handler will make possible\n        // later to add flags\n        _handlers[event].push({\n          handler: handler\n        });\n      }\n    }\n  }\n\n  /**\n   * Removes the handler from a specified event (or specified events).\n   *\n   * @param  {?string}           events  The name of the event (or the events\n   *                                     separated by spaces). If undefined,\n   *                                     then all handlers are removed.\n   * @param  {?function(Object)} handler The handler to unbind. If undefined,\n   *                                     each handler bound to the event or the\n   *                                     events will be removed.\n   * @return {Object}            Returns conrad.\n   */\n  function _unbind(events, handler) {\n    var i,\n        i_end,\n        j,\n        j_end,\n        a,\n        event,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    if (!arguments.length)\n      _handlers = Object.create(null);\n    else if (handler) {\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n        event = eArray[i];\n        if (_handlers[event]) {\n          a = [];\n          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)\n            if (_handlers[event][j].handler !== handler)\n              a.push(_handlers[event][j]);\n\n          _handlers[event] = a;\n        }\n\n        if (_handlers[event] && _handlers[event].length === 0)\n          delete _handlers[event];\n      }\n    } else\n      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)\n        delete _handlers[eArray[i]];\n  }\n\n  /**\n   * Executes each handler bound to the event.\n   *\n   * @param  {string}  events The name of the event (or the events separated\n   *                          by spaces).\n   * @param  {?Object} data   The content of the event (optional).\n   * @return {Object}         Returns conrad.\n   */\n  function _dispatch(events, data) {\n    var i,\n        j,\n        i_end,\n        j_end,\n        event,\n        eventName,\n        eArray = Array.isArray(events) ?\n                   events :\n                   events.split(/ /);\n\n    data = data === undefined ? {} : data;\n\n    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {\n      eventName = eArray[i];\n\n      if (_handlers[eventName]) {\n        event = {\n          type: eventName,\n          data: data || {}\n        };\n\n        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)\n          try {\n            _handlers[eventName][j].handler(event);\n          } catch (e) {}\n      }\n    }\n  }\n\n  /**\n   * Executes the most prioritary job once, and deals with filling the stats\n   * (done, time, averageTime, currentTime, etc...).\n   *\n   * @return {?Object} Returns the job object if it has to be killed, null else.\n   */\n  function _executeFirstJob() {\n    var i,\n        l,\n        test,\n        kill,\n        pushed = false,\n        time = __dateNow(),\n        job = _sortedByPriorityJobs.shift();\n\n    // Execute the job and look at the result:\n    test = job.job();\n\n    // Deal with stats:\n    time = __dateNow() - time;\n    job.done++;\n    job.time += time;\n    job.currentTime += time;\n    job.weightTime = job.currentTime / (job.weight || 1);\n    job.averageTime = job.time / job.done;\n\n    // Check if the job has to be killed:\n    kill = job.count ? (job.count <= job.done) : !test;\n\n    // Reset priorities:\n    if (!kill) {\n      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)\n        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {\n          _sortedByPriorityJobs.splice(i, 0, job);\n          pushed = true;\n          break;\n        }\n\n      if (!pushed)\n        _sortedByPriorityJobs.push(job);\n    }\n\n    return kill ? job : null;\n  }\n\n  /**\n   * Activates a job, by adding it to the _runningJobs object and the\n   * _sortedByPriorityJobs array. It also initializes its currentTime value.\n   *\n   * @param  {Object} job The job to activate.\n   */\n  function _activateJob(job) {\n    var l = _sortedByPriorityJobs.length;\n\n    // Add the job to the running jobs:\n    _runningJobs[job.id] = job;\n    job.status = 'running';\n\n    // Add the job to the priorities:\n    if (l) {\n      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;\n      job.currentTime = job.weightTime * (job.weight || 1);\n    }\n\n    // Initialize the job and dispatch:\n    job.startTime = __dateNow();\n    _dispatch('jobStarted', __clone(job));\n\n    _sortedByPriorityJobs.push(job);\n  }\n\n  /**\n   * The main loop of conrad.js:\n   *  . It executes job such that they all occupate the same processing time.\n   *  . It stops jobs that do not need to be executed anymore.\n   *  . It triggers callbacks when it is relevant.\n   *  . It starts waiting jobs when they need to be started.\n   *  . It injects frames to keep a constant frapes per second ratio.\n   *  . It stops itself when there are no more jobs to execute.\n   */\n  function _loop() {\n    var k,\n        o,\n        l,\n        job,\n        time,\n        deadJob;\n\n    // Deal with the newly added jobs (the _jobs object):\n    for (k in _jobs) {\n      job = _jobs[k];\n\n      if (job.after)\n        _waitingJobs[k] = job;\n      else\n        _activateJob(job);\n\n      delete _jobs[k];\n    }\n\n    // Set the _isRunning flag to false if there are no running job:\n    _isRunning = !!_sortedByPriorityJobs.length;\n\n    // Deal with the running jobs (the _runningJobs object):\n    while (\n      _sortedByPriorityJobs.length &&\n      __dateNow() - _lastFrameTime < _parameters.frameDuration\n    ) {\n      deadJob = _executeFirstJob();\n\n      // Deal with the case where the job has ended:\n      if (deadJob) {\n        _killJob(deadJob.id);\n\n        // Check for waiting jobs:\n        for (k in _waitingJobs)\n          if (_waitingJobs[k].after === deadJob.id) {\n            _activateJob(_waitingJobs[k]);\n            delete _waitingJobs[k];\n          }\n      }\n    }\n\n    // Check if conrad still has jobs to deal with, and kill it if not:\n    if (_isRunning) {\n      // Update the _lastFrameTime:\n      _lastFrameTime = __dateNow();\n\n      _dispatch('enterFrame');\n      setTimeout(_loop, 0);\n    } else\n      _dispatch('stop');\n  }\n\n  /**\n   * Adds one or more jobs, and starts the loop if no job was running before. A\n   * job is at least a unique string \"id\" and a function, and there are some\n   * parameters that you can specify for each job to modify the way conrad will\n   * execute it. If a job is added with the \"id\" of another job that is waiting\n   * or still running, an error will be thrown.\n   *\n   * When a job is added, it is referenced in the _jobs object, by its id.\n   * Then, if it has to be executed right now, it will be also referenced in\n   * the _runningJobs object. If it has to wait, then it will be added into the\n   * _waitingJobs object, until it can start.\n   *\n   * Keep reading this documentation to see how to call this method.\n   *\n   * @return {Object} Returns conrad.\n   *\n   * Adding one job:\n   * ***************\n   * Basically, a job is defined by its string id and a function (the job). It\n   * is also possible to add some parameters:\n   *\n   *  > conrad.addJob('myJobId', myJobFunction);\n   *  > conrad.addJob('myJobId', {\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   id: 'myJobId',\n   *  >   job: myJobFunction,\n   *  >   someParameter: someValue\n   *  > });\n   *\n   * Adding several jobs:\n   * ********************\n   * When adding several jobs at the same time, it is possible to specify\n   * parameters for each one individually or for all:\n   *\n   *  > conrad.addJob([\n   *  >   {\n   *  >     id: 'myJobId1',\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   {\n   *  >     id: 'myJobId2',\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > ], {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: {,\n   *  >     job: myJobFunction1,\n   *  >     someParameter1: someValue1\n   *  >   },\n   *  >   myJobId2: {,\n   *  >     job: myJobFunction2,\n   *  >     someParameter2: someValue2\n   *  >   }\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *  > conrad.addJob({\n   *  >   myJobId1: myJobFunction1,\n   *  >   myJobId2: myJobFunction2\n   *  > }, {\n   *  >   someCommonParameter: someCommonValue\n   *  > });\n   *\n   *  Recognized parameters:\n   *  **********************\n   *  Here is the exhaustive list of every accepted parameters:\n   *\n   *    {?Function} end      A callback to execute when the job is ended. It is\n   *                         not executed if the job is killed instead of ended\n   *                         \"naturally\".\n   *    {?Integer}  count    The number of time the job has to be executed.\n   *    {?Number}   weight   If specified, the job will be executed as it was\n   *                         added \"weight\" times.\n   *    {?String}   after    The id of another job (eventually not added yet).\n   *                         If specified, this job will start only when the\n   *                         specified \"after\" job is ended.\n   */\n  function _addJob(v1, v2) {\n    var i,\n        l,\n        o;\n\n    // Array of jobs:\n    if (Array.isArray(v1)) {\n      // Keep conrad to start until the last job is added:\n      _noStart = true;\n\n      for (i = 0, l = v1.length; i < l; i++)\n        _addJob(v1[i].id, __extend(v1[i], v2));\n\n      _noStart = false;\n      if (!_isRunning) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n    } else if (typeof v1 === 'object') {\n      // One job (object):\n      if (typeof v1.id === 'string')\n        _addJob(v1.id, v1);\n\n      // Hash of jobs:\n      else {\n        // Keep conrad to start until the last job is added:\n        _noStart = true;\n\n        for (i in v1)\n          if (typeof v1[i] === 'function')\n            _addJob(i, __extend({\n              job: v1[i]\n            }, v2));\n          else\n            _addJob(i, __extend(v1[i], v2));\n\n        _noStart = false;\n        if (!_isRunning) {\n          // Update the _lastFrameTime:\n          _lastFrameTime = __dateNow();\n\n          _dispatch('start');\n          _loop();\n        }\n      }\n\n    // One job (string, *):\n    } else if (typeof v1 === 'string') {\n      if (_hasJob(v1))\n        throw new Error(\n          '[conrad.addJob] Job with id \"' + v1 + '\" already exists.'\n        );\n\n      // One job (string, function):\n      if (typeof v2 === 'function') {\n        o = {\n          id: v1,\n          done: 0,\n          time: 0,\n          status: 'waiting',\n          currentTime: 0,\n          averageTime: 0,\n          weightTime: 0,\n          job: v2\n        };\n\n      // One job (string, object):\n      } else if (typeof v2 === 'object') {\n        o = __extend(\n          {\n            id: v1,\n            done: 0,\n            time: 0,\n            status: 'waiting',\n            currentTime: 0,\n            averageTime: 0,\n            weightTime: 0\n          },\n          v2\n        );\n\n      // If none of those cases, throw an error:\n      } else\n        throw new Error('[conrad.addJob] Wrong arguments.');\n\n      // Effectively add the job:\n      _jobs[v1] = o;\n      _dispatch('jobAdded', __clone(o));\n\n      // Check if the loop has to be started:\n      if (!_isRunning && !_noStart) {\n        // Update the _lastFrameTime:\n        _lastFrameTime = __dateNow();\n\n        _dispatch('start');\n        _loop();\n      }\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.addJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills one or more jobs, indicated by their ids. It is only possible to\n   * kill running jobs or waiting jobs. If you try to kill a job that does not\n   * exist or that is already killed, a warning will be thrown.\n   *\n   * @param  {Array|String} v1 A string job id or an array of job ids.\n   * @return {Object}       Returns conrad.\n   */\n  function _killJob(v1) {\n    var i,\n        l,\n        k,\n        a,\n        job,\n        found = false;\n\n    // Array of job ids:\n    if (Array.isArray(v1))\n      for (i = 0, l = v1.length; i < l; i++)\n        _killJob(v1[i]);\n\n    // One job's id:\n    else if (typeof v1 === 'string') {\n      a = [_runningJobs, _waitingJobs, _jobs];\n\n      // Remove the job from the hashes:\n      for (i = 0, l = a.length; i < l; i++)\n        if (v1 in a[i]) {\n          job = a[i][v1];\n\n          if (_parameters.history) {\n            job.status = 'done';\n            _doneJobs.push(job);\n          }\n\n          _dispatch('jobEnded', __clone(job));\n          delete a[i][v1];\n\n          if (typeof job.end === 'function')\n            job.end();\n\n          found = true;\n        }\n\n      // Remove the priorities array:\n      a = _sortedByPriorityJobs;\n      for (i = 0, l = a.length; i < l; i++)\n        if (a[i].id === v1) {\n          a.splice(i, 1);\n          break;\n        }\n\n      if (!found)\n        throw new Error('[conrad.killJob] Job \"' + v1 + '\" not found.');\n\n    // If none of those cases, throw an error:\n    } else\n      throw new Error('[conrad.killJob] Wrong arguments.');\n\n    return this;\n  }\n\n  /**\n   * Kills every running, waiting, and just added jobs.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _killAll() {\n    var k,\n        jobs = __extend(_jobs, _runningJobs, _waitingJobs);\n\n    // Take every jobs and push them into the _doneJobs object:\n    if (_parameters.history)\n      for (k in jobs) {\n        jobs[k].status = 'done';\n        _doneJobs.push(jobs[k]);\n\n        if (typeof jobs[k].end === 'function')\n          jobs[k].end();\n      }\n\n    // Reinitialize the different jobs lists:\n    _jobs = {};\n    _waitingJobs = {};\n    _runningJobs = {};\n    _sortedByPriorityJobs = [];\n\n    // In case some jobs are added right after the kill:\n    _isRunning = false;\n\n    return this;\n  }\n\n  /**\n   * Returns true if a job with the specified id is currently running or\n   * waiting, and false else.\n   *\n   * @param  {String}  id The id of the job.\n   * @return {?Object} Returns the job object if it exists.\n   */\n  function _hasJob(id) {\n    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];\n    return job ? __extend(job) : null;\n  }\n\n  /**\n   * This method will set the setting specified by \"v1\" to the value specified\n   * by \"v2\" if both are given, and else return the current value of the\n   * settings \"v1\".\n   *\n   * @param  {String}   v1 The name of the property.\n   * @param  {?*}       v2 Eventually, a value to set to the specified\n   *                       property.\n   * @return {Object|*} Returns the specified settings value if \"v2\" is not\n   *                    given, and conrad else.\n   */\n  function _settings(v1, v2) {\n    var o;\n\n    if (typeof a1 === 'string' && arguments.length === 1)\n      return _parameters[a1];\n    else {\n      o = (typeof a1 === 'object' && arguments.length === 1) ?\n        a1 || {} :\n        {};\n      if (typeof a1 === 'string')\n        o[a1] = a2;\n\n      for (var k in o)\n        if (o[k] !== undefined)\n          _parameters[k] = o[k];\n        else\n          delete _parameters[k];\n\n      return this;\n    }\n  }\n\n  /**\n   * Returns true if conrad is currently running, and false else.\n   *\n   * @return {Boolean} Returns _isRunning.\n   */\n  function _getIsRunning() {\n    return _isRunning;\n  }\n\n  /**\n   * Unreference every job that is stored in the _doneJobs object. It will\n   * not be possible anymore to get stats about these jobs, but it will release\n   * the memory.\n   *\n   * @return {Object} Returns conrad.\n   */\n  function _clearHistory() {\n    _doneJobs = [];\n    return this;\n  }\n\n  /**\n   * Returns a snapshot of every data about jobs that wait to be started, are\n   * currently running or are done.\n   *\n   * It is possible to get only running, waiting or done jobs by giving\n   * \"running\", \"waiting\" or \"done\" as fist argument.\n   *\n   * It is also possible to get every job with a specified id by giving it as\n   * first argument. Also, using a RegExp instead of an id will return every\n   * jobs whose ids match the RegExp. And these two last use cases work as well\n   * by giving before \"running\", \"waiting\" or \"done\".\n   *\n   * @return {Array} The array of the matching jobs.\n   *\n   * Some call examples:\n   * *******************\n   *  > conrad.getStats('running')\n   *  > conrad.getStats('waiting')\n   *  > conrad.getStats('done')\n   *  > conrad.getStats('myJob')\n   *  > conrad.getStats(/test/)\n   *  > conrad.getStats('running', 'myRunningJob')\n   *  > conrad.getStats('running', /test/)\n   */\n  function _getStats(v1, v2) {\n    var a,\n        k,\n        i,\n        l,\n        stats,\n        pattern,\n        isPatternString;\n\n    if (!arguments.length) {\n      stats = [];\n\n      for (k in _jobs)\n        stats.push(_jobs[k]);\n\n      for (k in _waitingJobs)\n        stats.push(_waitingJobs[k]);\n\n      for (k in _runningJobs)\n        stats.push(_runningJobs[k]);\n\n      stats = stats.concat(_doneJobs);\n    }\n\n    if (typeof v1 === 'string')\n      switch (v1) {\n        case 'waiting':\n          stats = __objectValues(_waitingJobs);\n          break;\n        case 'running':\n          stats = __objectValues(_runningJobs);\n          break;\n        case 'done':\n          stats = _doneJobs;\n          break;\n        default:\n          pattern = v1;\n      }\n\n    if (v1 instanceof RegExp)\n      pattern = v1;\n\n    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))\n      pattern = v2;\n\n    // Filter jobs if a pattern is given:\n    if (pattern) {\n      isPatternString = typeof pattern === 'string';\n\n      if (stats instanceof Array) {\n        a = stats;\n      } else if (typeof stats === 'object') {\n        a = [];\n\n        for (k in stats)\n          a = a.concat(stats[k]);\n      } else {\n        a = [];\n\n        for (k in _jobs)\n          a.push(_jobs[k]);\n\n        for (k in _waitingJobs)\n          a.push(_waitingJobs[k]);\n\n        for (k in _runningJobs)\n          a.push(_runningJobs[k]);\n\n        a = a.concat(_doneJobs);\n      }\n\n      stats = [];\n      for (i = 0, l = a.length; i < l; i++)\n        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))\n          stats.push(a[i]);\n    }\n\n    return __clone(stats);\n  }\n\n\n  /**\n   * TOOLS FUNCTIONS:\n   * ****************\n   */\n\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when two objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > __extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {Object+} Any number of objects.\n   * @return {Object}  The merged object.\n   */\n  function __extend() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  }\n\n  /**\n   * This function simply clones an object. This object must contain only\n   * objects, arrays and immutable values. Since it is not public, it does not\n   * deal with cyclic references, DOM elements and instantiated objects - so\n   * use it carefully.\n   *\n   * @param  {Object} The object to clone.\n   * @return {Object} The clone.\n   */\n  function __clone(item) {\n    var result, i, k, l;\n\n    if (!item)\n      return item;\n\n    if (Array.isArray(item)) {\n      result = [];\n      for (i = 0, l = item.length; i < l; i++)\n        result.push(__clone(item[i]));\n    } else if (typeof item === 'object') {\n      result = {};\n      for (i in item)\n        result[i] = __clone(item[i]);\n    } else\n      result = item;\n\n    return result;\n  }\n\n  /**\n   * Returns an array containing the values of an object.\n   *\n   * @param  {Object} The object.\n   * @return {Array}  The array of values.\n   */\n  function __objectValues(o) {\n    var k,\n        a = [];\n\n    for (k in o)\n      a.push(o[k]);\n\n    return a;\n  }\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  function __dateNow() {\n    return Date.now ? Date.now() : new Date().getTime();\n  }\n\n  /**\n   * Polyfill for the Array.isArray function:\n   */\n  if (!Array.isArray)\n    Array.isArray = function(v) {\n      return Object.prototype.toString.call(v) === '[object Array]';\n    };\n\n\n  /**\n   * EXPORT PUBLIC API:\n   * ******************\n   */\n  var conrad = {\n    hasJob: _hasJob,\n    addJob: _addJob,\n    killJob: _killJob,\n    killAll: _killAll,\n    settings: _settings,\n    getStats: _getStats,\n    isRunning: _getIsRunning,\n    clearHistory: _clearHistory,\n\n    // Events management:\n    bind: _bind,\n    unbind: _unbind,\n\n    // Version:\n    version: '0.1.0'\n  };\n\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = conrad;\n    exports.conrad = conrad;\n  }\n  global.conrad = conrad;\n})(this);\n\n}.call(window));\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n\n  /**\n   * This middleware will just copy the graphic properties.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   */\n  sigma.middlewares.copy = function(readPrefix, writePrefix) {\n    var i,\n        l,\n        a;\n\n    if (writePrefix + '' === readPrefix + '')\n      return;\n\n    a = this.graph.nodes();\n    for (i = 0, l = a.length; i < l; i++) {\n      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];\n      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n    }\n\n    a = this.graph.edges();\n    for (i = 0, l = a.length; i < l; i++)\n      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.middlewares');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * This middleware will rescale the graph such that it takes an optimal space\n   * on the renderer.\n   *\n   * As each middleware, this function is executed in the scope of the sigma\n   * instance.\n   *\n   * @param {?string} readPrefix  The read prefix.\n   * @param {?string} writePrefix The write prefix.\n   * @param {object}  options     The parameters.\n   */\n  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {\n    var i,\n        l,\n        a,\n        b,\n        c,\n        d,\n        scale,\n        margin,\n        n = this.graph.nodes(),\n        e = this.graph.edges(),\n        settings = this.settings.embedObjects(options || {}),\n        bounds = settings('bounds') || sigma.utils.getBoundaries(\n          this.graph,\n          readPrefix,\n          true\n        ),\n        minX = bounds.minX,\n        minY = bounds.minY,\n        maxX = bounds.maxX,\n        maxY = bounds.maxY,\n        sizeMax = bounds.sizeMax,\n        weightMax = bounds.weightMax,\n        w = settings('width') || 1,\n        h = settings('height') || 1,\n        rescaleSettings = settings('autoRescale'),\n        validSettings = {\n          nodePosition: 1,\n          nodeSize: 1,\n          edgeSize: 1\n        };\n\n    /**\n     * What elements should we rescale?\n     */\n    if (!(rescaleSettings instanceof Array))\n      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];\n\n    for (i = 0, l = rescaleSettings.length; i < l; i++)\n      if (!validSettings[rescaleSettings[i]])\n        throw new Error(\n          'The rescale setting \"' + rescaleSettings[i] + '\" is not recognized.'\n        );\n\n    var np = ~rescaleSettings.indexOf('nodePosition'),\n        ns = ~rescaleSettings.indexOf('nodeSize'),\n        es = ~rescaleSettings.indexOf('edgeSize');\n\n    /**\n     * First, we compute the scaling ratio, without considering the sizes\n     * of the nodes : Each node will have its center in the canvas, but might\n     * be partially out of it.\n     */\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    /**\n     * Then, we correct that scaling ratio considering a margin, which is\n     * basically the size of the biggest node.\n     * This has to be done as a correction since to compare the size of the\n     * biggest node to the X and Y values, we have to first get an\n     * approximation of the scaling ratio.\n     **/\n    margin =\n      (\n        settings('rescaleIgnoreSize') ?\n          0 :\n          (settings('maxNodeSize') || sizeMax) / scale\n      ) +\n      (settings('sideMargin') || 0);\n    maxX += margin;\n    minX -= margin;\n    maxY += margin;\n    minY -= margin;\n\n    // Fix the scaling with the new extrema:\n    scale = settings('scalingMode') === 'outside' ?\n      Math.max(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      ) :\n      Math.min(\n        w / Math.max(maxX - minX, 1),\n        h / Math.max(maxY - minY, 1)\n      );\n\n    // Size homothetic parameters:\n    if (!settings('maxNodeSize') && !settings('minNodeSize')) {\n      a = 1;\n      b = 0;\n    } else if (settings('maxNodeSize') === settings('minNodeSize')) {\n      a = 0;\n      b = +settings('maxNodeSize');\n    } else {\n      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;\n      b = +settings('minNodeSize');\n    }\n\n    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {\n      c = 1;\n      d = 0;\n    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {\n      c = 0;\n      d = +settings('minEdgeSize');\n    } else {\n      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;\n      d = +settings('minEdgeSize');\n    }\n\n    // Rescale the nodes and edges:\n    for (i = 0, l = e.length; i < l; i++)\n      e[i][writePrefix + 'size'] =\n        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      n[i][writePrefix + 'size'] =\n        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);\n      n[i][writePrefix + 'x'] =\n        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);\n      n[i][writePrefix + 'y'] =\n        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);\n    }\n  };\n\n  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {\n    var i,\n        l,\n        e = graph.edges(),\n        n = graph.nodes(),\n        weightMax = -Infinity,\n        sizeMax = -Infinity,\n        minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    if (doEdges)\n      for (i = 0, l = e.length; i < l; i++)\n        weightMax = Math.max(e[i][prefix + 'size'], weightMax);\n\n    for (i = 0, l = n.length; i < l; i++) {\n      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);\n      maxX = Math.max(n[i][prefix + 'x'], maxX);\n      minX = Math.min(n[i][prefix + 'x'], minX);\n      maxY = Math.max(n[i][prefix + 'y'], maxY);\n      minY = Math.min(n[i][prefix + 'y'], minY);\n    }\n\n    weightMax = weightMax || 1;\n    sizeMax = sizeMax || 1;\n\n    return {\n      weightMax: weightMax,\n      sizeMax: sizeMax,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY\n    };\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc.animation.running');\n\n  /**\n   * Generates a unique ID for the animation.\n   *\n   * @return {string} Returns the new ID.\n   */\n  var _getID = (function() {\n    var id = 0;\n    return function() {\n      return '' + (++id);\n    };\n  })();\n\n  /**\n   * This function animates a camera. It has to be called with the camera to\n   * animate, the values of the coordinates to reach and eventually some\n   * options. It returns a number id, that you can use to kill the animation,\n   * with the method sigma.misc.animation.kill(id).\n   *\n   * The available options are:\n   *\n   *   {?number}            duration   The duration of the animation.\n   *   {?function}          onNewFrame A callback to execute when the animation\n   *                                   enter a new frame.\n   *   {?function}          onComplete A callback to execute when the animation\n   *                                   is completed or killed.\n   *   {?(string|function)} easing     The name of a function from the package\n   *                                   sigma.utils.easings, or a custom easing\n   *                                   function.\n   *\n   * @param  {camera}  camera  The camera to animate.\n   * @param  {object}  target  The coordinates to reach.\n   * @param  {?object} options Eventually an object to specify some options to\n   *                           the function. The available options are\n   *                           presented in the description of the function.\n   * @return {number}          The animation id, to make it easy to kill\n   *                           through the method \"sigma.misc.animation.kill\".\n   */\n  sigma.misc.animation.camera = function(camera, val, options) {\n    if (\n      !(camera instanceof sigma.classes.camera) ||\n      typeof val !== 'object' ||\n      !val\n    )\n      throw 'animation.camera: Wrong arguments.';\n\n    if (\n      typeof val.x !== 'number' &&\n      typeof val.y !== 'number' &&\n      typeof val.ratio !== 'number' &&\n      typeof val.angle !== 'number'\n    )\n      throw 'There must be at least one valid coordinate in the given val.';\n\n    var fn,\n        id,\n        anim,\n        easing,\n        duration,\n        initialVal,\n        o = options || {},\n        start = sigma.utils.dateNow();\n\n    // Store initial values:\n    initialVal = {\n      x: camera.x,\n      y: camera.y,\n      ratio: camera.ratio,\n      angle: camera.angle\n    };\n\n    duration = o.duration;\n    easing = typeof o.easing !== 'function' ?\n      sigma.utils.easings[o.easing || 'quadraticInOut'] :\n      o.easing;\n\n    fn = function() {\n      var coef,\n          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;\n\n      // If the animation is over:\n      if (t >= 1) {\n        camera.isAnimated = false;\n        camera.goTo({\n          x: val.x !== undefined ? val.x : initialVal.x,\n          y: val.y !== undefined ? val.y : initialVal.y,\n          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,\n          angle: val.angle !== undefined ? val.angle : initialVal.angle\n        });\n\n        cancelAnimationFrame(id);\n        delete sigma.misc.animation.running[id];\n\n        // Check callbacks:\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n\n      // Else, let's keep going:\n      } else {\n        coef = easing(t);\n        camera.isAnimated = true;\n        camera.goTo({\n          x: val.x !== undefined ?\n            initialVal.x + (val.x - initialVal.x) * coef :\n            initialVal.x,\n          y: val.y !== undefined ?\n            initialVal.y + (val.y - initialVal.y) * coef :\n            initialVal.y,\n          ratio: val.ratio !== undefined ?\n            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :\n            initialVal.ratio,\n          angle: val.angle !== undefined ?\n            initialVal.angle + (val.angle - initialVal.angle) * coef :\n            initialVal.angle\n        });\n\n        // Check callbacks:\n        if (typeof o.onNewFrame === 'function')\n          o.onNewFrame();\n\n        anim.frameId = requestAnimationFrame(fn);\n      }\n    };\n\n    id = _getID();\n    anim = {\n      frameId: requestAnimationFrame(fn),\n      target: camera,\n      type: 'camera',\n      options: o,\n      fn: fn\n    };\n    sigma.misc.animation.running[id] = anim;\n\n    return id;\n  };\n\n  /**\n   * Kills a running animation. It triggers the eventual onComplete callback.\n   *\n   * @param  {number} id  The id of the animation to kill.\n   * @return {object}     Returns the sigma.misc.animation package.\n   */\n  sigma.misc.animation.kill = function(id) {\n    if (arguments.length !== 1 || typeof id !== 'number')\n      throw 'animation.kill: Wrong arguments.';\n\n    var o = sigma.misc.animation.running[id];\n\n    if (o) {\n      cancelAnimationFrame(id);\n      delete sigma.misc.animation.running[o.frameId];\n\n      if (o.type === 'camera')\n        o.target.isAnimated = false;\n\n      // Check callbacks:\n      if (typeof (o.options || {}).onComplete === 'function')\n        o.options.onComplete();\n    }\n\n    return this;\n  };\n\n  /**\n   * Kills every running animations, or only the one with the specified type,\n   * if a string parameter is given.\n   *\n   * @param  {?(string|object)} filter A string to filter the animations to kill\n   *                                   on their type (example: \"camera\"), or an\n   *                                   object to filter on their target.\n   * @return {number}                  Returns the number of animations killed\n   *                                   that way.\n   */\n  sigma.misc.animation.killAll = function(filter) {\n    var o,\n        id,\n        count = 0,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      ) {\n        o = sigma.misc.animation.running[id];\n        cancelAnimationFrame(o.frameId);\n        delete sigma.misc.animation.running[id];\n\n        if (o.type === 'camera')\n          o.target.isAnimated = false;\n\n        // Increment counter:\n        count++;\n\n        // Check callbacks:\n        if (typeof (o.options || {}).onComplete === 'function')\n          o.options.onComplete();\n      }\n\n    return count;\n  };\n\n  /**\n   * Returns \"true\" if any animation that is currently still running matches\n   * the filter given to the function.\n   *\n   * @param  {string|object} filter A string to filter the animations to kill\n   *                                on their type (example: \"camera\"), or an\n   *                                object to filter on their target.\n   * @return {boolean}              Returns true if any running animation\n   *                                matches.\n   */\n  sigma.misc.animation.has = function(filter) {\n    var id,\n        type = typeof filter === 'string' ? filter : null,\n        target = typeof filter === 'object' ? filter : null,\n        running = sigma.misc.animation.running;\n\n    for (id in running)\n      if (\n        (!type || running[id].type === type) &&\n        (!target || running[id].target === target)\n      )\n        return true;\n\n    return false;\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any DOM renderer (for instance svg)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindDOMEvents = function(container) {\n    var self = this,\n        graph = this.graph;\n\n    // DOMElement abstraction\n    function Element(domElement) {\n\n      // Helpers\n      this.attr = function(attrName) {\n        return domElement.getAttributeNS(null, attrName);\n      };\n\n      // Properties\n      this.tag = domElement.tagName;\n      this.class = this.attr('class');\n      this.id = this.attr('id');\n\n      // Methods\n      this.isNode = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');\n      };\n\n      this.isEdge = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');\n      };\n\n      this.isHover = function() {\n        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');\n      };\n    }\n\n    // Click\n    function click(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('click', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('clickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('clickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // Double click\n    function doubleClick(e) {\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      // Generic event\n      self.dispatchEvent('doubleClick', e);\n\n      // Are we on a node?\n      var element = new Element(e.target);\n\n      if (element.isNode())\n        self.dispatchEvent('doubleClickNode', {\n          node: graph.nodes(element.attr('data-node-id'))\n        });\n      else\n        self.dispatchEvent('doubleClickStage');\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    // On over\n    function onOver(e) {\n      var target = e.toElement || e.target;\n\n      if (!self.settings('eventsEnabled') || !target)\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('overNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('overEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // On out\n    function onOut(e) {\n      var target = e.fromElement || e.originalTarget;\n\n      if (!self.settings('eventsEnabled'))\n        return;\n\n      var el = new Element(target);\n\n      if (el.isNode()) {\n        self.dispatchEvent('outNode', {\n          node: graph.nodes(el.attr('data-node-id'))\n        });\n      }\n      else if (el.isEdge()) {\n        var edge = graph.edges(el.attr('data-edge-id'));\n        self.dispatchEvent('outEdge', {\n          edge: edge,\n          source: graph.nodes(edge.source),\n          target: graph.nodes(edge.target)\n        });\n      }\n    }\n\n    // Registering Events:\n\n    // Click\n    container.addEventListener('click', click, false);\n    sigma.utils.doubleClick(container, 'click', doubleClick);\n\n    // Touch counterparts\n    container.addEventListener('touchstart', click, false);\n    sigma.utils.doubleClick(container, 'touchstart', doubleClick);\n\n    // Mouseover\n    container.addEventListener('mouseover', onOver, true);\n\n    // Mouseout\n    container.addEventListener('mouseout', onOut, true);\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)\n   * to its captors, to properly dispatch the good events to the sigma instance\n   * to manage clicking, hovering etc...\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.bindEvents = function(prefix) {\n    var i,\n        l,\n        mX,\n        mY,\n        captor,\n        self = this;\n\n    function getNodes(e) {\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          n,\n          x,\n          y,\n          s,\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          nodes = self.camera.quadtree.point(\n            point.x,\n            point.y\n          );\n\n      if (nodes.length)\n        for (i = 0, l = nodes.length; i < l; i++) {\n          n = nodes[i];\n          x = n[prefix + 'x'];\n          y = n[prefix + 'y'];\n          s = n[prefix + 'size'];\n\n          if (\n            !n.hidden &&\n            modifiedX > x - s &&\n            modifiedX < x + s &&\n            modifiedY > y - s &&\n            modifiedY < y + s &&\n            Math.sqrt(\n              Math.pow(modifiedX - x, 2) +\n              Math.pow(modifiedY - y, 2)\n            ) < s\n          ) {\n            // Insert the node:\n            inserted = false;\n\n            for (j = 0; j < selected.length; j++)\n              if (n.size > selected[j].size) {\n                selected.splice(j, 0, n);\n                inserted = true;\n                break;\n              }\n\n            if (!inserted)\n              selected.push(n);\n          }\n        }\n\n      return selected;\n    }\n\n\n    function getEdges(e) {\n      if (!self.settings('enableEdgeHovering')) {\n        // No event if the setting is off:\n        return [];\n      }\n\n      var isCanvas = (\n        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);\n\n      if (!isCanvas) {\n        // A quick hardcoded rule to prevent people from using this feature\n        // with the WebGL renderer (which is not good enough at the moment):\n        throw new Error(\n          'The edge events feature is not compatible with the WebGL renderer'\n        );\n      }\n\n      if (e) {\n        mX = 'x' in e.data ? e.data.x : mX;\n        mY = 'y' in e.data ? e.data.y : mY;\n      }\n\n      var i,\n          j,\n          l,\n          a,\n          edge,\n          s,\n          maxEpsilon = self.settings('edgeHoverPrecision'),\n          source,\n          target,\n          cp,\n          nodeIndex = {},\n          inserted,\n          selected = [],\n          modifiedX = mX + self.width / 2,\n          modifiedY = mY + self.height / 2,\n          point = self.camera.cameraPosition(\n            mX,\n            mY\n          ),\n          edges = [];\n\n      if (isCanvas) {\n        var nodesOnScreen = self.camera.quadtree.area(\n          self.camera.getRectangle(self.width, self.height)\n        );\n        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)\n          nodeIndex[a[i].id] = a[i];\n      }\n\n      if (self.camera.edgequadtree !== undefined) {\n        edges = self.camera.edgequadtree.point(\n          point.x,\n          point.y\n        );\n      }\n\n      function insertEdge(selected, edge) {\n        inserted = false;\n\n        for (j = 0; j < selected.length; j++)\n          if (edge.size > selected[j].size) {\n            selected.splice(j, 0, edge);\n            inserted = true;\n            break;\n          }\n\n        if (!inserted)\n          selected.push(edge);\n      }\n\n      if (edges.length)\n        for (i = 0, l = edges.length; i < l; i++) {\n          edge = edges[i];\n          source = self.graph.nodes(edge.source);\n          target = self.graph.nodes(edge.target);\n          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:\n          s = edge[prefix + 'size'] ||\n              edge['read_' + prefix + 'size'];\n\n          // First, let's identify which edges are drawn. To do this, we keep\n          // every edges that have at least one extremity displayed according to\n          // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n          // edges.\n          // Then, let's check if the mouse is on the edge (we suppose that it\n          // is a line segment).\n\n          if (\n            !edge.hidden &&\n            !source.hidden && !target.hidden &&\n            (!isCanvas ||\n              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&\n            sigma.utils.getDistance(\n              source[prefix + 'x'],\n              source[prefix + 'y'],\n              modifiedX,\n              modifiedY) > source[prefix + 'size'] &&\n            sigma.utils.getDistance(\n              target[prefix + 'x'],\n              target[prefix + 'y'],\n              modifiedX,\n              modifiedY) > target[prefix + 'size']\n          ) {\n            if (edge.type == 'curve' || edge.type == 'curvedArrow') {\n              if (source.id === target.id) {\n                cp = sigma.utils.getSelfLoopControlPoints(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  source[prefix + 'size']\n                );\n                if (\n                  sigma.utils.isPointOnBezierCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x1,\n                  cp.y1,\n                  cp.x2,\n                  cp.y2,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n              else {\n                cp = sigma.utils.getQuadraticControlPoint(\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y']);\n                if (\n                  sigma.utils.isPointOnQuadraticCurve(\n                  modifiedX,\n                  modifiedY,\n                  source[prefix + 'x'],\n                  source[prefix + 'y'],\n                  target[prefix + 'x'],\n                  target[prefix + 'y'],\n                  cp.x,\n                  cp.y,\n                  Math.max(s, maxEpsilon)\n                )) {\n                  insertEdge(selected, edge);\n                }\n              }\n            } else if (\n                sigma.utils.isPointOnSegment(\n                modifiedX,\n                modifiedY,\n                source[prefix + 'x'],\n                source[prefix + 'y'],\n                target[prefix + 'x'],\n                target[prefix + 'y'],\n                Math.max(s, maxEpsilon)\n              )) {\n              insertEdge(selected, edge);\n            }\n          }\n        }\n\n      return selected;\n    }\n\n\n    function bindCaptor(captor) {\n      var nodes,\n          edges,\n          overNodes = {},\n          overEdges = {};\n\n      function onClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('click', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('clickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('clickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('clickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('clickStage', {captor: e.data});\n      }\n\n      function onDoubleClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('doubleClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('doubleClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('doubleClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('doubleClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('doubleClickStage', {captor: e.data});\n      }\n\n      function onRightClick(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        self.dispatchEvent('rightClick', e.data);\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        if (nodes.length) {\n          self.dispatchEvent('rightClickNode', {\n            node: nodes[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickNodes', {\n            node: nodes,\n            captor: e.data\n          });\n        } else if (edges.length) {\n          self.dispatchEvent('rightClickEdge', {\n            edge: edges[0],\n            captor: e.data\n          });\n          self.dispatchEvent('rightClickEdges', {\n            edge: edges,\n            captor: e.data\n          });\n        } else\n          self.dispatchEvent('rightClickStage', {captor: e.data});\n      }\n\n      function onOut(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        var k,\n            i,\n            l,\n            le,\n            outNodes = [],\n            outEdges = [];\n\n        for (k in overNodes)\n          outNodes.push(overNodes[k]);\n\n        overNodes = {};\n        // Dispatch both single and multi events:\n        for (i = 0, l = outNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: outNodes[i],\n            captor: e.data\n          });\n        if (outNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: outNodes,\n            captor: e.data\n          });\n\n        overEdges = {};\n        // Dispatch both single and multi events:\n        for (i = 0, le = outEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: outEdges[i],\n            captor: e.data\n          });\n        if (outEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: outEdges,\n            captor: e.data\n          });\n      }\n\n      function onMove(e) {\n        if (!self.settings('eventsEnabled'))\n          return;\n\n        nodes = getNodes(e);\n        edges = getEdges(e);\n\n        var i,\n            k,\n            node,\n            edge,\n            newOutNodes = [],\n            newOverNodes = [],\n            currentOverNodes = {},\n            l = nodes.length,\n            newOutEdges = [],\n            newOverEdges = [],\n            currentOverEdges = {},\n            le = edges.length;\n\n        // Check newly overred nodes:\n        for (i = 0; i < l; i++) {\n          node = nodes[i];\n          currentOverNodes[node.id] = node;\n          if (!overNodes[node.id]) {\n            newOverNodes.push(node);\n            overNodes[node.id] = node;\n          }\n        }\n\n        // Check no more overred nodes:\n        for (k in overNodes)\n          if (!currentOverNodes[k]) {\n            newOutNodes.push(overNodes[k]);\n            delete overNodes[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, l = newOverNodes.length; i < l; i++)\n          self.dispatchEvent('overNode', {\n            node: newOverNodes[i],\n            captor: e.data\n          });\n        for (i = 0, l = newOutNodes.length; i < l; i++)\n          self.dispatchEvent('outNode', {\n            node: newOutNodes[i],\n            captor: e.data\n          });\n        if (newOverNodes.length)\n          self.dispatchEvent('overNodes', {\n            nodes: newOverNodes,\n            captor: e.data\n          });\n        if (newOutNodes.length)\n          self.dispatchEvent('outNodes', {\n            nodes: newOutNodes,\n            captor: e.data\n          });\n\n        // Check newly overred edges:\n        for (i = 0; i < le; i++) {\n          edge = edges[i];\n          currentOverEdges[edge.id] = edge;\n          if (!overEdges[edge.id]) {\n            newOverEdges.push(edge);\n            overEdges[edge.id] = edge;\n          }\n        }\n\n        // Check no more overred edges:\n        for (k in overEdges)\n          if (!currentOverEdges[k]) {\n            newOutEdges.push(overEdges[k]);\n            delete overEdges[k];\n          }\n\n        // Dispatch both single and multi events:\n        for (i = 0, le = newOverEdges.length; i < le; i++)\n          self.dispatchEvent('overEdge', {\n            edge: newOverEdges[i],\n            captor: e.data\n          });\n        for (i = 0, le = newOutEdges.length; i < le; i++)\n          self.dispatchEvent('outEdge', {\n            edge: newOutEdges[i],\n            captor: e.data\n          });\n        if (newOverEdges.length)\n          self.dispatchEvent('overEdges', {\n            edges: newOverEdges,\n            captor: e.data\n          });\n        if (newOutEdges.length)\n          self.dispatchEvent('outEdges', {\n            edges: newOutEdges,\n            captor: e.data\n          });\n      }\n\n      // Bind events:\n      captor.bind('click', onClick);\n      captor.bind('mousedown', onMove);\n      captor.bind('mouseup', onMove);\n      captor.bind('mousemove', onMove);\n      captor.bind('mouseout', onOut);\n      captor.bind('doubleclick', onDoubleClick);\n      captor.bind('rightclick', onRightClick);\n      self.bind('render', onMove);\n    }\n\n    for (i = 0, l = this.captors.length; i < l; i++)\n      bindCaptor(this.captors[i]);\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.misc');\n\n  /**\n   * This method listens to \"overNode\", \"outNode\", \"overEdge\" and \"outEdge\"\n   * events from a renderer and renders the nodes differently on the top layer.\n   * The goal is to make any node label readable with the mouse, and to\n   * highlight hovered nodes and edges.\n   *\n   * It has to be called in the scope of the related renderer.\n   */\n  sigma.misc.drawHovers = function(prefix) {\n    var self = this,\n        hoveredNodes = {},\n        hoveredEdges = {};\n\n    this.bind('overNode', function(event) {\n      var node = event.data.node;\n      if (!node.hidden) {\n        hoveredNodes[node.id] = node;\n        draw();\n      }\n    });\n\n    this.bind('outNode', function(event) {\n      delete hoveredNodes[event.data.node.id];\n      draw();\n    });\n\n    this.bind('overEdge', function(event) {\n      var edge = event.data.edge;\n      if (!edge.hidden) {\n        hoveredEdges[edge.id] = edge;\n        draw();\n      }\n    });\n\n    this.bind('outEdge', function(event) {\n      delete hoveredEdges[event.data.edge.id];\n      draw();\n    });\n\n    this.bind('render', function(event) {\n      draw();\n    });\n\n    function draw() {\n\n      var k,\n          source,\n          target,\n          hoveredNode,\n          hoveredEdge,\n          c = self.contexts.hover.canvas,\n          defaultNodeType = self.settings('defaultNodeType'),\n          defaultEdgeType = self.settings('defaultEdgeType'),\n          nodeRenderers = sigma.canvas.hovers,\n          edgeRenderers = sigma.canvas.edgehovers,\n          extremitiesRenderers = sigma.canvas.extremities,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Clear self.contexts.hover:\n      self.contexts.hover.clearRect(0, 0, c.width, c.height);\n\n      // Node render: single hover\n      if (\n        embedSettings('enableHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredNodes).length\n      ) {\n        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];\n        (\n          nodeRenderers[hoveredNode.type] ||\n          nodeRenderers[defaultNodeType] ||\n          nodeRenderers.def\n        )(\n          hoveredNode,\n          self.contexts.hover,\n          embedSettings\n        );\n      }\n\n      // Node render: multiple hover\n      if (\n        embedSettings('enableHovering') &&\n        !embedSettings('singleHover')\n      )\n        for (k in hoveredNodes)\n          (\n            nodeRenderers[hoveredNodes[k].type] ||\n            nodeRenderers[defaultNodeType] ||\n            nodeRenderers.def\n          )(\n            hoveredNodes[k],\n            self.contexts.hover,\n            embedSettings\n          );\n\n      // Edge render: single hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        embedSettings('singleHover') &&\n        Object.keys(hoveredEdges).length\n      ) {\n        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];\n        source = self.graph.nodes(hoveredEdge.source);\n        target = self.graph.nodes(hoveredEdge.target);\n\n        if (! hoveredEdge.hidden) {\n          (\n            edgeRenderers[hoveredEdge.type] ||\n            edgeRenderers[defaultEdgeType] ||\n            edgeRenderers.def\n          ) (\n            hoveredEdge,\n            source,\n            target,\n            self.contexts.hover,\n            embedSettings\n          );\n\n          if (embedSettings('edgeHoverExtremities')) {\n            (\n              extremitiesRenderers[hoveredEdge.type] ||\n              extremitiesRenderers.def\n            )(\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n          } else {\n            // Avoid edges rendered over nodes:\n            (\n              sigma.canvas.nodes[source.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              source,\n              self.contexts.hover,\n              embedSettings\n            );\n            (\n              sigma.canvas.nodes[target.type] ||\n              sigma.canvas.nodes.def\n            ) (\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n          }\n        }\n      }\n\n      // Edge render: multiple hover\n      if (\n        embedSettings('enableEdgeHovering') &&\n        !embedSettings('singleHover')\n      ) {\n        for (k in hoveredEdges) {\n          hoveredEdge = hoveredEdges[k];\n          source = self.graph.nodes(hoveredEdge.source);\n          target = self.graph.nodes(hoveredEdge.target);\n\n          if (!hoveredEdge.hidden) {\n            (\n              edgeRenderers[hoveredEdge.type] ||\n              edgeRenderers[defaultEdgeType] ||\n              edgeRenderers.def\n            ) (\n              hoveredEdge,\n              source,\n              target,\n              self.contexts.hover,\n              embedSettings\n            );\n\n            if (embedSettings('edgeHoverExtremities')) {\n              (\n                extremitiesRenderers[hoveredEdge.type] ||\n                extremitiesRenderers.def\n              )(\n                hoveredEdge,\n                source,\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            } else {\n              // Avoid edges rendered over nodes:\n              (\n                sigma.canvas.nodes[source.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                source,\n                self.contexts.hover,\n                embedSettings\n              );\n              (\n                sigma.canvas.nodes[target.type] ||\n                sigma.canvas.nodes.def\n              ) (\n                target,\n                self.contexts.hover,\n                embedSettings\n              );\n            }\n          }\n        }\n      }\n    }\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edgehovers');\n\n  /**\n   * This hover renderer will display the edge with a different color or size.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edgehovers.def =\n    function(edge, source, target, context, settings) {\n      var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    if (settings('edgeHoverColor') === 'edge') {\n      color = edge.hover_color || color;\n    } else {\n      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;\n    }\n    size *= settings('edgeHoverSizeRatio');\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.edges');\n\n  /**\n   * The default edge renderer. It renders the edge as a simple line.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.edges.def = function(edge, source, target, context, settings) {\n    var color = edge.color,\n        prefix = settings('prefix') || '',\n        size = edge[prefix + 'size'] || 1,\n        edgeColor = settings('edgeColor'),\n        defaultNodeColor = settings('defaultNodeColor'),\n        defaultEdgeColor = settings('defaultEdgeColor');\n\n    if (!color)\n      switch (edgeColor) {\n        case 'source':\n          color = source.color || defaultNodeColor;\n          break;\n        case 'target':\n          color = target.color || defaultNodeColor;\n          break;\n        default:\n          color = defaultEdgeColor;\n          break;\n      }\n\n    context.strokeStyle = color;\n    context.lineWidth = size;\n    context.beginPath();\n    context.moveTo(\n      source[prefix + 'x'],\n      source[prefix + 'y']\n    );\n    context.lineTo(\n      target[prefix + 'x'],\n      target[prefix + 'y']\n    );\n    context.stroke();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.extremities');\n\n  /**\n   * The default renderer for hovered edge extremities. It renders the edge\n   * extremities as hovered.\n   *\n   * @param  {object}                   edge         The edge object.\n   * @param  {object}                   source node  The edge source node.\n   * @param  {object}                   target node  The edge target node.\n   * @param  {CanvasRenderingContext2D} context      The canvas context.\n   * @param  {configurable}             settings     The settings function.\n   */\n  sigma.canvas.extremities.def =\n    function(edge, source, target, context, settings) {\n    // Source Node:\n    (\n      sigma.canvas.hovers[source.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      source, context, settings\n    );\n\n    // Target Node:\n    (\n      sigma.canvas.hovers[target.type] ||\n      sigma.canvas.hovers.def\n    ) (\n      target, context, settings\n    );\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.hovers');\n\n  /**\n   * This hover renderer will basically display the label with a background.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.hovers.def = function(node, context, settings) {\n    var x,\n        y,\n        w,\n        h,\n        e,\n        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'],\n        fontSize = (settings('labelSize') === 'fixed') ?\n          settings('defaultLabelSize') :\n          settings('labelSizeRatio') * size;\n\n    // Label background:\n    context.font = (fontStyle ? fontStyle + ' ' : '') +\n      fontSize + 'px ' + (settings('hoverFont') || settings('font'));\n\n    context.beginPath();\n    context.fillStyle = settings('labelHoverBGColor') === 'node' ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultHoverLabelBGColor');\n\n    if (node.label && settings('labelHoverShadow')) {\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 8;\n      context.shadowColor = settings('labelHoverShadowColor');\n    }\n\n    if (node.label && typeof node.label === 'string') {\n      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n      w = Math.round(\n        context.measureText(node.label).width + fontSize / 2 + size + 7\n      );\n      h = Math.round(fontSize + 4);\n      e = Math.round(fontSize / 2 + 2);\n\n      context.moveTo(x, y + e);\n      context.arcTo(x, y, x + e, y, e);\n      context.lineTo(x + w, y);\n      context.lineTo(x + w, y + h);\n      context.lineTo(x + e, y + h);\n      context.arcTo(x, y + h, x, y + h - e, e);\n      context.lineTo(x, y + e);\n\n      context.closePath();\n      context.fill();\n\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n      context.shadowBlur = 0;\n    }\n\n    // Node border:\n    if (settings('borderSize') > 0) {\n      context.beginPath();\n      context.fillStyle = settings('nodeBorderColor') === 'node' ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultNodeBorderColor');\n      context.arc(\n        node[prefix + 'x'],\n        node[prefix + 'y'],\n        size + settings('borderSize'),\n        0,\n        Math.PI * 2,\n        true\n      );\n      context.closePath();\n      context.fill();\n    }\n\n    // Node:\n    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;\n    nodeRenderer(node, context, settings);\n\n    // Display the label:\n    if (node.label && typeof node.label === 'string') {\n      context.fillStyle = (settings('labelHoverColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelHoverColor');\n\n      context.fillText(\n        node.label,\n        Math.round(node[prefix + 'x'] + size + 3),\n        Math.round(node[prefix + 'y'] + fontSize / 3)\n      );\n    }\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.canvas.labels');\n\n  /**\n   * This label renderer will just display the label on the right of the node.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.labels.def = function(node, context, settings) {\n    var fontSize,\n        prefix = settings('prefix') || '',\n        size = node[prefix + 'size'];\n\n    if (size < settings('labelThreshold'))\n      return;\n\n    if (!node.label || typeof node.label !== 'string')\n      return;\n\n    fontSize = (settings('labelSize') === 'fixed') ?\n      settings('defaultLabelSize') :\n      settings('labelSizeRatio') * size;\n\n    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +\n      fontSize + 'px ' + settings('font');\n    context.fillStyle = (settings('labelColor') === 'node') ?\n      (node.color || settings('defaultNodeColor')) :\n      settings('defaultLabelColor');\n\n    context.fillText(\n      node.label,\n      Math.round(node[prefix + 'x'] + size + 3),\n      Math.round(node[prefix + 'y'] + fontSize / 3)\n    );\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.canvas.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   *\n   * @param  {object}                   node     The node object.\n   * @param  {CanvasRenderingContext2D} context  The canvas context.\n   * @param  {configurable}             settings The settings function.\n   */\n  sigma.canvas.nodes.def = function(node, context, settings) {\n    var prefix = settings('prefix') || '';\n\n    context.fillStyle = node.color || settings('defaultNodeColor');\n    context.beginPath();\n    context.arc(\n      node[prefix + 'x'],\n      node[prefix + 'y'],\n      node[prefix + 'size'],\n      0,\n      Math.PI * 2,\n      true\n    );\n\n    context.closePath();\n    context.fill();\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.canvas = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.canvas: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Node indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + this.conradId + ':';\n\n    // Initialize the DOM elements:\n    if (\n      !this.settings('batchEdgesDrawing')\n    ) {\n      this.initDOM('canvas', 'scene');\n      this.contexts.edges = this.contexts.scene;\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    } else {\n      this.initDOM('canvas', 'edges');\n      this.initDOM('canvas', 'scene');\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.labels = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.options.prefix);\n    sigma.misc.drawHovers.call(this, this.options.prefix);\n\n    this.resize(false);\n  };\n\n\n\n\n  /**\n   * This method renders the graph on the canvases.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.canvas}         Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        l,\n        o,\n        id,\n        end,\n        job,\n        start,\n        edges,\n        renderers,\n        rendererType,\n        batchSize,\n        tempGCO,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix\n        });\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Clear canvases:\n    this.clear();\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    // Find which nodes are on screen:\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Draw edges:\n    // - If settings('batchEdgesDrawing') is true, the edges are displayed per\n    //   batches. If not, they are drawn in one frame.\n    if (drawEdges) {\n      // First, let's identify which edges to draw. To do this, we just keep\n      // every edges that have at least one extremity displayed according to\n      // the quadtree and the \"hidden\" attribute. We also do not keep hidden\n      // edges.\n      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n        o = a[i];\n        if (\n          (index[o.source] || index[o.target]) &&\n          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n        )\n          this.edgesOnScreen.push(o);\n      }\n\n      // If the \"batchEdgesDrawing\" settings is true, edges are batched:\n      if (this.settings(options, 'batchEdgesDrawing')) {\n        id = 'edges_' + this.conradId;\n        batchSize = embedSettings('canvasEdgesBatchSize');\n\n        edges = this.edgesOnScreen;\n        l = edges.length;\n\n        start = 0;\n        end = Math.min(edges.length, start + batchSize);\n\n        job = function() {\n          tempGCO = this.contexts.edges.globalCompositeOperation;\n          this.contexts.edges.globalCompositeOperation = 'destination-over';\n\n          renderers = sigma.canvas.edges;\n          for (i = start; i < end; i++) {\n            o = edges[i];\n            (renderers[\n              o.type || this.settings(options, 'defaultEdgeType')\n            ] || renderers.def)(\n              o,\n              graph.nodes(o.source),\n              graph.nodes(o.target),\n              this.contexts.edges,\n              embedSettings\n            );\n          }\n\n          // Draw edge labels:\n          if (drawEdgeLabels) {\n            renderers = sigma.canvas.edges.labels;\n            for (i = start; i < end; i++) {\n              o = edges[i];\n              if (!o.hidden)\n                (renderers[\n                  o.type || this.settings(options, 'defaultEdgeType')\n                ] || renderers.def)(\n                  o,\n                  graph.nodes(o.source),\n                  graph.nodes(o.target),\n                  this.contexts.labels,\n                  embedSettings\n                );\n            }\n          }\n\n          // Restore original globalCompositeOperation:\n          this.contexts.edges.globalCompositeOperation = tempGCO;\n\n          // Catch job's end:\n          if (end === edges.length) {\n            delete this.jobs[id];\n            return false;\n          }\n\n          start = end + 1;\n          end = Math.min(edges.length, start + batchSize);\n          return true;\n        };\n\n        this.jobs[id] = job;\n        conrad.addJob(id, job.bind(this));\n\n      // If not, they are drawn in one frame:\n      } else {\n        renderers = sigma.canvas.edges;\n        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n          o = a[i];\n          (renderers[\n            o.type || this.settings(options, 'defaultEdgeType')\n          ] || renderers.def)(\n            o,\n            graph.nodes(o.source),\n            graph.nodes(o.target),\n            this.contexts.edges,\n            embedSettings\n          );\n        }\n\n        // Draw edge labels:\n        // - No batching\n        if (drawEdgeLabels) {\n          renderers = sigma.canvas.edges.labels;\n          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)\n            if (!a[i].hidden)\n              (renderers[\n                a[i].type || this.settings(options, 'defaultEdgeType')\n              ] || renderers.def)(\n                a[i],\n                graph.nodes(a[i].source),\n                graph.nodes(a[i].target),\n                this.contexts.labels,\n                embedSettings\n              );\n        }\n      }\n    }\n\n    // Draw nodes:\n    // - No batching\n    if (drawNodes) {\n      renderers = sigma.canvas.nodes;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.nodes,\n            embedSettings\n          );\n    }\n\n    // Draw labels:\n    // - No batching\n    if (drawLabels) {\n      renderers = sigma.canvas.labels;\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (renderers[\n            a[i].type || this.settings(options, 'defaultNodeType')\n          ] || renderers.def)(\n            a[i],\n            this.contexts.labels,\n            embedSettings\n          );\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {\n    var dom = document.createElement(tag);\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas')\n      this.contexts[id] = dom.getContext('2d');\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.canvas}        Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n          if (pixelRatio !== 1)\n            this.contexts[k].scale(pixelRatio, pixelRatio);\n        }\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.canvas} Returns the instance itself.\n   */\n  sigma.renderers.canvas.prototype.clear = function() {\n    for (var k in this.contexts) {\n      this.contexts[k].clearRect(0, 0, this.width, this.height);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.canvas.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./canvas\" folder.\n   */\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.canvas.edges');\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  var __instances = {};\n\n  /**\n   * This is the sigma instances constructor. One instance of sigma represent\n   * one graph. It is possible to represent this grapĥ with several renderers\n   * at the same time. By default, the default renderer (WebGL + Canvas\n   * polyfill) will be used as the only renderer, with the container specified\n   * in the configuration.\n   *\n   * @param  {?*}    conf The configuration of the instance. There are a lot of\n   *                      different recognized forms to instantiate sigma, check\n   *                      example files, documentation in this file and unit\n   *                      tests to know more.\n   * @return {sigma}      The fresh new sigma instance.\n   *\n   * Instanciating sigma:\n   * ********************\n   * If no parameter is given to the constructor, the instance will be created\n   * without any renderer or camera. It will just instantiate the graph, and\n   * other modules will have to be instantiated through the public methods,\n   * like \"addRenderer\" etc:\n   *\n   *  > s0 = new sigma();\n   *  > s0.addRenderer({\n   *  >   type: 'canvas',\n   *  >   container: 'my-container-id'\n   *  > });\n   *\n   * In most of the cases, sigma will simply be used with the default renderer.\n   * Then, since the only required parameter is the DOM container, there are\n   * some simpler way to call the constructor. The four following calls do the\n   * exact same things:\n   *\n   *  > s1 = new sigma('my-container-id');\n   *  > s2 = new sigma(document.getElementById('my-container-id'));\n   *  > s3 = new sigma({\n   *  >   container: document.getElementById('my-container-id')\n   *  > });\n   *  > s4 = new sigma({\n   *  >   renderers: [{\n   *  >     container: document.getElementById('my-container-id')\n   *  >   }]\n   *  > });\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters, when calling the\n   * constructor with to top level configuration object (fourth case in the\n   * previous examples):\n   *\n   *   {?string} id        The id of the instance. It will be generated\n   *                       automatically if not specified.\n   *   {?array}  renderers An array containing objects describing renderers.\n   *   {?object} graph     An object containing an array of nodes and an array\n   *                       of edges, to avoid having to add them by hand later.\n   *   {?object} settings  An object containing instance specific settings that\n   *                       will override the default ones defined in the object\n   *                       sigma.settings.\n   */\n  var sigma = function(conf) {\n    // Local variables:\n    // ****************\n    var i,\n        l,\n        a,\n        c,\n        o,\n        id;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Private attributes:\n    // *******************\n    var _self = this,\n        _conf = conf || {};\n\n    // Little shortcut:\n    // ****************\n    // The configuration is supposed to have a list of the configuration\n    // objects for each renderer.\n    //  - If there are no configuration at all, then nothing is done.\n    //  - If there are no renderer list, the given configuration object will be\n    //    considered as describing the first and only renderer.\n    //  - If there are no renderer list nor \"container\" object, it will be\n    //    considered as the container itself (a DOM element).\n    //  - If the argument passed to sigma() is a string, it will be considered\n    //    as the ID of the DOM container.\n    if (\n      typeof _conf === 'string' ||\n      _conf instanceof HTMLElement\n    )\n      _conf = {\n        renderers: [_conf]\n      };\n    else if (Object.prototype.toString.call(_conf) === '[object Array]')\n      _conf = {\n        renderers: _conf\n      };\n\n    // Also check \"renderer\" and \"container\" keys:\n    o = _conf.renderers || _conf.renderer || _conf.container;\n    if (!_conf.renderers || _conf.renderers.length === 0)\n      if (\n        typeof o === 'string' ||\n        o instanceof HTMLElement ||\n        (typeof o === 'object' && 'container' in o)\n      )\n        _conf.renderers = [o];\n\n    // Recense the instance:\n    if (_conf.id) {\n      if (__instances[_conf.id])\n        throw 'sigma: Instance \"' + _conf.id + '\" already exists.';\n      Object.defineProperty(this, 'id', {\n        value: _conf.id\n      });\n    } else {\n      id = 0;\n      while (__instances[id])\n        id++;\n      Object.defineProperty(this, 'id', {\n        value: '' + id\n      });\n    }\n    __instances[this.id] = this;\n\n    // Initialize settings function:\n    this.settings = new sigma.classes.configurable(\n      sigma.settings,\n      _conf.settings || {}\n    );\n\n    // Initialize locked attributes:\n    Object.defineProperty(this, 'graph', {\n      value: new sigma.classes.graph(this.settings),\n      configurable: true\n    });\n    Object.defineProperty(this, 'middlewares', {\n      value: [],\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameras', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderers', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'renderersPerCamera', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'cameraFrames', {\n      value: {},\n      configurable: true\n    });\n    Object.defineProperty(this, 'camera', {\n      get: function() {\n        return this.cameras[0];\n      }\n    });\n    Object.defineProperty(this, 'events', {\n      value: [\n        'click',\n        'rightClick',\n        'clickStage',\n        'doubleClickStage',\n        'rightClickStage',\n        'clickNode',\n        'clickNodes',\n        'doubleClickNode',\n        'doubleClickNodes',\n        'rightClickNode',\n        'rightClickNodes',\n        'overNode',\n        'overNodes',\n        'outNode',\n        'outNodes',\n        'downNode',\n        'downNodes',\n        'upNode',\n        'upNodes'\n      ],\n      configurable: true\n    });\n\n    // Add a custom handler, to redispatch events from renderers:\n    this._handler = (function(e) {\n      var k,\n          data = {};\n\n      for (k in e.data)\n        data[k] = e.data[k];\n\n      data.renderer = e.target;\n      this.dispatchEvent(e.type, data);\n    }).bind(this);\n\n    // Initialize renderers:\n    a = _conf.renderers || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.addRenderer(a[i]);\n\n    // Initialize middlewares:\n    a = _conf.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      this.middlewares.push(\n        typeof a[i] === 'string' ?\n          sigma.middlewares[a[i]] :\n          a[i]\n      );\n\n    // Check if there is already a graph to fill in:\n    if (typeof _conf.graph === 'object' && _conf.graph) {\n      this.graph.read(_conf.graph);\n\n      // If a graph is given to the to the instance, the \"refresh\" method is\n      // directly called:\n      this.refresh();\n    }\n\n    // Deal with resize:\n    window.addEventListener('resize', function() {\n      if (_self.settings)\n        _self.refresh();\n    });\n  };\n\n\n\n\n  /**\n   * This methods will instantiate and reference a new camera. If no id is\n   * specified, then an automatic id will be generated.\n   *\n   * @param  {?string}              id Eventually the camera id.\n   * @return {sigma.classes.camera}    The fresh new camera instance.\n   */\n  sigma.prototype.addCamera = function(id) {\n    var self = this,\n        camera;\n\n    if (!arguments.length) {\n      id = 0;\n      while (this.cameras['' + id])\n        id++;\n      id = '' + id;\n    }\n\n    if (this.cameras[id])\n      throw 'sigma.addCamera: The camera \"' + id + '\" already exists.';\n\n    camera = new sigma.classes.camera(id, this.graph, this.settings);\n    this.cameras[id] = camera;\n\n    // Add a quadtree to the camera:\n    camera.quadtree = new sigma.classes.quad();\n\n    // Add an edgequadtree to the camera:\n    if (sigma.classes.edgequad !== undefined) {\n      camera.edgequadtree = new sigma.classes.edgequad();\n    }\n\n    camera.bind('coordinatesUpdated', function(e) {\n      self.renderCamera(camera, camera.isAnimated);\n    });\n\n    this.renderersPerCamera[id] = [];\n\n    return camera;\n  };\n\n  /**\n   * This method kills a camera, and every renderer attached to it.\n   *\n   * @param  {string|camera} v The camera to kill or its ID.\n   * @return {sigma}           Returns the instance.\n   */\n  sigma.prototype.killCamera = function(v) {\n    v = typeof v === 'string' ? this.cameras[v] : v;\n\n    if (!v)\n      throw 'sigma.killCamera: The camera is undefined.';\n\n    var i,\n        l,\n        a = this.renderersPerCamera[v.id];\n\n    for (l = a.length, i = l - 1; i >= 0; i--)\n      this.killRenderer(a[i]);\n\n    delete this.renderersPerCamera[v.id];\n    delete this.cameraFrames[v.id];\n    delete this.cameras[v.id];\n\n    if (v.kill)\n      v.kill();\n\n    return this;\n  };\n\n  /**\n   * This methods will instantiate and reference a new renderer. The \"type\"\n   * argument can be the constructor or its name in the \"sigma.renderers\"\n   * package. If no type is specified, then \"sigma.renderers.def\" will be used.\n   * If no id is specified, then an automatic id will be generated.\n   *\n   * @param  {?object}  options Eventually some options to give to the renderer\n   *                            constructor.\n   * @return {renderer}         The fresh new renderer instance.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?string}            id     Eventually the renderer id.\n   *   {?(function|string)} type   Eventually the renderer constructor or its\n   *                               name in the \"sigma.renderers\" package.\n   *   {?(camera|string)}   camera Eventually the renderer camera or its\n   *                               id.\n   */\n  sigma.prototype.addRenderer = function(options) {\n    var id,\n        fn,\n        camera,\n        renderer,\n        o = options || {};\n\n    // Polymorphism:\n    if (typeof o === 'string')\n      o = {\n        container: document.getElementById(o)\n      };\n    else if (o instanceof HTMLElement)\n      o = {\n        container: o\n      };\n\n    // If the container still is a string, we get it by id\n    if (typeof o.container === 'string')\n      o.container = document.getElementById(o.container);\n\n    // Reference the new renderer:\n    if (!('id' in o)) {\n      id = 0;\n      while (this.renderers['' + id])\n        id++;\n      id = '' + id;\n    } else\n      id = o.id;\n\n    if (this.renderers[id])\n      throw 'sigma.addRenderer: The renderer \"' + id + '\" already exists.';\n\n    // Find the good constructor:\n    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];\n    fn = fn || sigma.renderers.def;\n\n    // Find the good camera:\n    camera = 'camera' in o ?\n      (\n        o.camera instanceof sigma.classes.camera ?\n          o.camera :\n          this.cameras[o.camera] || this.addCamera(o.camera)\n      ) :\n      this.addCamera();\n\n    if (this.cameras[camera.id] !== camera)\n      throw 'sigma.addRenderer: The camera is not properly referenced.';\n\n    // Instantiate:\n    renderer = new fn(this.graph, camera, this.settings, o);\n    this.renderers[id] = renderer;\n    Object.defineProperty(renderer, 'id', {\n      value: id\n    });\n\n    // Bind events:\n    if (renderer.bind)\n      renderer.bind(\n        [\n          'click',\n          'rightClick',\n          'clickStage',\n          'doubleClickStage',\n          'rightClickStage',\n          'clickNode',\n          'clickNodes',\n          'clickEdge',\n          'clickEdges',\n          'doubleClickNode',\n          'doubleClickNodes',\n          'doubleClickEdge',\n          'doubleClickEdges',\n          'rightClickNode',\n          'rightClickNodes',\n          'rightClickEdge',\n          'rightClickEdges',\n          'overNode',\n          'overNodes',\n          'overEdge',\n          'overEdges',\n          'outNode',\n          'outNodes',\n          'outEdge',\n          'outEdges',\n          'downNode',\n          'downNodes',\n          'downEdge',\n          'downEdges',\n          'upNode',\n          'upNodes',\n          'upEdge',\n          'upEdges'\n        ],\n        this._handler\n      );\n\n    // Reference the renderer by its camera:\n    this.renderersPerCamera[camera.id].push(renderer);\n\n    return renderer;\n  };\n\n  /**\n   * This method kills a renderer.\n   *\n   * @param  {string|renderer} v The renderer to kill or its ID.\n   * @return {sigma}             Returns the instance.\n   */\n  sigma.prototype.killRenderer = function(v) {\n    v = typeof v === 'string' ? this.renderers[v] : v;\n\n    if (!v)\n      throw 'sigma.killRenderer: The renderer is undefined.';\n\n    var a = this.renderersPerCamera[v.camera.id],\n        i = a.indexOf(v);\n\n    if (i >= 0)\n      a.splice(i, 1);\n\n    if (v.kill)\n      v.kill();\n\n    delete this.renderers[v.id];\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method calls the \"render\" method of each renderer, with the same\n   * arguments than the \"render\" method, but will also check if the renderer\n   * has a \"process\" method, and call it if it exists.\n   *\n   * It is useful for quadtrees or WebGL processing, for instance.\n   *\n   * @param  {?object}  options Eventually some options to give to the refresh\n   *                            method.\n   * @return {sigma}            Returns the instance itself.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the \"options\"\n   * object:\n   *\n   *   {?boolean} skipIndexation A flag specifying wether or not the refresh\n   *                             function should reindex the graph in the\n   *                             quadtrees or not (default: false).\n   */\n  sigma.prototype.refresh = function(options) {\n    var i,\n        l,\n        k,\n        a,\n        c,\n        bounds,\n        prefix = 0;\n\n    options = options || {};\n\n    // Call each middleware:\n    a = this.middlewares || [];\n    for (i = 0, l = a.length; i < l; i++)\n      a[i].call(\n        this,\n        (i === 0) ? '' : 'tmp' + prefix + ':',\n        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')\n      );\n\n    // Then, for each camera, call the \"rescale\" middleware, unless the\n    // settings specify not to:\n    for (k in this.cameras) {\n      c = this.cameras[k];\n      if (\n        c.settings('autoRescale') &&\n        this.renderersPerCamera[c.id] &&\n        this.renderersPerCamera[c.id].length\n      )\n        sigma.middlewares.rescale.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix,\n          {\n            width: this.renderersPerCamera[c.id][0].width,\n            height: this.renderersPerCamera[c.id][0].height\n          }\n        );\n      else\n        sigma.middlewares.copy.call(\n          this,\n          a.length ? 'ready:' : '',\n          c.readPrefix\n        );\n\n      if (!options.skipIndexation) {\n        // Find graph boundaries:\n        bounds = sigma.utils.getBoundaries(\n          this.graph,\n          c.readPrefix\n        );\n\n        // Refresh quadtree:\n        c.quadtree.index(this.graph.nodes(), {\n          prefix: c.readPrefix,\n          bounds: {\n            x: bounds.minX,\n            y: bounds.minY,\n            width: bounds.maxX - bounds.minX,\n            height: bounds.maxY - bounds.minY\n          }\n        });\n\n        // Refresh edgequadtree:\n        if (\n          c.edgequadtree !== undefined &&\n          c.settings('drawEdges') &&\n          c.settings('enableEdgeHovering')\n        ) {\n          c.edgequadtree.index(this.graph, {\n            prefix: c.readPrefix,\n            bounds: {\n              x: bounds.minX,\n              y: bounds.minY,\n              width: bounds.maxX - bounds.minX,\n              height: bounds.maxY - bounds.minY\n            }\n          });\n        }\n      }\n    }\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.renderers[a[i]].process) {\n        if (this.settings('skipErrors'))\n          try {\n            this.renderers[a[i]].process();\n          } catch (e) {\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".process()\"'\n            );\n          }\n        else\n          this.renderers[a[i]].process();\n      }\n\n    this.render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer.\n   *\n   * @return {sigma} Returns the instance itself.\n   */\n  sigma.prototype.render = function() {\n    var i,\n        l,\n        a,\n        prefix = 0;\n\n    // Call each renderer:\n    a = Object.keys(this.renderers);\n    for (i = 0, l = a.length; i < l; i++)\n      if (this.settings('skipErrors'))\n        try {\n          this.renderers[a[i]].render();\n        } catch (e) {\n          if (this.settings('verbose'))\n            console.log(\n              'Warning: The renderer \"' + a[i] + '\" crashed on \".render()\"'\n            );\n        }\n      else\n        this.renderers[a[i]].render();\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"render\" method of each renderer that is bound to\n   * the specified camera. To improve the performances, if this method is\n   * called too often, the number of effective renderings is limitated to one\n   * per frame, unless you are using the \"force\" flag.\n   *\n   * @param  {sigma.classes.camera} camera The camera to render.\n   * @param  {?boolean}             force  If true, will render the camera\n   *                                       directly.\n   * @return {sigma}                       Returns the instance itself.\n   */\n  sigma.prototype.renderCamera = function(camera, force) {\n    var i,\n        l,\n        a,\n        self = this;\n\n    if (force) {\n      a = this.renderersPerCamera[camera.id];\n      for (i = 0, l = a.length; i < l; i++)\n        if (this.settings('skipErrors'))\n          try {\n            a[i].render();\n          } catch (e) {\n            if (this.settings('verbose'))\n              console.log(\n                'Warning: The renderer \"' + a[i].id + '\" crashed on \".render()\"'\n              );\n          }\n        else\n          a[i].render();\n    } else {\n      if (!this.cameraFrames[camera.id]) {\n        a = this.renderersPerCamera[camera.id];\n        for (i = 0, l = a.length; i < l; i++)\n          if (this.settings('skipErrors'))\n            try {\n              a[i].render();\n            } catch (e) {\n              if (this.settings('verbose'))\n                console.log(\n                  'Warning: The renderer \"' +\n                    a[i].id +\n                    '\" crashed on \".render()\"'\n                );\n            }\n          else\n            a[i].render();\n\n        this.cameraFrames[camera.id] = requestAnimationFrame(function() {\n          delete self.cameraFrames[camera.id];\n        });\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * This method calls the \"kill\" method of each module and destroys any\n   * reference from the instance.\n   */\n  sigma.prototype.kill = function() {\n    var k;\n\n    // Dispatching event\n    this.dispatchEvent('kill');\n\n    // Kill graph:\n    this.graph.kill();\n\n    // Kill middlewares:\n    delete this.middlewares;\n\n    // Kill each renderer:\n    for (k in this.renderers)\n      this.killRenderer(this.renderers[k]);\n\n    // Kill each camera:\n    for (k in this.cameras)\n      this.killCamera(this.cameras[k]);\n\n    delete this.renderers;\n    delete this.cameras;\n\n    // Kill everything else:\n    for (k in this)\n      if (this.hasOwnProperty(k))\n        delete this[k];\n\n    delete __instances[this.id];\n  };\n\n\n\n\n  /**\n   * Returns a clone of the instances object or a specific running instance.\n   *\n   * @param  {?string} id Eventually an instance ID.\n   * @return {object}     The related instance or a clone of the instances\n   *                      object.\n   */\n  sigma.instances = function(id) {\n    return arguments.length ?\n      __instances[id] :\n      sigma.utils.extend({}, __instances);\n  };\n\n\n\n  /**\n   * The current version of sigma:\n   */\n  sigma.version = '1.2.0';\n\n\n\n\n  /**\n   * EXPORT:\n   * *******\n   */\n  if (typeof this.sigma !== 'undefined')\n    throw 'An object called sigma is already in the global scope.';\n\n  this.sigma = sigma;\n\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Packages initialization:\n  sigma.utils.pkg('sigma.settings');\n\n  var settings = {\n    /**\n     * GRAPH SETTINGS:\n     * ***************\n     */\n    // {boolean} Indicates if the data have to be cloned in methods to add\n    //           nodes or edges.\n    clone: true,\n    // {boolean} Indicates if nodes \"id\" values and edges \"id\", \"source\" and\n    //           \"target\" values must be set as immutable.\n    immutable: true,\n    // {boolean} Indicates if sigma can log its errors and warnings.\n    verbose: false,\n\n\n    /**\n     * RENDERERS SETTINGS:\n     * *******************\n     */\n    // {string}\n    classPrefix: 'sigma',\n    // {string}\n    defaultNodeType: 'def',\n    // {string}\n    defaultEdgeType: 'def',\n    // {string}\n    defaultLabelColor: '#000',\n    // {string}\n    defaultEdgeColor: '#000',\n    // {string}\n    defaultNodeColor: '#000',\n    // {string}\n    defaultLabelSize: 14,\n    // {string} Indicates how to choose the edges color. Available values:\n    //          \"source\", \"target\", \"default\"\n    edgeColor: 'source',\n    // {number} Defines the minimal edge's arrow display size.\n    minArrowSize: 0,\n    // {string}\n    font: 'arial',\n    // {string} Example: 'bold'\n    fontStyle: '',\n    // {string} Indicates how to choose the labels color. Available values:\n    //          \"node\", \"default\"\n    labelColor: 'default',\n    // {string} Indicates how to choose the labels size. Available values:\n    //          \"fixed\", \"proportional\"\n    labelSize: 'fixed',\n    // {string} The ratio between the font size of the label and the node size.\n    labelSizeRatio: 1,\n    // {number} The minimum size a node must have to see its label displayed.\n    labelThreshold: 8,\n    // {number} The oversampling factor used in WebGL renderer.\n    webglOversamplingRatio: 2,\n    // {number} The size of the border of hovered nodes.\n    borderSize: 0,\n    // {number} The default hovered node border's color.\n    defaultNodeBorderColor: '#000',\n    // {number} The hovered node's label font. If not specified, will heritate\n    //          the \"font\" value.\n    hoverFont: '',\n    // {boolean} If true, then only one node can be hovered at a time.\n    singleHover: true,\n    // {string} Example: 'bold'\n    hoverFontStyle: '',\n    // {string} Indicates how to choose the hovered nodes shadow color.\n    //          Available values: \"node\", \"default\"\n    labelHoverShadow: 'default',\n    // {string}\n    labelHoverShadowColor: '#000',\n    // {string} Indicates how to choose the hovered nodes color.\n    //          Available values: \"node\", \"default\"\n    nodeHoverColor: 'node',\n    // {string}\n    defaultNodeHoverColor: '#000',\n    // {string} Indicates how to choose the hovered nodes background color.\n    //          Available values: \"node\", \"default\"\n    labelHoverBGColor: 'default',\n    // {string}\n    defaultHoverLabelBGColor: '#fff',\n    // {string} Indicates how to choose the hovered labels color.\n    //          Available values: \"node\", \"default\"\n    labelHoverColor: 'default',\n    // {string}\n    defaultLabelHoverColor: '#000',\n    // {string} Indicates how to choose the edges hover color. Available values:\n    //          \"edge\", \"default\"\n    edgeHoverColor: 'edge',\n    // {number} The size multiplicator of hovered edges.\n    edgeHoverSizeRatio: 1,\n    // {string}\n    defaultEdgeHoverColor: '#000',\n    // {boolean} Indicates if the edge extremities must be hovered when the\n    //           edge is hovered.\n    edgeHoverExtremities: false,\n    // {booleans} The different drawing modes:\n    //           false: Layered not displayed.\n    //           true: Layered displayed.\n    drawEdges: true,\n    drawNodes: true,\n    drawLabels: true,\n    drawEdgeLabels: false,\n    // {boolean} Indicates if the edges must be drawn in several frames or in\n    //           one frame, as the nodes and labels are drawn.\n    batchEdgesDrawing: false,\n    // {boolean} Indicates if the edges must be hidden during dragging and\n    //           animations.\n    hideEdgesOnMove: false,\n    // {numbers} The different batch sizes, when elements are displayed in\n    //           several frames.\n    canvasEdgesBatchSize: 500,\n    webglEdgesBatchSize: 1000,\n\n\n\n\n    /**\n     * RESCALE SETTINGS:\n     * *****************\n     */\n    // {string} Indicates of to scale the graph relatively to its container.\n    //          Available values: \"inside\", \"outside\"\n    scalingMode: 'inside',\n    // {number} The margin to keep around the graph.\n    sideMargin: 0,\n    // {number} Determine the size of the smallest and the biggest node / edges\n    //          on the screen. This mapping makes easier to display the graph,\n    //          avoiding too big nodes that take half of the screen, or too\n    //          small ones that are not readable. If the two parameters are\n    //          equals, then the minimal display size will be 0. And if they\n    //          are both equal to 0, then there is no mapping, and the radius\n    //          of the nodes will be their size.\n    minEdgeSize: 0.5,\n    maxEdgeSize: 1,\n    minNodeSize: 1,\n    maxNodeSize: 8,\n\n\n\n\n    /**\n     * CAPTORS SETTINGS:\n     * *****************\n     */\n    // {boolean}\n    touchEnabled: true,\n    // {boolean}\n    mouseEnabled: true,\n    // {boolean}\n    mouseWheelEnabled: true,\n    // {boolean}\n    doubleClickEnabled: true,\n    // {boolean} Defines whether the custom events such as \"clickNode\" can be\n    //           used.\n    eventsEnabled: true,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms with the mouse-wheel.\n    zoomingRatio: 1.7,\n    // {number} Defines by how much multiplicating the zooming level when the\n    //          user zooms by double clicking.\n    doubleClickZoomingRatio: 2.2,\n    // {number} The minimum zooming level.\n    zoomMin: 0.0625,\n    // {number} The maximum zooming level.\n    zoomMax: 2,\n    // {number} The duration of animations following a mouse scrolling.\n    mouseZoomDuration: 200,\n    // {number} The duration of animations following a mouse double click.\n    doubleClickZoomDuration: 200,\n    // {number} The duration of animations following a mouse dropping.\n    mouseInertiaDuration: 200,\n    // {number} The inertia power (mouse captor).\n    mouseInertiaRatio: 3,\n    // {number} The duration of animations following a touch dropping.\n    touchInertiaDuration: 200,\n    // {number} The inertia power (touch captor).\n    touchInertiaRatio: 3,\n    // {number} The maximum time between two clicks to make it a double click.\n    doubleClickTimeout: 300,\n    // {number} The maximum time between two taps to make it a double tap.\n    doubleTapTimeout: 300,\n    // {number} The maximum time of dragging to trigger intertia.\n    dragTimeout: 200,\n\n\n\n\n    /**\n     * GLOBAL SETTINGS:\n     * ****************\n     */\n    // {boolean} Determines whether the instance has to refresh itself\n    //           automatically when a \"resize\" event is dispatched from the\n    //           window object.\n    autoResize: true,\n    // {boolean} Determines whether the \"rescale\" middleware has to be called\n    //           automatically for each camera on refresh.\n    autoRescale: true,\n    // {boolean} If set to false, the camera method \"goTo\" will basically do\n    //           nothing.\n    enableCamera: true,\n    // {boolean} If set to false, the nodes cannot be hovered.\n    enableHovering: true,\n    // {boolean} If set to true, the edges can be hovered.\n    enableEdgeHovering: false,\n    // {number} The size of the area around the edges to activate hovering.\n    edgeHoverPrecision: 5,\n    // {boolean} If set to true, the rescale middleware will ignore node sizes\n    //           to determine the graphs boundings.\n    rescaleIgnoreSize: false,\n    // {boolean} Determines if the core has to try to catch errors on\n    //           rendering.\n    skipErrors: false,\n\n\n\n\n    /**\n     * CAMERA SETTINGS:\n     * ****************\n     */\n    // {number} The power degrees applied to the nodes/edges size relatively to\n    //          the zooming level. Basically:\n    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R\n    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T\n    nodesPowRatio: 0.5,\n    edgesPowRatio: 0.5,\n\n\n\n\n    /**\n     * ANIMATIONS SETTINGS:\n     * ********************\n     */\n    // {number} The default animation time.\n    animationsTime: 200\n  };\n\n  // Export the previously designed settings:\n  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(global) {\n  'use strict';\n\n  /**\n   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n   * requestAnimationFrame polyfill by Erik Möller.\n   * fixes from Paul Irish and Tino Zijdel\n   * MIT license\n   */\n  var x,\n      lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {\n    global.requestAnimationFrame =\n      global[vendors[x] + 'RequestAnimationFrame'];\n    global.cancelAnimationFrame =\n      global[vendors[x] + 'CancelAnimationFrame'] ||\n      global[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!global.requestAnimationFrame)\n    global.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime(),\n          timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n          id = global.setTimeout(\n            function() {\n              callback(currTime + timeToCall);\n            },\n            timeToCall\n          );\n\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n  if (!global.cancelAnimationFrame)\n    global.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n\n  /**\n   * Function.prototype.bind polyfill found on MDN.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility\n   * Public domain\n   */\n  if (!Function.prototype.bind)\n    Function.prototype.bind = function(oThis) {\n      if (typeof this !== 'function')\n        // Closest thing possible to the ECMAScript 5 internal IsCallable\n        // function:\n        throw new TypeError(\n          'Function.prototype.bind - what is trying to be bound is not callable'\n        );\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP,\n          fBound;\n\n      fNOP = function() {};\n      fBound = function() {\n        return fToBind.apply(\n          this instanceof fNOP && oThis ?\n            this :\n            oThis,\n          aArgs.concat(Array.prototype.slice.call(arguments))\n        );\n      };\n\n      fNOP.prototype = this.prototype;\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n})(this);\n\n}.call(window));\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  var _root = this;\n\n  // Initialize packages:\n  sigma.utils = sigma.utils || {};\n\n  /**\n   * MISC UTILS:\n   */\n  /**\n   * This function takes any number of objects as arguments, copies from each\n   * of these objects each pair key/value into a new object, and finally\n   * returns this object.\n   *\n   * The arguments are parsed from the last one to the first one, such that\n   * when several objects have keys in common, the \"earliest\" object wins.\n   *\n   * Example:\n   * ********\n   *  > var o1 = {\n   *  >       a: 1,\n   *  >       b: 2,\n   *  >       c: '3'\n   *  >     },\n   *  >     o2 = {\n   *  >       c: '4',\n   *  >       d: [ 5 ]\n   *  >     };\n   *  > sigma.utils.extend(o1, o2);\n   *  > // Returns: {\n   *  > //   a: 1,\n   *  > //   b: 2,\n   *  > //   c: '3',\n   *  > //   d: [ 5 ]\n   *  > // };\n   *\n   * @param  {object+} Any number of objects.\n   * @return {object}  The merged object.\n   */\n  sigma.utils.extend = function() {\n    var i,\n        k,\n        res = {},\n        l = arguments.length;\n\n    for (i = l - 1; i >= 0; i--)\n      for (k in arguments[i])\n        res[k] = arguments[i][k];\n\n    return res;\n  };\n\n  /**\n   * A short \"Date.now()\" polyfill.\n   *\n   * @return {Number} The current time (in ms).\n   */\n  sigma.utils.dateNow = function() {\n    return Date.now ? Date.now() : new Date().getTime();\n  };\n\n  /**\n   * Takes a package name as parameter and checks at each lebel if it exists,\n   * and if it does not, creates it.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.pkg('a.b.c');\n   *  > a.b.c;\n   *  > // Object {};\n   *  >\n   *  > sigma.utils.pkg('a.b.d');\n   *  > a.b;\n   *  > // Object { c: {}, d: {} };\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.pkg = function(pkgName) {\n    return (pkgName || '').split('.').reduce(function(context, objName) {\n      return (objName in context) ?\n        context[objName] :\n        (context[objName] = {});\n    }, _root);\n  };\n\n  /**\n   * Returns a unique incremental number ID.\n   *\n   * Example:\n   * ********\n   *  > sigma.utils.id();\n   *  > // 1;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 2;\n   *  >\n   *  > sigma.utils.id();\n   *  > // 3;\n   *\n   * @param  {string} pkgName The name of the package to create/find.\n   * @return {object}         The related package.\n   */\n  sigma.utils.id = (function() {\n    var i = 0;\n    return function() {\n      return ++i;\n    };\n  })();\n\n  /**\n   * This function takes an hexa color (for instance \"#ffcc00\" or \"#fc0\") or a\n   * rgb / rgba color (like \"rgb(255,255,12)\" or \"rgba(255,255,12,1)\") and\n   * returns an integer equal to \"r * 255 * 255 + g * 255 + b\", to gain some\n   * memory in the data given to WebGL shaders.\n   *\n   * Note that the function actually caches its results for better performance.\n   *\n   * @param  {string} val The hexa or rgba color.\n   * @return {number}     The number value.\n   */\n  var floatColorCache = {};\n\n  sigma.utils.floatColor = function(val) {\n\n    // Is the color already computed?\n    if (floatColorCache[val])\n      return floatColorCache[val];\n\n    var original = val,\n        r = 0,\n        g = 0,\n        b = 0;\n\n    if (val[0] === '#') {\n      val = val.slice(1);\n\n      if (val.length === 3) {\n        r = parseInt(val.charAt(0) + val.charAt(0), 16);\n        g = parseInt(val.charAt(1) + val.charAt(1), 16);\n        b = parseInt(val.charAt(2) + val.charAt(2), 16);\n      }\n      else {\n        r = parseInt(val.charAt(0) + val.charAt(1), 16);\n        g = parseInt(val.charAt(2) + val.charAt(3), 16);\n        b = parseInt(val.charAt(4) + val.charAt(5), 16);\n      }\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      r = +val[1];\n      g = +val[2];\n      b = +val[3];\n    }\n\n    var color = (\n      r * 256 * 256 +\n      g * 256 +\n      b\n    );\n\n    // Caching the color\n    floatColorCache[original] = color;\n\n    return color;\n  };\n\n    /**\n   * Perform a zoom into a camera, with or without animation, to the\n   * coordinates indicated using a specified ratio.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the animation\n   * object:\n   *\n   *   {?number} duration     An amount of time that means the duration of the\n   *                          animation. If this parameter doesn't exist the\n   *                          zoom will be performed without animation.\n   *   {?function} onComplete A function to perform it after the animation. It\n   *                          will be performed even if there is no duration.\n   *\n   * @param {camera}     The camera where perform the zoom.\n   * @param {x}          The X coordiantion where the zoom goes.\n   * @param {y}          The Y coordiantion where the zoom goes.\n   * @param {ratio}      The ratio to apply it to the current camera ratio.\n   * @param {?animation} A dictionary with options for a possible animation.\n   */\n  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {\n    var settings = camera.settings,\n        count,\n        newRatio,\n        animationSettings,\n        coordinates;\n\n    // Create the newRatio dealing with min / max:\n    newRatio = Math.max(\n      settings('zoomMin'),\n      Math.min(\n        settings('zoomMax'),\n        camera.ratio * ratio\n      )\n    );\n\n    // Check that the new ratio is different from the initial one:\n    if (newRatio !== camera.ratio) {\n      // Create the coordinates variable:\n      ratio = newRatio / camera.ratio;\n      coordinates = {\n        x: x * (1 - ratio) + camera.x,\n        y: y * (1 - ratio) + camera.y,\n        ratio: newRatio\n      };\n\n      if (animation && animation.duration) {\n        // Complete the animation setings:\n        count = sigma.misc.animation.killAll(camera);\n        animation = sigma.utils.extend(\n          animation,\n          {\n            easing: count ? 'quadraticOut' : 'quadraticInOut'\n          }\n        );\n\n        sigma.misc.animation.camera(camera, coordinates, animation);\n      } else {\n        camera.goTo(coordinates);\n        if (animation && animation.onComplete)\n          animation.onComplete();\n      }\n    }\n  };\n\n  /**\n   * Return the control point coordinates for a quadratic bezier curve.\n   *\n   * @param  {number} x1  The X coordinate of the start point.\n   * @param  {number} y1  The Y coordinate of the start point.\n   * @param  {number} x2  The X coordinate of the end point.\n   * @param  {number} y2  The Y coordinate of the end point.\n   * @return {x,y}        The control point coordinates.\n   */\n  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {\n    return {\n      x: (x1 + x2) / 2 + (y2 - y1) / 4,\n      y: (y1 + y2) / 2 + (x1 - x2) / 4\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the quadratic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the ending point.\n    * @param  {number} y2 The Y coordinate of the ending point.\n    * @param  {number} xi The X coordinate of the control point.\n    * @param  {number} yi The Y coordinate of the control point.\n    * @return {object}    {x,y}.\n  */\n  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {\n    // http://stackoverflow.com/a/5634528\n    return {\n      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,\n      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2\n    };\n  };\n\n  /**\n    * Compute the coordinates of the point positioned\n    * at length t in the cubic bezier curve.\n    *\n    * @param  {number} t  In [0,1] the step percentage to reach\n    *                     the point in the curve from the context point.\n    * @param  {number} x1 The X coordinate of the context point.\n    * @param  {number} y1 The Y coordinate of the context point.\n    * @param  {number} x2 The X coordinate of the end point.\n    * @param  {number} y2 The Y coordinate of the end point.\n    * @param  {number} cx The X coordinate of the first control point.\n    * @param  {number} cy The Y coordinate of the first control point.\n    * @param  {number} dx The X coordinate of the second control point.\n    * @param  {number} dy The Y coordinate of the second control point.\n    * @return {object}    {x,y} The point at t.\n  */\n  sigma.utils.getPointOnBezierCurve =\n    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {\n    // http://stackoverflow.com/a/15397596\n    // Blending functions:\n    var B0_t = Math.pow(1 - t, 3),\n        B1_t = 3 * t * Math.pow(1 - t, 2),\n        B2_t = 3 * Math.pow(t, 2) * (1 - t),\n        B3_t = Math.pow(t, 3);\n\n    return {\n      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),\n      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)\n    };\n  };\n\n  /**\n   * Return the coordinates of the two control points for a self loop (i.e.\n   * where the start point is also the end point) computed as a cubic bezier\n   * curve.\n   *\n   * @param  {number} x    The X coordinate of the node.\n   * @param  {number} y    The Y coordinate of the node.\n   * @param  {number} size The node size.\n   * @return {x1,y1,x2,y2} The coordinates of the two control points.\n   */\n  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {\n    return {\n      x1: x - size * 7,\n      y1: y,\n      x2: x,\n      y2: y + size * 7\n    };\n  };\n\n  /**\n   * Return the euclidian distance between two points of a plane\n   * with an orthonormal basis.\n   *\n   * @param  {number} x1  The X coordinate of the first point.\n   * @param  {number} y1  The Y coordinate of the first point.\n   * @param  {number} x2  The X coordinate of the second point.\n   * @param  {number} y2  The Y coordinate of the second point.\n   * @return {number}     The euclidian distance.\n   */\n  sigma.utils.getDistance = function(x0, y0, x1, y1) {\n    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  };\n\n  /**\n   * Return the coordinates of the intersection points of two circles.\n   *\n   * @param  {number} x0  The X coordinate of center location of the first\n   *                      circle.\n   * @param  {number} y0  The Y coordinate of center location of the first\n   *                      circle.\n   * @param  {number} r0  The radius of the first circle.\n   * @param  {number} x1  The X coordinate of center location of the second\n   *                      circle.\n   * @param  {number} y1  The Y coordinate of center location of the second\n   *                      circle.\n   * @param  {number} r1  The radius of the second circle.\n   * @return {xi,yi}      The coordinates of the intersection points.\n   */\n  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {\n    // http://stackoverflow.com/a/12219802\n    var a, dx, dy, d, h, rx, ry, x2, y2;\n\n    // dx and dy are the vertical and horizontal distances between the circle\n    // centers:\n    dx = x1 - x0;\n    dy = y1 - y0;\n\n    // Determine the straight-line distance between the centers:\n    d = Math.sqrt((dy * dy) + (dx * dx));\n\n    // Check for solvability:\n    if (d > (r0 + r1)) {\n        // No solution. circles do not intersect.\n        return false;\n    }\n    if (d < Math.abs(r0 - r1)) {\n        // No solution. one circle is contained in the other.\n        return false;\n    }\n\n    //'point 2' is the point where the line through the circle intersection\n    // points crosses the line between the circle centers.\n\n    // Determine the distance from point 0 to point 2:\n    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);\n\n    // Determine the coordinates of point 2:\n    x2 = x0 + (dx * a / d);\n    y2 = y0 + (dy * a / d);\n\n    // Determine the distance from point 2 to either of the intersection\n    // points:\n    h = Math.sqrt((r0 * r0) - (a * a));\n\n    // Determine the offsets of the intersection points from point 2:\n    rx = -dy * (h / d);\n    ry = dx * (h / d);\n\n    // Determine the absolute intersection points:\n    var xi = x2 + rx;\n    var xi_prime = x2 - rx;\n    var yi = y2 + ry;\n    var yi_prime = y2 - ry;\n\n    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};\n  };\n\n  /**\n    * Check if a point is on a line segment.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the line start point.\n    * @param  {number} y1      The Y coordinate of the line start point.\n    * @param  {number} x2      The X coordinate of the line end point.\n    * @param  {number} y2      The Y coordinate of the line end point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if point is \"close to\" the line\n    *                          segment, false otherwise.\n  */\n  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {\n    // http://stackoverflow.com/a/328122\n    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),\n        d = sigma.utils.getDistance(x1, y1, x2, y2),\n        nCrossProduct = crossProduct / d; // normalized cross product\n\n    return (nCrossProduct < epsilon &&\n     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&\n     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));\n  };\n\n  /**\n    * Check if a point is on a quadratic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx     The X coordinate of the curve control point.\n    * @param  {number} cpy     The Y coordinate of the curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnQuadraticCurve =\n    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);\n    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n    * Check if a point is on a cubic bezier curve segment with a thickness.\n    *\n    * @param  {number} x       The X coordinate of the point to check.\n    * @param  {number} y       The Y coordinate of the point to check.\n    * @param  {number} x1      The X coordinate of the curve start point.\n    * @param  {number} y1      The Y coordinate of the curve start point.\n    * @param  {number} x2      The X coordinate of the curve end point.\n    * @param  {number} y2      The Y coordinate of the curve end point.\n    * @param  {number} cpx1    The X coordinate of the 1st curve control point.\n    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.\n    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.\n    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.\n    * @param  {number} epsilon The precision (consider the line thickness).\n    * @return {boolean}        True if (x,y) is on the curve segment,\n    *                          false otherwise.\n  */\n  sigma.utils.isPointOnBezierCurve =\n    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {\n    // Fails if the point is too far from the extremities of the segment,\n    // preventing for more costly computation:\n    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);\n    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {\n      return false;\n    }\n\n    var dP1 = sigma.utils.getDistance(x, y, x1, y1),\n        dP2 = sigma.utils.getDistance(x, y, x2, y2),\n        t = 0.5,\n        r = (dP1 < dP2) ? -0.01 : 0.01,\n        rThreshold = 0.001,\n        i = 100,\n        pt = sigma.utils.getPointOnBezierCurve(\n          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),\n        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),\n        old_dt;\n\n    // This algorithm minimizes the distance from the point to the curve. It\n    // find the optimal t value where t=0 is the start point and t=1 is the end\n    // point of the curve, starting from t=0.5.\n    // It terminates because it runs a maximum of i interations.\n    while (i-- > 0 &&\n      t >= 0 && t <= 1 &&\n      (dt > epsilon) &&\n      (r > rThreshold || r < -rThreshold)) {\n      old_dt = dt;\n      pt = sigma.utils.getPointOnBezierCurve(\n        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);\n      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);\n\n      if (dt > old_dt) {\n        // not the right direction:\n        // halfstep in the opposite direction\n        r = -r / 2;\n        t += r;\n      }\n      else if (t + r < 0 || t + r > 1) {\n        // oops, we've gone too far:\n        // revert with a halfstep\n        r = r / 2;\n        dt = old_dt;\n      }\n      else {\n        // progress:\n        t += r;\n      }\n    }\n\n    return dt < epsilon;\n  };\n\n\n  /**\n   * ************\n   * EVENTS UTILS:\n   * ************\n   */\n  /**\n   * Here are some useful functions to unify extraction of the information we\n   * need with mouse events and touch events, from different browsers:\n   */\n\n  /**\n   * Extract the local X position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local X value of the mouse.\n   */\n  sigma.utils.getX = function(e) {\n    return (\n      (e.offsetX !== undefined && e.offsetX) ||\n      (e.layerX !== undefined && e.layerX) ||\n      (e.clientX !== undefined && e.clientX)\n    );\n  };\n\n  /**\n   * Extract the local Y position from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The local Y value of the mouse.\n   */\n  sigma.utils.getY = function(e) {\n    return (\n      (e.offsetY !== undefined && e.offsetY) ||\n      (e.layerY !== undefined && e.layerY) ||\n      (e.clientY !== undefined && e.clientY)\n    );\n  };\n\n  /**\n   * The pixel ratio of the screen. Taking zoom into account\n   *\n   * @return {number}        Pixel ratio of the screen\n   */\n  sigma.utils.getPixelRatio = function() {\n    var ratio = 1;\n    if (window.screen.deviceXDPI !== undefined &&\n         window.screen.logicalXDPI !== undefined &&\n         window.screen.deviceXDPI > window.screen.logicalXDPI) {\n        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;\n    }\n    else if (window.devicePixelRatio !== undefined) {\n        ratio = window.devicePixelRatio;\n    }\n    return ratio;\n  };\n\n  /**\n   * Extract the width from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The width of the event's target.\n   */\n  sigma.utils.getWidth = function(e) {\n    var w = (!e.target.ownerSVGElement) ?\n              e.target.width :\n              e.target.ownerSVGElement.width;\n\n    return (\n      (typeof w === 'number' && w) ||\n      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the center from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {object}   The center of the event's target.\n   */\n  sigma.utils.getCenter = function(e) {\n    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :\n        sigma.utils.getPixelRatio();\n    return {\n      x: sigma.utils.getWidth(e) / (2 * ratio),\n      y: sigma.utils.getHeight(e) / (2 * ratio)\n    };\n  };\n\n  /**\n   * Convert mouse coords to sigma coords\n   *\n   * @param  {event}   e A mouse or touch event.\n   * @param  {number?} x The x coord to convert\n   * @param  {number?} x The y coord to convert\n   *\n   * @return {object}    The standardized event\n   */\n  sigma.utils.mouseCoords = function(e, x, y) {\n    x = x || sigma.utils.getX(e);\n    y = y || sigma.utils.getY(e);\n    return {\n        x: x - sigma.utils.getCenter(e).x,\n        y: y - sigma.utils.getCenter(e).y,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey\n    };\n  };\n\n  /**\n   * Extract the height from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The height of the event's target.\n   */\n  sigma.utils.getHeight = function(e) {\n    var h = (!e.target.ownerSVGElement) ?\n              e.target.height :\n              e.target.ownerSVGElement.height;\n\n    return (\n      (typeof h === 'number' && h) ||\n      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)\n    );\n  };\n\n  /**\n   * Extract the wheel delta from a mouse or touch event.\n   *\n   * @param  {event}  e A mouse or touch event.\n   * @return {number}   The wheel delta of the mouse.\n   */\n  sigma.utils.getDelta = function(e) {\n    return (\n      (e.wheelDelta !== undefined && e.wheelDelta) ||\n      (e.detail !== undefined && -e.detail)\n    );\n  };\n\n  /**\n   * Returns the offset of a DOM element.\n   *\n   * @param  {DOMElement} dom The element to retrieve the position.\n   * @return {object}         The offset of the DOM element (top, left).\n   */\n  sigma.utils.getOffset = function(dom) {\n    var left = 0,\n        top = 0;\n\n    while (dom) {\n      top = top + parseInt(dom.offsetTop);\n      left = left + parseInt(dom.offsetLeft);\n      dom = dom.offsetParent;\n    }\n\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  /**\n   * Simulates a \"double click\" event.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   * @param  {function}    callback The callback to execute.\n   */\n  sigma.utils.doubleClick = function(target, type, callback) {\n    var clicks = 0,\n        self = this,\n        handlers;\n\n    target._doubleClickHandler = target._doubleClickHandler || {};\n    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];\n    handlers = target._doubleClickHandler[type];\n\n    handlers.push(function(e) {\n      clicks++;\n\n      if (clicks === 2) {\n        clicks = 0;\n        return callback(e);\n      } else if (clicks === 1) {\n        setTimeout(function() {\n          clicks = 0;\n        }, sigma.settings.doubleClickTimeout);\n      }\n    });\n\n    target.addEventListener(type, handlers[handlers.length - 1], false);\n  };\n\n  /**\n   * Unbind simulated \"double click\" events.\n   *\n   * @param  {HTMLElement} target   The event target.\n   * @param  {string}      type     The event type.\n   */\n  sigma.utils.unbindDoubleClick = function(target, type) {\n    var handler,\n        handlers = (target._doubleClickHandler || {})[type] || [];\n\n    while ((handler = handlers.pop())) {\n      target.removeEventListener(type, handler);\n    }\n\n    delete (target._doubleClickHandler || {})[type];\n  };\n\n\n\n\n  /**\n   * Here are just some of the most basic easing functions, used for the\n   * animated camera \"goTo\" calls.\n   *\n   * If you need some more easings functions, don't hesitate to add them to\n   * sigma.utils.easings. But I will not add some more here or merge PRs\n   * containing, because I do not want sigma sources full of overkill and never\n   * used stuff...\n   */\n  sigma.utils.easings = sigma.utils.easings || {};\n  sigma.utils.easings.linearNone = function(k) {\n    return k;\n  };\n  sigma.utils.easings.quadraticIn = function(k) {\n    return k * k;\n  };\n  sigma.utils.easings.quadraticOut = function(k) {\n    return k * (2 - k);\n  };\n  sigma.utils.easings.quadraticInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k;\n    return - 0.5 * (--k * (k - 2) - 1);\n  };\n  sigma.utils.easings.cubicIn = function(k) {\n    return k * k * k;\n  };\n  sigma.utils.easings.cubicOut = function(k) {\n    return --k * k * k + 1;\n  };\n  sigma.utils.easings.cubicInOut = function(k) {\n    if ((k *= 2) < 1)\n      return 0.5 * k * k * k;\n    return 0.5 * ((k -= 2) * k * k + 2);\n  };\n\n\n\n\n  /**\n   * ************\n   * WEBGL UTILS:\n   * ************\n   */\n  /**\n   * Loads a WebGL shader and returns it.\n   *\n   * @param  {WebGLContext}           gl           The WebGLContext to use.\n   * @param  {string}                 shaderSource The shader source.\n   * @param  {number}                 shaderType   The type of shader.\n   * @param  {function(string): void} error        Callback for errors.\n   * @return {WebGLShader}                         The created shader.\n   */\n  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {\n    var compiled,\n        shader = gl.createShader(shaderType);\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    // If something went wrong:\n    if (!compiled) {\n      if (error) {\n        error(\n          'Error compiling shader \"' + shader + '\":' +\n          gl.getShaderInfoLog(shader)\n        );\n      }\n\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  };\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.\n   * @param  {Array.<string>}         attribs   The attribs names.\n   * @param  {Array.<number>}         locations The locations for the attribs.\n   * @param  {function(string): void} error     Callback for errors.\n   * @return {WebGLProgram}                     The created program.\n   */\n  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {\n    var i,\n        linked,\n        program = gl.createProgram();\n\n    for (i = 0; i < shaders.length; ++i)\n      gl.attachShader(program, shaders[i]);\n\n    if (attribs)\n      for (i = 0; i < attribs.length; ++i)\n        gl.bindAttribLocation(\n          program,\n          locations ? locations[i] : i,\n          opt_attribs[i]\n        );\n\n    gl.linkProgram(program);\n\n    // Check the link status\n    linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n      if (error)\n        error('Error in program linking: ' + gl.getProgramInfoLog(program));\n\n      gl.deleteProgram(program);\n      return null;\n    }\n\n    return program;\n  };\n\n\n\n\n  /**\n   * *********\n   * MATRICES:\n   * *********\n   * The following utils are just here to help generating the transformation\n   * matrices for the WebGL renderers.\n   */\n  sigma.utils.pkg('sigma.utils.matrices');\n\n  /**\n   * The returns a 3x3 translation matrix.\n   *\n   * @param  {number} dx The X translation.\n   * @param  {number} dy The Y translation.\n   * @return {array}     Returns the matrix.\n   */\n  sigma.utils.matrices.translation = function(dx, dy) {\n    return [\n      1, 0, 0,\n      0, 1, 0,\n      dx, dy, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 rotation matrix.\n   *\n   * @param  {number}  angle The rotation angle.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.rotation = function(angle, m2) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle);\n\n    return m2 ? [\n      cos, -sin,\n      sin, cos\n    ] : [\n      cos, -sin, 0,\n      sin, cos, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {number}  ratio The scaling ratio.\n   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.\n   * @return {array}         Returns the matrix.\n   */\n  sigma.utils.matrices.scale = function(ratio, m2) {\n    return m2 ? [\n      ratio, 0,\n      0, ratio\n    ] : [\n      ratio, 0, 0,\n      0, ratio, 0,\n      0, 0, 1\n    ];\n  };\n\n  /**\n   * The returns a 3x3 or 2x2 homothetic transformation matrix.\n   *\n   * @param  {array}   a  The first matrix.\n   * @param  {array}   b  The second matrix.\n   * @param  {boolean} m2 If true, the function will assume both matrices are\n   *                      2x2.\n   * @return {array}      Returns the matrix.\n   */\n  sigma.utils.matrices.multiply = function(a, b, m2) {\n    var l = m2 ? 2 : 3,\n        a00 = a[0 * l + 0],\n        a01 = a[0 * l + 1],\n        a02 = a[0 * l + 2],\n        a10 = a[1 * l + 0],\n        a11 = a[1 * l + 1],\n        a12 = a[1 * l + 2],\n        a20 = a[2 * l + 0],\n        a21 = a[2 * l + 1],\n        a22 = a[2 * l + 2],\n        b00 = b[0 * l + 0],\n        b01 = b[0 * l + 1],\n        b02 = b[0 * l + 2],\n        b10 = b[1 * l + 0],\n        b11 = b[1 * l + 1],\n        b12 = b[1 * l + 2],\n        b20 = b[2 * l + 0],\n        b21 = b[2 * l + 1],\n        b22 = b[2 * l + 2];\n\n    return m2 ? [\n      a00 * b00 + a01 * b10,\n      a00 * b01 + a01 * b11,\n      a10 * b00 + a11 * b10,\n      a10 * b01 + a11 * b11\n    ] : [\n      a00 * b00 + a01 * b10 + a02 * b20,\n      a00 * b01 + a01 * b11 + a02 * b21,\n      a00 * b02 + a01 * b12 + a02 * b22,\n      a10 * b00 + a11 * b10 + a12 * b20,\n      a10 * b01 + a11 * b11 + a12 * b21,\n      a10 * b02 + a11 * b12 + a12 * b22,\n      a20 * b00 + a21 * b10 + a22 * b20,\n      a20 * b01 + a21 * b11 + a22 * b21,\n      a20 * b02 + a21 * b12 + a22 * b22\n    ];\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n/* 80 */,\n/* 81 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_sigma_core_js__ = __webpack_require__(76);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_sigma_core_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sigma_react_src_sigma_core_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_conrad_js__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_conrad_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sigma_react_src_conrad_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_utils_sigma_utils_js__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_utils_sigma_utils_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_sigma_react_src_utils_sigma_utils_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_utils_sigma_polyfills_js__ = __webpack_require__(78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_utils_sigma_polyfills_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_sigma_react_src_utils_sigma_polyfills_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_sigma_settings_js__ = __webpack_require__(77);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_sigma_settings_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_sigma_react_src_sigma_settings_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_classes_sigma_classes_dispatcher_js__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_classes_sigma_classes_dispatcher_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_sigma_react_src_classes_sigma_classes_dispatcher_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_src_classes_sigma_classes_configurable_js__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_src_classes_sigma_classes_configurable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_sigma_react_src_classes_sigma_classes_configurable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_sigma_react_src_classes_sigma_classes_graph_js__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_sigma_react_src_classes_sigma_classes_graph_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_sigma_react_src_classes_sigma_classes_graph_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_sigma_react_src_classes_sigma_classes_camera_js__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_sigma_react_src_classes_sigma_classes_camera_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_sigma_react_src_classes_sigma_classes_camera_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_sigma_react_src_classes_sigma_classes_quad_js__ = __webpack_require__(41);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_sigma_react_src_classes_sigma_classes_quad_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_sigma_react_src_classes_sigma_classes_quad_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_sigma_react_src_classes_sigma_classes_edgequad_js__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_sigma_react_src_classes_sigma_classes_edgequad_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_sigma_react_src_classes_sigma_classes_edgequad_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_sigma_react_src_captors_sigma_captors_mouse_js__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_sigma_react_src_captors_sigma_captors_mouse_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_sigma_react_src_captors_sigma_captors_mouse_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_sigma_react_src_captors_sigma_captors_touch_js__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_sigma_react_src_captors_sigma_captors_touch_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_sigma_react_src_captors_sigma_captors_touch_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_sigma_react_src_renderers_sigma_renderers_canvas_js__ = __webpack_require__(61);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_sigma_react_src_renderers_sigma_renderers_canvas_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_sigma_react_src_renderers_sigma_renderers_canvas_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_sigma_react_src_renderers_canvas_sigma_canvas_labels_def_js__ = __webpack_require__(59);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_sigma_react_src_renderers_canvas_sigma_canvas_labels_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_sigma_react_src_renderers_canvas_sigma_canvas_labels_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_sigma_react_src_renderers_canvas_sigma_canvas_hovers_def_js__ = __webpack_require__(58);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_sigma_react_src_renderers_canvas_sigma_canvas_hovers_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_sigma_react_src_renderers_canvas_sigma_canvas_hovers_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_sigma_react_src_renderers_canvas_sigma_canvas_nodes_def_js__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_sigma_react_src_renderers_canvas_sigma_canvas_nodes_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_16_sigma_react_src_renderers_canvas_sigma_canvas_nodes_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_sigma_react_src_renderers_canvas_sigma_canvas_edges_def_js__ = __webpack_require__(56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_sigma_react_src_renderers_canvas_sigma_canvas_edges_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_17_sigma_react_src_renderers_canvas_sigma_canvas_edges_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_def_js__ = __webpack_require__(52);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_18_sigma_react_src_renderers_canvas_sigma_canvas_edgehovers_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_sigma_react_src_renderers_canvas_sigma_canvas_extremities_def_js__ = __webpack_require__(57);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_sigma_react_src_renderers_canvas_sigma_canvas_extremities_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_19_sigma_react_src_renderers_canvas_sigma_canvas_extremities_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_sigma_react_src_middlewares_sigma_middlewares_rescale_js__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_sigma_react_src_middlewares_sigma_middlewares_rescale_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_20_sigma_react_src_middlewares_sigma_middlewares_rescale_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_sigma_react_src_middlewares_sigma_middlewares_copy_js__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_sigma_react_src_middlewares_sigma_middlewares_copy_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_21_sigma_react_src_middlewares_sigma_middlewares_copy_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_sigma_react_src_misc_sigma_misc_animation_js__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_sigma_react_src_misc_sigma_misc_animation_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_22_sigma_react_src_misc_sigma_misc_animation_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_sigma_react_src_misc_sigma_misc_bindEvents_js__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_sigma_react_src_misc_sigma_misc_bindEvents_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_23_sigma_react_src_misc_sigma_misc_bindEvents_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_sigma_react_src_misc_sigma_misc_bindDOMEvents_js__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_sigma_react_src_misc_sigma_misc_bindDOMEvents_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_24_sigma_react_src_misc_sigma_misc_bindDOMEvents_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_sigma_react_src_misc_sigma_misc_drawHovers_js__ = __webpack_require__(48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_sigma_react_src_misc_sigma_misc_drawHovers_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_25_sigma_react_src_misc_sigma_misc_drawHovers_js__);\n// Sigma build is quite big and not friendly for webpack, therefore we use custom import\n\n// Core:\n\n\n// Utils:\n\n\n\n\n// Main classes:\n\n\n\n\n\n\n\n\n// Captors:\n\n\n\n// Renderers:\n\n\n// Sub functions per engine:\n\n\n\n\n\n\n\n// Middlewares:\n\n\n\n// Miscellaneous:\n\n\n\n\n\nvar sigma = window.sigma;\n\n// By default we exclude WbGL renderer from the Sigma component.\n// WebGL has to be imported explicitly via <SigmaEnableWebGL /> in the global context.\nsigma.renderers.def = sigma.renderers.canvas;\n\n// We do not support svg at all to reduce package size\n//    'src/renderers/sigma.renderers.svg.js',\n//    'src/renderers/svg/sigma.svg.utils.js',\n//    'src/renderers/svg/sigma.svg.nodes.def.js',\n//    'src/renderers/svg/sigma.svg.edges.def.js',\n//    'src/renderers/svg/sigma.svg.edges.curve.js',\n//    'src/renderers/svg/sigma.svg.labels.def.js',\n//    'src/renderers/svg/sigma.svg.hovers.def.js',\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sigma);\n\n/***/ })\n/******/ ]));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/main.js\n// module id = ./node_modules/react-sigma/sigma/main.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 127);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 127:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function (undefined) {\n    'use strict';\n\n    if (typeof sigma === 'undefined')\n        throw 'sigma is not declared';\n\n    // Declare neo4j package\n    sigma.utils.pkg(\"sigma.neo4j\");\n\n    // Initialize package:\n    sigma.utils.pkg('sigma.utils');\n\n\n    /**\n     * This function is an helper for the neo4j communication.\n     *\n     * @param   {string|object}     neo4j       The URL of neo4j server or a neo4j server object.\n     * @param   {string}            endpoint    Endpoint of the neo4j server\n     * @param   {string}            method      The calling method for the endpoint : 'GET' or 'POST'\n     * @param   {object|string}     data        Data that will be send to the server\n     * @param   {function}          callback    The callback function\n     */\n    sigma.neo4j.send = function(neo4j, endpoint, method, data, callback) {\n        var xhr = sigma.utils.xhr(),\n            url, user, password;\n\n        // if neo4j arg is not an object\n        url = neo4j;\n        if(typeof neo4j === 'object') {\n            url = neo4j.url;\n            user = neo4j.user;\n            password = neo4j.password;\n        }\n\n        if (!xhr)\n            throw 'XMLHttpRequest not supported, cannot load the file.';\n\n        // Construct the endpoint url\n        url += endpoint;\n\n        xhr.open(method, url, true);\n        if( user && password) {\n            xhr.setRequestHeader('Authorization', 'Basic ' + btoa(user + ':' + password));\n        }\n        xhr.setRequestHeader('Accept', 'application/json');\n        xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                // Call the callback if specified:\n                callback(JSON.parse(xhr.responseText));\n            }\n        };\n        xhr.send(data);\n    };\n\n    /**\n     * This function parse a neo4j cypher query result, and transform it into\n     * a sigma graph object.\n     *\n     * @param  {object}     result      The server response of a cypher query.\n     *\n     * @return A graph object\n     */\n    sigma.neo4j.cypher_parse = function(result, producers) {\n        var graph = { nodes: [], edges: [] },\n            nodesMap = {},\n            edgesMap = {},\n            key;\n\n        // Iteration on all result data\n        result.results[0].data.forEach(function (data) {\n\n            // iteration on graph for all node\n            data.graph.nodes.forEach(function (node) {\n\n                var sigmaNode = producers.node(node);\n\n                if (sigmaNode.id in nodesMap) {\n                    // do nothing\n                } else {\n                    nodesMap[sigmaNode.id] = sigmaNode;\n                }\n            });\n\n            // iteration on graph for all edges\n            data.graph.relationships.forEach(function (edge) {\n\n                var sigmaEdge = producers.edge(edge);\n\n                if (sigmaEdge.id in edgesMap) {\n                    // do nothing\n                } else {\n                    edgesMap[sigmaEdge.id] = sigmaEdge;\n                }\n            });\n\n        });\n\n        // construct sigma nodes\n        for (key in nodesMap) {\n            graph.nodes.push(nodesMap[key]);\n        }\n        // construct sigma nodes\n        for (key in edgesMap) {\n            graph.edges.push(edgesMap[key]);\n        }\n\n        return graph;\n    };\n\n\n    /**\n     * This function execute a cypher and create a new sigma instance or\n     * updates the graph of a given instance. It is possible to give a callback\n     * that will be executed at the end of the process.\n     *\n     * @param  {object|string}      neo4j       The URL of neo4j server or a neo4j server object.\n     * @param  {string}             cypher      The cypher query\n     * @param  {?object|?sigma}     sig         A sigma configuration object or a sigma instance.\n     * @param  {?function}          callback    Eventually a callback to execute after\n     *                                          having parsed the file. It will be called\n     *                                          with the related sigma instance as\n     *                                          parameter.\n     * @param  {?object}            producers   Factory object with node and/or edge producers functions\n     *                                          By default sigma.neo4j produces black nodes and gray edges.\n     *                                          producers.node(node) takes neo4j node as input,\n     *                                          should output sigma node properties\n     *                                          producers.edge(edge) takes neo4j node as input,\n     *                                          should output sigma edge properties\n     */\n    sigma.neo4j.cypher = function (neo4j, cypher, sig, callback, producers) {\n        var endpoint = '/db/data/transaction/commit',\n            data, cypherCallback;\n\n        if(!producers) producers = sigma.neo4j.defaultProducers;\n\n        // Data that will be send to the server\n        data = JSON.stringify({\n            \"statements\": [\n                {\n                    \"statement\": cypher,\n                    \"resultDataContents\": [\"graph\"],\n                    \"includeStats\": false\n                }\n            ]\n        });\n\n        // Callback method after server response\n        cypherCallback = function (callback) {\n\n            return function (response) {\n\n                var graph = { nodes: [], edges: [] };\n\n                graph = sigma.neo4j.cypher_parse(response, producers);\n\n                // Update the instance's graph:\n                if (sig instanceof sigma) {\n                    sig.graph.clear();\n                    sig.graph.read(graph);\n\n                    // ...or instantiate sigma if needed:\n                } else if (typeof sig === 'object') {\n                    sig = new sigma(sig);\n                    sig.graph.read(graph);\n                    sig.refresh();\n\n                    // ...or it's finally the callback:\n                } else if (typeof sig === 'function') {\n                    callback = sig;\n                    sig = null;\n                }\n\n                // Call the callback if specified:\n                if (callback)\n                    callback(sig || graph);\n            };\n        };\n\n        // Let's call neo4j\n        sigma.neo4j.send(neo4j, endpoint, 'POST', data, cypherCallback(callback));\n    };\n\n    /**\n     * This function call neo4j to get all labels of the graph.\n     *\n     * @param  {string}       neo4j      The URL of neo4j server or an object with the url, user & password.\n     * @param  {function}     callback   The callback function\n     *\n     * @return An array of label\n     */\n    sigma.neo4j.getLabels = function(neo4j, callback) {\n        sigma.neo4j.send(neo4j, '/db/data/labels', 'GET', null, callback);\n    };\n\n    /**\n     * This function parse a neo4j cypher query result.\n     *\n     * @param  {string}       neo4j      The URL of neo4j server or an object with the url, user & password.\n     * @param  {function}     callback   The callback function\n     *\n     * @return An array of relationship type\n     */\n    sigma.neo4j.getTypes = function(neo4j, callback) {\n        sigma.neo4j.send(neo4j, '/db/data/relationship/types', 'GET', null, callback);\n    };\n\n    /**\n     * This object consist of sigma node and endge producers based on neo4j data node.\n     *\n     * @param  {object}       node   node(neo4j_node): sigma_node, where  neo4j_node = {id, label, properties}\n     * @param  {object}       edge   edge(neo4j_edge): sigma_edge, where  neo4j_edge = {id, type, startNode, endNode, properties}\n     *\n     * @return Sigma data object for node or edge\n     */\n    sigma.neo4j.defaultProducers = {\n        node: function(node) {\n            return {\n                id : node.id,\n                label : node.id,\n                x : Math.random(),\n                y : Math.random(),\n                size : 1,\n                color : '#666666',\n                neo4j_labels : node.labels,\n                neo4j_data : node.properties\n            }\n        },\n        edge: function(edge) {\n            return {\n                id : edge.id,\n                label : edge.type,\n                source : edge.startNode,\n                target : edge.endNode,\n                color : '#7D7C8E',\n                neo4j_type : edge.type,\n                neo4j_data : edge.properties\n            }\n        }\n    }\n\n}).call(window);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/neo4j.cypher.js\n// module id = ./node_modules/react-sigma/sigma/neo4j.cypher.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 82);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 29:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  var shapes = [];\n  var register = function(name,drawShape,drawBorder) {\n    shapes.push({\n      'name': name,\n      'drawShape': drawShape,\n      'drawBorder': drawBorder\n    });\n  }\n\n  var enumerateShapes = function() {\n    return shapes;\n  }\n\n  /**\n   * For the standard closed shapes - the shape fill and border are drawn the\n   * same, with some minor differences for fill and border. To facilitate this we\n   * create the generic draw functions, that take a shape drawing func and\n   * return a shape-renderer/border-renderer\n   * ----------\n   */\n  var genericDrawShape = function(shapeFunc) {\n    return function(node,x,y,size,color,context) {\n      context.fillStyle = color;\n      context.beginPath();\n      shapeFunc(node,x,y,size,context);\n      context.closePath();\n      context.fill();\n    };\n  }\n\n  var genericDrawBorder = function(shapeFunc) {\n    return function(node,x,y,size,color,context) {\n      context.strokeStyle = color;\n      context.lineWidth = size / 5;\n      context.beginPath();\n      shapeFunc(node,x,y,size,context);\n      context.closePath();\n      context.stroke();\n    };\n  }\n\n  /**\n   * We now proced to use the generics to define our standard shape/border\n   * drawers: square, diamond, equilateral (polygon), and star\n   * ----------\n   */\n  var drawSquare = function(node,x,y,size,context) {\n    var rotate = Math.PI*45/180; // 45 deg rotation of a diamond shape\n    context.moveTo(x+size*Math.sin(rotate), y-size*Math.cos(rotate)); // first point on outer radius, dwangle 'rotate'\n    for(var i=1; i<4; i++) {\n      context.lineTo(x+Math.sin(rotate+2*Math.PI*i/4)*size, y-Math.cos(rotate+2*Math.PI*i/4)*size);\n    }\n  }\n  register(\"square\",genericDrawShape(drawSquare),genericDrawBorder(drawSquare));\n\n  var drawCircle = function(node,x,y,size,context) {\n    context.arc(x,y,size,0,Math.PI*2,true);\n  }\n  register(\"circle\",genericDrawShape(drawCircle),genericDrawBorder(drawCircle));\n\n  var drawDiamond = function(node,x,y,size,context) {\n    context.moveTo(x-size, y);\n    context.lineTo(x, y-size);\n    context.lineTo(x+size, y);\n    context.lineTo(x, y+size);\n  }\n  register(\"diamond\",genericDrawShape(drawDiamond),genericDrawBorder(drawDiamond));\n\n  var drawCross = function(node,x,y,size,context) {\n    var lineWeight = (node.cross && node.cross.lineWeight) || 5;\n    context.moveTo(x-size, y-lineWeight);\n    context.lineTo(x-size, y+lineWeight);\n    context.lineTo(x-lineWeight, y+lineWeight);\n    context.lineTo(x-lineWeight, y+size);\n    context.lineTo(x+lineWeight, y+size);\n    context.lineTo(x+lineWeight, y+lineWeight);\n    context.lineTo(x+size, y+lineWeight);\n    context.lineTo(x+size, y-lineWeight);\n    context.lineTo(x+lineWeight, y-lineWeight);\n    context.lineTo(x+lineWeight, y-size);\n    context.lineTo(x-lineWeight, y-size);\n    context.lineTo(x-lineWeight, y-lineWeight);\n  }\n  register(\"cross\",genericDrawShape(drawCross),genericDrawBorder(drawCross));\n\n  var drawEquilateral = function(node,x,y,size,context) {\n    var pcount = (node.equilateral && node.equilateral.numPoints) || 5;\n    var rotate = ((node.equilateral && node.equilateral.rotate) || 0)*Math.PI/180;\n    var radius = size;\n    context.moveTo(x+radius*Math.sin(rotate), y-radius*Math.cos(rotate)); // first point on outer radius, angle 'rotate'\n    for(var i=1; i<pcount; i++) {\n      context.lineTo(x+Math.sin(rotate+2*Math.PI*i/pcount)*radius, y-Math.cos(rotate+2*Math.PI*i/pcount)*radius);\n    }\n  }\n  register(\"equilateral\",genericDrawShape(drawEquilateral),genericDrawBorder(drawEquilateral));\n\n\n  var starShape = function(node,x,y,size,context) {\n    var pcount = (node.star && node.star.numPoints) || 5,\n        inRatio = (node.star && node.star.innerRatio) || 0.5,\n        outR = size,\n        inR = size*inRatio,\n        angleOffset = Math.PI/pcount;\n    context.moveTo(x, y-size); // first point on outer radius, top\n    for(var i=0; i<pcount; i++) {\n      context.lineTo(x+Math.sin(angleOffset+2*Math.PI*i/pcount)*inR,\n          y-Math.cos(angleOffset+2*Math.PI*i/pcount)*inR);\n      context.lineTo(x+Math.sin(2*Math.PI*(i+1)/pcount)*outR,\n          y-Math.cos(2*Math.PI*(i+1)/pcount)*outR);\n    }\n  }\n  register(\"star\",genericDrawShape(starShape),genericDrawBorder(starShape));\n\n  /**\n   * An example of a non standard shape (pacman). Here we WILL NOT use the\n   * genericDraw functions, but rather register a full custom node renderer for\n   * fill, and skip the border renderer which is irrelevant for this shape\n   * ----------\n   */\n  var drawPacman = function(node,x,y,size,color,context) {\n    context.fillStyle = 'yellow';\n    context.beginPath();\n    context.arc(x,y,size,1.25*Math.PI,0,false);\n    context.arc(x,y,size,0,0.75*Math.PI,false);\n    context.lineTo(x,y);\n    context.closePath();\n    context.fill();\n\n    context.fillStyle = 'white';\n    context.strokeStyle = 'black';\n    context.beginPath();\n    context.arc(x+size/3,y-size/3,size/4,0,2*Math.PI,false);\n    context.closePath();\n    context.fill();\n    context.stroke();\n\n    context.fillStyle = 'black';\n    context.beginPath();\n    context.arc(x+4*size/9,y-size/3,size/8,0,2*Math.PI,false);\n    context.closePath();\n    context.fill();\n  }\n  register(\"pacman\",drawPacman,null);\n\n  /**\n   * Exporting\n   * ----------\n   */\n  this.ShapeLibrary = {\n\n    // Functions\n    enumerate: enumerateShapes,\n    // add: addShape,\n\n    // Version\n    version: '0.1'\n  };\n\n}).call(window);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 30:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof ShapeLibrary === 'undefined')\n    throw 'ShapeLibrary is not declared';\n\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.canvas.nodes');\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  var sigInst = undefined;\n  var imgCache = {};\n\n  var initPlugin = function(inst) {\n    sigInst = inst;\n  }\n\n  var drawImage = function (node,x,y,size,context) {\n    if(sigInst && node.image && node.image.url) {\n      var url = node.image.url;\n      var ih = node.image.h || 1; // 1 is arbitrary, anyway only the ratio counts\n      var iw = node.image.w || 1;\n      var scale = node.image.scale || 1;\n      var clip = node.image.clip || 1;\n\n      // create new IMG or get from imgCache\n      var image = imgCache[url];\n      if(!image) {\n        image = document.createElement('IMG');\n        image.src = url;\n        image.status = 'loading';\n        image.onerror = function() {\n          console.log(\"error loading\", url);\n          image.status = 'error';\n        };\n        image.onload = function(){\n          // TODO see how we redraw on load\n          // need to provide the siginst as a parameter to the library\n          console.log(\"redraw on image load\", url);\n          image.status = 'ok';\n          sigInst.refresh();\n        };\n        imgCache[url] = image;\n      }\n\n      // calculate position and draw\n      var xratio = (iw<ih) ? (iw/ih) : 1;\n      var yratio = (ih<iw) ? (ih/iw) : 1;\n      var r = size*scale;\n\n      // Draw the clipping disc:\n      context.save(); // enter clipping mode\n      context.beginPath();\n      context.arc(x,y,size*clip,0,Math.PI*2,true);\n      context.closePath();\n      context.clip();\n\n      if(image.status === 'ok') {\n        // Draw the actual image\n        context.drawImage(image,\n            x+Math.sin(-3.142/4)*r*xratio,\n            y-Math.cos(-3.142/4)*r*yratio,\n            r*xratio*2*Math.sin(-3.142/4)*(-1),\n            r*yratio*2*Math.cos(-3.142/4));\n      }\n      context.restore(); // exit clipping mode\n    }\n  }\n\n  var drawSVGImage = function (node, group, settings) {\n    if(sigInst && node.image && node.image.url) {\n      var clipCircle = document.createElementNS(settings('xmlns'), 'circle'),\n        clipPath = document.createElementNS(settings('xmlns'), 'clipPath'),\n        clipPathId = settings('classPrefix') + '-clip-path-' + node.id,\n        def = document.createElementNS(settings('xmlns'), 'defs'),\n        image = document.createElementNS(settings('xmlns'), 'image'),\n        url = node.image.url;\n\n      clipPath.setAttributeNS(null, 'id', clipPathId);\n      clipPath.appendChild(clipCircle);\n      def.appendChild(clipPath);\n\n      // angular's base tag will change the relative fragment id, so\n      // #<clipPathId> doesn't work\n      // HACKHACK: IE <=9 does not respect the HTML base element in SVG.\n      // They don't need the current URL in the clip path reference.\n      var absolutePath = /MSIE [5-9]/.test(navigator.userAgent) ?\n        \"\" : document.location.href;\n      // To fix cases where an anchor tag was used\n      absolutePath = absolutePath.split(\"#\")[0];\n      image.setAttributeNS(null, 'class',\n        settings('classPrefix') + '-node-image');\n      image.setAttributeNS(null, 'clip-path',\n        'url(' + absolutePath + '#' + clipPathId + ')');\n      image.setAttributeNS(null, 'pointer-events', 'none');\n      image.setAttributeNS('http://www.w3.org/1999/xlink', 'href',\n        node.image.url);\n      group.appendChild(def);\n      group.appendChild(image);\n    }\n  }\n\n  var register = function(name,drawShape,drawBorder) {\n    sigma.canvas.nodes[name] = function(node, context, settings) {\n      var args = arguments,\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          color = node.color || settings('defaultNodeColor'),\n          borderColor = node.borderColor || color,\n          x = node[prefix + 'x'],\n          y = node[prefix + 'y'];\n\n      context.save();\n\n      if(drawShape) {\n        drawShape(node,x,y,size,color,context);\n      }\n\n      if(drawBorder) {\n        drawBorder(node,x,y,size,borderColor,context);\n      }\n\n      drawImage(node,x,y,size,context);\n\n      context.restore();\n    };\n\n    sigma.svg.nodes[name] = {\n      create: function(node, settings) {\n        var group = document.createElementNS(settings('xmlns'), 'g'),\n        circle = document.createElementNS(settings('xmlns'), 'circle');\n\n        group.setAttributeNS(null, 'class',\n          settings('classPrefix') + '-node-group');\n        group.setAttributeNS(null, 'data-node-id', node.id);\n        // Defining the node's circle\n        circle.setAttributeNS(null, 'data-node-id', node.id);\n        circle.setAttributeNS(null, 'class',\n          settings('classPrefix') + '-node');\n        circle.setAttributeNS(null, 'fill',\n          node.color || settings('defaultNodeColor'));\n\n        group.appendChild(circle);\n        drawSVGImage(node, group, settings);\n        return group;\n      },\n      update: function(node, group, settings) {\n        var classPrefix = settings('classPrefix'),\n          clip = node.image.clip || 1,\n          // 1 is arbitrary, anyway only the ratio counts\n          ih = node.image.h || 1,\n          iw = node.image.w || 1,\n          prefix = settings('prefix') || '',\n          scale = node.image.scale || 1,\n          size = node[prefix + 'size'],\n          x = node[prefix + 'x'],\n          y = node[prefix + 'y'];\n\n          var r = scale * size,\n          xratio = (iw<ih) ? (iw/ih) : 1,\n          yratio = (ih<iw) ? (ih/iw) : 1;\n\n        for(var i = 0, childNodes = group.childNodes; i < childNodes.length; i ++) {\n          var className = childNodes[i].getAttribute('class');\n\n          switch (className) {\n            case classPrefix + '-node':\n              childNodes[i].setAttributeNS(null, 'cx', x);\n              childNodes[i].setAttributeNS(null, 'cy', y);\n              childNodes[i].setAttributeNS(null, 'r', size);\n\n              // // Updating only if not freestyle\n              if (!settings('freeStyle')) {\n                childNodes[i].setAttributeNS(\n                  null,\n                  'fill',\n                  node.color || settings('defaultNodeColor'));\n              }\n              break;\n            case classPrefix + '-node-image':\n              childNodes[i].setAttributeNS(null, 'x',\n                x+Math.sin(-3.142/4)*r*xratio);\n              childNodes[i].setAttributeNS(null, 'y',\n                y-Math.cos(-3.142/4)*r*yratio);\n              childNodes[i].setAttributeNS(null, 'width',\n                r*xratio*2*Math.sin(-3.142/4)*(-1));\n              childNodes[i].setAttributeNS(null, 'height',\n                r*yratio*2*Math.cos(-3.142/4));\n              break;\n            default:\n              // no class name, must be the clip-path\n              var clipPath = childNodes[i].firstChild;\n              if (clipPath != null) {\n                var clipPathId = classPrefix + '-clip-path-' + node.id;\n                if (clipPath.getAttribute('id') === clipPathId) {\n                  clipPath.firstChild.setAttributeNS(null, 'cx', x);\n                  clipPath.firstChild.setAttributeNS(null, 'cy', y);\n                  clipPath.firstChild.setAttributeNS(null, 'r',\n                    clip * size);\n                }\n              }\n              break;\n          }\n        }\n\n        // showing\n        group.style.display = '';\n      }\n    }\n  }\n\n  ShapeLibrary.enumerate().forEach(function(shape) {\n    register(shape.name,shape.drawShape,shape.drawBorder);\n  });\n\n  /**\n   * Exporting\n   * ----------\n   */\n  this.CustomShapes = {\n\n    // Functions\n    init: initPlugin,\n    // add pre-cache images\n\n    // Version\n    version: '0.1'\n  };\n\n\n\n}).call(window);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 82:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_plugins_sigma_renderers_customShapes_shape_library_js__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_plugins_sigma_renderers_customShapes_shape_library_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sigma_react_plugins_sigma_renderers_customShapes_shape_library_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_plugins_sigma_renderers_customShapes_sigma_renderers_customShapes_js__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_plugins_sigma_renderers_customShapes_sigma_renderers_customShapes_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sigma_react_plugins_sigma_renderers_customShapes_sigma_renderers_customShapes_js__);\n\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/nodes.js\n// module id = ./node_modules/react-sigma/sigma/nodes.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 136);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 136:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(19);\nmodule.exports = __webpack_require__(20);\n\n\n/***/ }),\n\n/***/ 19:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  /**\n   * GEXF Library\n   * =============\n   *\n   * Author: PLIQUE Guillaume (Yomguithereal)\n   * URL: https://github.com/Yomguithereal/gexf-parser\n   * Version: 0.1.1\n   */\n\n  /**\n   * Helper Namespace\n   * -----------------\n   *\n   * A useful batch of function dealing with DOM operations and types.\n   */\n  var _helpers = {\n    getModelTags: function(xml) {\n      var attributesTags = xml.getElementsByTagName('attributes'),\n          modelTags = {},\n          l = attributesTags.length,\n          i;\n\n      for (i = 0; i < l; i++)\n        modelTags[attributesTags[i].getAttribute('class')] =\n          attributesTags[i].childNodes;\n\n      return modelTags;\n    },\n    nodeListToArray: function(nodeList) {\n\n      // Return array\n      var children = [];\n\n      // Iterating\n      for (var i = 0, len = nodeList.length; i < len; ++i) {\n        if (nodeList[i].nodeName !== '#text')\n          children.push(nodeList[i]);\n      }\n\n      return children;\n    },\n    nodeListEach: function(nodeList, func) {\n\n      // Iterating\n      for (var i = 0, len = nodeList.length; i < len; ++i) {\n        if (nodeList[i].nodeName !== '#text')\n          func(nodeList[i]);\n      }\n    },\n    nodeListToHash: function(nodeList, filter) {\n\n      // Return object\n      var children = {};\n\n      // Iterating\n      for (var i = 0; i < nodeList.length; i++) {\n        if (nodeList[i].nodeName !== '#text') {\n          var prop = filter(nodeList[i]);\n          children[prop.key] = prop.value;\n        }\n      }\n\n      return children;\n    },\n    namedNodeMapToObject: function(nodeMap) {\n\n      // Return object\n      var attributes = {};\n\n      // Iterating\n      for (var i = 0; i < nodeMap.length; i++) {\n        attributes[nodeMap[i].name] = nodeMap[i].value;\n      }\n\n      return attributes;\n    },\n    getFirstElementByTagNS: function(node, ns, tag) {\n      var el = node.getElementsByTagName(ns + ':' + tag)[0];\n\n      if (!el)\n        el = node.getElementsByTagNameNS(ns, tag)[0];\n\n      if (!el)\n        el = node.getElementsByTagName(tag)[0];\n\n      return el;\n    },\n    getAttributeNS: function(node, ns, attribute) {\n      var attr_value = node.getAttribute(ns + ':' + attribute);\n\n      if (attr_value === undefined)\n        attr_value = node.getAttributeNS(ns, attribute);\n\n      if (attr_value === undefined)\n        attr_value = node.getAttribute(attribute);\n\n      return attr_value;\n    },\n    enforceType: function(type, value) {\n\n      switch (type) {\n        case 'boolean':\n          value = (value === 'true');\n          break;\n\n        case 'integer':\n        case 'long':\n        case 'float':\n        case 'double':\n          value = +value;\n          break;\n\n        case 'liststring':\n          value = value ? value.split('|') : [];\n          break;\n      }\n\n      return value;\n    },\n    getRGB: function(values) {\n      return (values[3]) ?\n        'rgba(' + values.join(',') + ')' :\n        'rgb(' + values.slice(0, -1).join(',') + ')';\n    }\n  };\n\n\n  /**\n   * Parser Core Functions\n   * ----------------------\n   *\n   * The XML parser's functions themselves.\n   */\n\n  /**\n   * Node structure.\n   * A function returning an object guarded with default value.\n   *\n   * @param  {object} properties The node properties.\n   * @return {object}            The guarded node object.\n   */\n  function Node(properties) {\n\n    // Possible Properties\n    var node = {\n      id: properties.id,\n      label: properties.label\n    };\n\n    if (properties.viz)\n      node.viz = properties.viz;\n\n    if (properties.attributes)\n      node.attributes = properties.attributes;\n\n    return node;\n  }\n\n\n  /**\n   * Edge structure.\n   * A function returning an object guarded with default value.\n   *\n   * @param  {object} properties The edge properties.\n   * @return {object}            The guarded edge object.\n   */\n  function Edge(properties) {\n\n    // Possible Properties\n    var edge = {\n      id: properties.id,\n      type: properties.type || 'undirected',\n      label: properties.label || '',\n      source: properties.source,\n      target: properties.target,\n      weight: +properties.weight || 1.0\n    };\n\n    if (properties.viz)\n      edge.viz = properties.viz;\n\n    if (properties.attributes)\n      edge.attributes = properties.attributes;\n\n    return edge;\n  }\n\n  /**\n   * Graph parser.\n   * This structure parse a gexf string and return an object containing the\n   * parsed graph.\n   *\n   * @param  {string} xml The xml string of the gexf file to parse.\n   * @return {object}     The parsed graph.\n   */\n  function Graph(xml) {\n    var _xml = {};\n\n    // Basic Properties\n    //------------------\n    _xml.els = {\n      root: xml.getElementsByTagName('gexf')[0],\n      graph: xml.getElementsByTagName('graph')[0],\n      meta: xml.getElementsByTagName('meta')[0],\n      nodes: xml.getElementsByTagName('node'),\n      edges: xml.getElementsByTagName('edge'),\n      model: _helpers.getModelTags(xml)\n    };\n\n    // Information\n    _xml.hasViz = !!_helpers.getAttributeNS(_xml.els.root, 'xmlns', 'viz');\n    _xml.version = _xml.els.root.getAttribute('version') || '1.0';\n    _xml.mode = _xml.els.graph.getAttribute('mode') || 'static';\n\n    var edgeType = _xml.els.graph.getAttribute('defaultedgetype');\n    _xml.defaultEdgetype = edgeType || 'undirected';\n\n    // Parser Functions\n    //------------------\n\n    // Meta Data\n    function _metaData() {\n\n      var metas = {};\n      if (!_xml.els.meta)\n        return metas;\n\n      // Last modified date\n      metas.lastmodifieddate = _xml.els.meta.getAttribute('lastmodifieddate');\n\n      // Other information\n      _helpers.nodeListEach(_xml.els.meta.childNodes, function(child) {\n        metas[child.tagName.toLowerCase()] = child.textContent;\n      });\n\n      return metas;\n    }\n\n    // Model\n    function _model(cls) {\n      var attributes = [];\n\n      // Iterating through attributes\n      if (_xml.els.model[cls])\n        _helpers.nodeListEach(_xml.els.model[cls], function(attr) {\n\n          // Properties\n          var properties = {\n            id: attr.getAttribute('id') || attr.getAttribute('for'),\n            type: attr.getAttribute('type') || 'string',\n            title: attr.getAttribute('title') || ''\n          };\n\n          // Defaults\n          var default_el = _helpers.nodeListToArray(attr.childNodes);\n\n          if (default_el.length > 0)\n            properties.defaultValue = default_el[0].textContent;\n\n          // Creating attribute\n          attributes.push(properties);\n        });\n\n      return attributes.length > 0 ? attributes : false;\n    }\n\n    // Data from nodes or edges\n    function _data(model, node_or_edge) {\n\n      var data = {};\n      var attvalues_els = node_or_edge.getElementsByTagName('attvalue');\n\n      // Getting Node Indicated Attributes\n      var ah = _helpers.nodeListToHash(attvalues_els, function(el) {\n        var attributes = _helpers.namedNodeMapToObject(el.attributes);\n        var key = attributes.id || attributes['for'];\n\n        // Returning object\n        return {key: key, value: attributes.value};\n      });\n\n\n      // Iterating through model\n      model.map(function(a) {\n\n        // Default value?\n        data[a.id] = !(a.id in ah) && 'defaultValue' in a ?\n          _helpers.enforceType(a.type, a.defaultValue) :\n          _helpers.enforceType(a.type, ah[a.id]);\n\n      });\n\n      return data;\n    }\n\n    // Nodes\n    function _nodes(model) {\n      var nodes = [];\n\n      // Iteration through nodes\n      _helpers.nodeListEach(_xml.els.nodes, function(n) {\n\n        // Basic properties\n        var properties = {\n          id: n.getAttribute('id'),\n          label: n.getAttribute('label') || ''\n        };\n\n        // Retrieving data from nodes if any\n        if (model)\n          properties.attributes = _data(model, n);\n\n        // Retrieving viz information\n        if (_xml.hasViz)\n          properties.viz = _nodeViz(n);\n\n        // Pushing node\n        nodes.push(Node(properties));\n      });\n\n      return nodes;\n    }\n\n    // Viz information from nodes\n    function _nodeViz(node) {\n      var viz = {};\n\n      // Color\n      var color_el = _helpers.getFirstElementByTagNS(node, 'viz', 'color');\n\n      if (color_el) {\n        var color = ['r', 'g', 'b', 'a'].map(function(c) {\n          return color_el.getAttribute(c);\n        });\n\n        viz.color = _helpers.getRGB(color);\n      }\n\n      // Position\n      var pos_el = _helpers.getFirstElementByTagNS(node, 'viz', 'position');\n\n      if (pos_el) {\n        viz.position = {};\n\n        ['x', 'y', 'z'].map(function(p) {\n          viz.position[p] = +pos_el.getAttribute(p);\n        });\n      }\n\n      // Size\n      var size_el = _helpers.getFirstElementByTagNS(node, 'viz', 'size');\n      if (size_el)\n        viz.size = +size_el.getAttribute('value');\n\n      // Shape\n      var shape_el = _helpers.getFirstElementByTagNS(node, 'viz', 'shape');\n      if (shape_el)\n        viz.shape = shape_el.getAttribute('value');\n\n      return viz;\n    }\n\n    // Edges\n    function _edges(model, default_type) {\n      var edges = [];\n\n      // Iteration through edges\n      _helpers.nodeListEach(_xml.els.edges, function(e) {\n\n        // Creating the edge\n        var properties = _helpers.namedNodeMapToObject(e.attributes);\n        if (!('type' in properties)) {\n          properties.type = default_type;\n        }\n\n        // Retrieving edge data\n        if (model)\n          properties.attributes = _data(model, e);\n\n\n        // Retrieving viz information\n        if (_xml.hasViz)\n          properties.viz = _edgeViz(e);\n\n        edges.push(Edge(properties));\n      });\n\n      return edges;\n    }\n\n    // Viz information from edges\n    function _edgeViz(edge) {\n      var viz = {};\n\n      // Color\n      var color_el = _helpers.getFirstElementByTagNS(edge, 'viz', 'color');\n\n      if (color_el) {\n        var color = ['r', 'g', 'b', 'a'].map(function(c) {\n          return color_el.getAttribute(c);\n        });\n\n        viz.color = _helpers.getRGB(color);\n      }\n\n      // Shape\n      var shape_el = _helpers.getFirstElementByTagNS(edge, 'viz', 'shape');\n      if (shape_el)\n        viz.shape = shape_el.getAttribute('value');\n\n      // Thickness\n      var thick_el = _helpers.getFirstElementByTagNS(edge, 'viz', 'thickness');\n      if (thick_el)\n        viz.thickness = +thick_el.getAttribute('value');\n\n      return viz;\n    }\n\n\n    // Returning the Graph\n    //---------------------\n    var nodeModel = _model('node'),\n        edgeModel = _model('edge');\n\n    var graph = {\n      version: _xml.version,\n      mode: _xml.mode,\n      defaultEdgeType: _xml.defaultEdgetype,\n      meta: _metaData(),\n      model: {},\n      nodes: _nodes(nodeModel),\n      edges: _edges(edgeModel, _xml.defaultEdgetype)\n    };\n\n    if (nodeModel)\n      graph.model.node = nodeModel;\n    if (edgeModel)\n      graph.model.edge = edgeModel;\n\n    return graph;\n  }\n\n\n  /**\n   * Public API\n   * -----------\n   *\n   * User-accessible functions.\n   */\n\n  // Fetching GEXF with XHR\n  function fetch(gexf_url, callback) {\n    var xhr = (function() {\n      if (window.XMLHttpRequest)\n        return new XMLHttpRequest();\n\n      var names,\n          i;\n\n      if (window.ActiveXObject) {\n        names = [\n          'Msxml2.XMLHTTP.6.0',\n          'Msxml2.XMLHTTP.3.0',\n          'Msxml2.XMLHTTP',\n          'Microsoft.XMLHTTP'\n        ];\n\n        for (i in names)\n          try {\n            return new ActiveXObject(names[i]);\n          } catch (e) {}\n      }\n\n      return null;\n    })();\n\n    if (!xhr)\n      throw 'XMLHttpRequest not supported, cannot load the file.';\n\n    // Async?\n    var async = (typeof callback === 'function'),\n        getResult;\n\n    // If we can't override MIME type, we are on IE 9\n    // We'll be parsing the response string then.\n    if (xhr.overrideMimeType) {\n      xhr.overrideMimeType('text/xml');\n      getResult = function(r) {\n        return r.responseXML;\n      };\n    }\n    else {\n      getResult = function(r) {\n        var p = new DOMParser();\n        return p.parseFromString(r.responseText, 'application/xml');\n      };\n    }\n\n    xhr.open('GET', gexf_url, async);\n\n    if (async)\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4)\n          callback(getResult(xhr));\n      };\n\n    xhr.send();\n\n    return (async) ? xhr : getResult(xhr);\n  }\n\n  // Parsing the GEXF File\n  function parse(gexf) {\n    return Graph(gexf);\n  }\n\n  // Fetch and parse the GEXF File\n  function fetchAndParse(gexf_url, callback) {\n    if (typeof callback === 'function') {\n      return fetch(gexf_url, function(gexf) {\n        callback(Graph(gexf));\n      });\n    } else\n      return Graph(fetch(gexf_url));\n  }\n\n\n  /**\n   * Exporting\n   * ----------\n   */\n  if (typeof this.gexf !== 'undefined')\n    throw 'gexf: error - a variable called \"gexf\" already ' +\n          'exists in the global scope';\n\n  this.gexf = {\n\n    // Functions\n    parse: parse,\n    fetch: fetchAndParse,\n\n    // Version\n    version: '0.1.1'\n  };\n\n  if (typeof exports !== 'undefined' && this.exports !== exports)\n    module.exports = this.gexf;\n}).call(window);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.parsers');\n\n  // Just a basic ID generator:\n  var _id = 0;\n  function edgeId() {\n    return 'e' + (_id++);\n  }\n\n  /**\n   * If the first arguments is a valid URL, this function loads a GEXF file and\n   * creates a new sigma instance or updates the graph of a given instance. It\n   * is possible to give a callback that will be executed at the end of the\n   * process. And if the first argument is a DOM element, it will skip the\n   * loading step and parse the given XML tree to fill the graph.\n   *\n   * @param  {string|DOMElement} target   The URL of the GEXF file or a valid\n   *                                      GEXF tree.\n   * @param  {object|sigma}      sig      A sigma configuration object or a\n   *                                      sigma instance.\n   * @param  {?function}         callback Eventually a callback to execute\n   *                                      after having parsed the file. It will\n   *                                      be called with the related sigma\n   *                                      instance as parameter.\n   */\n  sigma.parsers.gexf = function(target, sig, callback) {\n    var i,\n        l,\n        arr,\n        obj;\n\n    function parse(graph) {\n      // Adapt the graph:\n      arr = graph.nodes;\n      for (i = 0, l = arr.length; i < l; i++) {\n        obj = arr[i];\n\n        obj.id = obj.id;\n        if (obj.viz && typeof obj.viz === 'object') {\n          if (obj.viz.position && typeof obj.viz.position === 'object') {\n            obj.x = obj.viz.position.x;\n            obj.y = -obj.viz.position.y; // Needed otherwise it's up side down\n          }\n          obj.size = obj.viz.size;\n          obj.color = obj.viz.color;\n        }\n      }\n\n      arr = graph.edges;\n      for (i = 0, l = arr.length; i < l; i++) {\n        obj = arr[i];\n\n        obj.id = typeof obj.id === 'string' ? obj.id : edgeId();\n        obj.source = '' + obj.source;\n        obj.target = '' + obj.target;\n\n        if (obj.viz && typeof obj.viz === 'object') {\n          obj.color = obj.viz.color;\n          obj.size = obj.viz.thickness;\n        }\n\n        // Weight over viz.thickness?\n        obj.size = obj.weight;\n\n        // Changing type to be direction so it won't mess with sigma's naming\n        obj.direction = obj.type;\n        delete obj.type;\n      }\n\n      // Update the instance's graph:\n      if (sig instanceof sigma) {\n        sig.graph.clear();\n\n        arr = graph.nodes;\n        for (i = 0, l = arr.length; i < l; i++)\n          sig.graph.addNode(arr[i]);\n\n        arr = graph.edges;\n        for (i = 0, l = arr.length; i < l; i++)\n          sig.graph.addEdge(arr[i]);\n\n      // ...or instantiate sigma if needed:\n      } else if (typeof sig === 'object') {\n        sig.graph = graph;\n        sig = new sigma(sig);\n\n      // ...or it's finally the callback:\n      } else if (typeof sig === 'function') {\n        callback = sig;\n        sig = null;\n      }\n\n      // Call the callback if specified:\n      if (callback) {\n        callback(sig || graph);\n        return;\n      } else\n        return graph;\n    }\n\n    if (typeof target === 'string')\n      gexf.fetch(target, parse);\n    else if (typeof target === 'object')\n      return parse(gexf.parse(target));\n  };\n}).call(window);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/parsers.gexf.js\n// module id = ./node_modules/react-sigma/sigma/parsers.gexf.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 128);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 128:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.parsers');\n  sigma.utils.pkg('sigma.utils');\n\n  /**\n   * Just an XmlHttpRequest polyfill for different IE versions.\n   *\n   * @return {*} The XHR like object.\n   */\n  sigma.utils.xhr = function() {\n    if (window.XMLHttpRequest)\n      return new XMLHttpRequest();\n\n    var names,\n        i;\n\n    if (window.ActiveXObject) {\n      names = [\n        'Msxml2.XMLHTTP.6.0',\n        'Msxml2.XMLHTTP.3.0',\n        'Msxml2.XMLHTTP',\n        'Microsoft.XMLHTTP'\n      ];\n\n      for (i in names)\n        try {\n          return new ActiveXObject(names[i]);\n        } catch (e) {}\n    }\n\n    return null;\n  };\n\n  /**\n   * This function loads a JSON file and creates a new sigma instance or\n   * updates the graph of a given instance. It is possible to give a callback\n   * that will be executed at the end of the process.\n   *\n   * @param  {string}       url      The URL of the JSON file.\n   * @param  {object|sigma} sig      A sigma configuration object or a sigma\n   *                                 instance.\n   * @param  {?function}    callback Eventually a callback to execute after\n   *                                 having parsed the file. It will be called\n   *                                 with the related sigma instance as\n   *                                 parameter.\n   */\n  sigma.parsers.json = function(url, sig, callback) {\n    var graph,\n        xhr = sigma.utils.xhr();\n\n    if (!xhr)\n      throw 'XMLHttpRequest not supported, cannot load the file.';\n\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState === 4) {\n        graph = JSON.parse(xhr.responseText);\n\n        // Update the instance's graph:\n        if (sig instanceof sigma) {\n          sig.graph.clear();\n          sig.graph.read(graph);\n\n        // ...or instantiate sigma if needed:\n        } else if (typeof sig === 'object') {\n          sig.graph = graph;\n          sig = new sigma(sig);\n\n        // ...or it's finally the callback:\n        } else if (typeof sig === 'function') {\n          callback = sig;\n          sig = null;\n        }\n\n        // Call the callback if specified:\n        if (callback)\n          callback(sig || graph);\n      }\n    };\n    xhr.send();\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/parsers.json.js\n// module id = ./node_modules/react-sigma/sigma/parsers.json.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 129);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 129:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n/**\n * This plugin provides a method to animate a sigma instance by interpolating\n * some node properties. Check the sigma.plugins.animate function doc or the\n * examples/animate.html code sample to know more.\n */\n(function() {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.plugins');\n\n  var _id = 0,\n      _cache = {};\n\n  // TOOLING FUNCTIONS:\n  // ******************\n  function parseColor(val) {\n    if (_cache[val])\n      return _cache[val];\n\n    var result = [0, 0, 0];\n\n    if (val.match(/^#/)) {\n      val = (val || '').replace(/^#/, '');\n      result = (val.length === 3) ?\n        [\n          parseInt(val.charAt(0) + val.charAt(0), 16),\n          parseInt(val.charAt(1) + val.charAt(1), 16),\n          parseInt(val.charAt(2) + val.charAt(2), 16)\n        ] :\n        [\n          parseInt(val.charAt(0) + val.charAt(1), 16),\n          parseInt(val.charAt(2) + val.charAt(3), 16),\n          parseInt(val.charAt(4) + val.charAt(5), 16)\n        ];\n    } else if (val.match(/^ *rgba? *\\(/)) {\n      val = val.match(\n        /^ *rgba? *\\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\\) *$/\n      );\n      result = [\n        +val[1],\n        +val[2],\n        +val[3]\n      ];\n    }\n\n    _cache[val] = {\n      r: result[0],\n      g: result[1],\n      b: result[2]\n    };\n\n    return _cache[val];\n  }\n\n  function interpolateColors(c1, c2, p) {\n    c1 = parseColor(c1);\n    c2 = parseColor(c2);\n\n    var c = {\n      r: c1.r * (1 - p) + c2.r * p,\n      g: c1.g * (1 - p) + c2.g * p,\n      b: c1.b * (1 - p) + c2.b * p\n    };\n\n    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';\n  }\n\n  /**\n   * This function will animate some specified node properties. It will\n   * basically call requestAnimationFrame, interpolate the values and call the\n   * refresh method during a specified duration.\n   *\n   * Recognized parameters:\n   * **********************\n   * Here is the exhaustive list of every accepted parameters in the settings\n   * object:\n   *\n   *   {?array}             nodes      An array of node objects or node ids. If\n   *                                   not specified, all nodes of the graph\n   *                                   will be animated.\n   *   {?(function|string)} easing     Either the name of an easing in the\n   *                                   sigma.utils.easings package or a\n   *                                   function. If not specified, the\n   *                                   quadraticInOut easing from this package\n   *                                   will be used instead.\n   *   {?number}            duration   The duration of the animation. If not\n   *                                   specified, the \"animationsTime\" setting\n   *                                   value of the sigma instance will be used\n   *                                   instead.\n   *   {?function}          onComplete Eventually a function to call when the\n   *                                   animation is ended.\n   *\n   * @param  {sigma}   s       The related sigma instance.\n   * @param  {object}  animate An hash with the keys being the node properties\n   *                           to interpolate, and the values being the related\n   *                           target values.\n   * @param  {?object} options Eventually an object with options.\n   */\n  sigma.plugins.animate = function(s, animate, options) {\n    var o = options || {},\n        id = ++_id,\n        duration = o.duration || s.settings('animationsTime'),\n        easing = typeof o.easing === 'string' ?\n          sigma.utils.easings[o.easing] :\n          typeof o.easing === 'function' ?\n          o.easing :\n          sigma.utils.easings.quadraticInOut,\n        start = sigma.utils.dateNow(),\n        nodes,\n        startPositions;\n\n    if (o.nodes && o.nodes.length) {\n      if (typeof o.nodes[0] === 'object')\n        nodes = o.nodes;\n      else\n        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs\n    }\n    else\n      nodes = s.graph.nodes();\n\n    // Store initial positions:\n    startPositions = nodes.reduce(function(res, node) {\n      var k;\n      res[node.id] = {};\n      for (k in animate)\n        if (k in node)\n          res[node.id][k] = node[k];\n      return res;\n    }, {});\n\n    s.animations = s.animations || Object.create({});\n    sigma.plugins.kill(s);\n\n    // Do not refresh edgequadtree during drag:\n    var k,\n        c;\n    for (k in s.cameras) {\n      c = s.cameras[k];\n      c.edgequadtree._enabled = false;\n    }\n\n    function step() {\n      var p = (sigma.utils.dateNow() - start) / duration;\n\n      if (p >= 1) {\n        nodes.forEach(function(node) {\n          for (var k in animate)\n            if (k in animate)\n              node[k] = node[animate[k]];\n        });\n\n        // Allow to refresh edgequadtree:\n        var k,\n            c;\n        for (k in s.cameras) {\n          c = s.cameras[k];\n          c.edgequadtree._enabled = true;\n        }\n\n        s.refresh();\n        if (typeof o.onComplete === 'function')\n          o.onComplete();\n      } else {\n        p = easing(p);\n        nodes.forEach(function(node) {\n          for (var k in animate)\n            if (k in animate) {\n              if (k.match(/color$/))\n                node[k] = interpolateColors(\n                  startPositions[node.id][k],\n                  node[animate[k]],\n                  p\n                );\n              else\n                node[k] =\n                  node[animate[k]] * p +\n                  startPositions[node.id][k] * (1 - p);\n            }\n        });\n\n        s.refresh();\n        s.animations[id] = requestAnimationFrame(step);\n      }\n    }\n\n    step();\n  };\n\n  sigma.plugins.kill = function(s) {\n    for (var k in (s.animations || {}))\n      cancelAnimationFrame(s.animations[k]);\n\n    // Allow to refresh edgequadtree:\n    var k,\n        c;\n    for (k in s.cameras) {\n      c = s.cameras[k];\n      c.edgequadtree._enabled = true;\n    }\n  };\n}).call(window);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/plugins.animate.js\n// module id = ./node_modules/react-sigma/sigma/plugins.animate.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 131);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 131:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize package:\n  sigma.utils.pkg('sigma.plugins');\n\n  // Add custom graph methods:\n  /**\n   * This methods returns an array of nodes that are adjacent to a node.\n   *\n   * @param  {string} id The node id.\n   * @return {array}     The array of adjacent nodes.\n   */\n  if (!sigma.classes.graph.hasMethod('adjacentNodes'))\n    sigma.classes.graph.addMethod('adjacentNodes', function(id) {\n      if (typeof id !== 'string')\n        throw 'adjacentNodes: the node id must be a string.';\n\n      var target,\n          nodes = [];\n      for(target in this.allNeighborsIndex[id]) {\n        nodes.push(this.nodesIndex[target]);\n      }\n      return nodes;\n    });\n\n  /**\n   * This methods returns an array of edges that are adjacent to a node.\n   *\n   * @param  {string} id The node id.\n   * @return {array}     The array of adjacent edges.\n   */\n  if (!sigma.classes.graph.hasMethod('adjacentEdges'))\n    sigma.classes.graph.addMethod('adjacentEdges', function(id) {\n      if (typeof id !== 'string')\n        throw 'adjacentEdges: the node id must be a string.';\n\n      var a = this.allNeighborsIndex[id],\n          eid,\n          target,\n          edges = [];\n      for(target in a) {\n        for(eid in a[target]) {\n          edges.push(a[target][eid]);\n        }\n      }\n      return edges;\n    });\n\n  /**\n   * Sigma Filter\n   * =============================\n   *\n   * @author Sébastien Heymann <seb@linkurio.us> (Linkurious)\n   * @version 0.1\n   */\n\n   var _g = undefined,\n       _s = undefined,\n       _chain = [], // chain of wrapped filters\n       _keysIndex = Object.create(null),\n       Processors = {};   // available predicate processors\n\n\n  /**\n   * Library of processors\n   * ------------------\n   */\n\n   /**\n    *\n    * @param  {function} fn The predicate.\n    */\n  Processors.nodes = function nodes(fn) {\n    var n = _g.nodes(),\n        ln = n.length,\n        e = _g.edges(),\n        le = e.length;\n\n    // hide node, or keep former value\n    while(ln--)\n      n[ln].hidden = !fn.call(_g, n[ln]) || n[ln].hidden;\n\n    while(le--)\n      if (_g.nodes(e[le].source).hidden || _g.nodes(e[le].target).hidden)\n        e[le].hidden = true;\n  };\n\n   /**\n    *\n    * @param  {function} fn The predicate.\n    */\n  Processors.edges = function edges(fn) {\n    var e = _g.edges(),\n        le = e.length;\n\n    // hide edge, or keep former value\n    while(le--)\n      e[le].hidden = !fn.call(_g, e[le]) || e[le].hidden;\n  };\n\n   /**\n    *\n    * @param  {string} id The center node.\n    */\n  Processors.neighbors = function neighbors(id) {\n    var n = _g.nodes(),\n        ln = n.length,\n        e = _g.edges(),\n        le = e.length,\n        neighbors = _g.adjacentNodes(id),\n        nn = neighbors.length,\n        no = {};\n\n    while(nn--)\n      no[neighbors[nn].id] = true;\n\n    while(ln--)\n      if (n[ln].id !== id && !(n[ln].id in no))\n        n[ln].hidden = true;\n\n    while(le--)\n      if (_g.nodes(e[le].source).hidden || _g.nodes(e[le].target).hidden)\n        e[le].hidden = true;\n  };\n\n\n  /**\n   * This function adds a filter to the chain of filters.\n   *\n   * @param  {function} fn  The filter (i.e. predicate processor).\n   * @param  {function} p   The predicate.\n   * @param  {?string}  key The key to identify the filter.\n   */\n  function register(fn, p, key) {\n    if (key != undefined && typeof key !== 'string')\n      throw 'The filter key \"'+ key.toString() +'\" must be a string.';\n\n    if (key != undefined && !key.length)\n      throw 'The filter key must be a non-empty string.';\n\n    if (typeof fn !== 'function')\n      throw 'The predicate of key \"'+ key +'\" must be a function.';\n\n    if ('undo' === key)\n      throw '\"undo\" is a reserved key.';\n\n    if (_keysIndex[key])\n      throw 'The filter \"' + key + '\" already exists.';\n\n    if (key)\n      _keysIndex[key] = true;\n\n    _chain.push({\n      'key': key,\n      'processor': fn,\n      'predicate': p\n    });\n  };\n\n  /**\n   * This function removes a set of filters from the chain.\n   *\n   * @param {object} o The filter keys.\n   */\n  function unregister (o) {\n    _chain = _chain.filter(function(a) {\n      return !(a.key in o);\n    });\n\n    for(var key in o)\n      delete _keysIndex[key];\n  };\n\n\n\n\n  /**\n   * Filter Object\n   * ------------------\n   * @param  {sigma} s The related sigma instance.\n   */\n  function Filter(s) {\n    _s = s;\n    _g = s.graph;\n  };\n\n\n  /**\n   * This method is used to filter the nodes. The method must be called with\n   * the predicate, which is a function that takes a node as argument and\n   * returns a boolean. It may take an identifier as argument to undo the\n   * filter later. The method wraps the predicate into an anonymous function\n   * that looks through each node in the graph. When executed, the anonymous\n   * function hides the nodes that fail a truth test (predicate). The method\n   * adds the anonymous function to the chain of filters. The filter is not\n   * executed until the apply() method is called.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.nodesBy(function(n) {\n   * >   return this.degree(n.id) > 0;\n   * > }, 'degreeNotNull');\n   *\n   * @param  {function}             fn  The filter predicate.\n   * @param  {?string}              key The key to identify the filter.\n   * @return {sigma.plugins.filter}     Returns the instance.\n   */\n  Filter.prototype.nodesBy = function(fn, key) {\n    // Wrap the predicate to be applied on the graph and add it to the chain.\n    register(Processors.nodes, fn, key);\n\n    return this;\n  };\n\n  /**\n   * This method is used to filter the edges. The method must be called with\n   * the predicate, which is a function that takes a node as argument and\n   * returns a boolean. It may take an identifier as argument to undo the\n   * filter later. The method wraps the predicate into an anonymous function\n   * that looks through each edge in the graph. When executed, the anonymous\n   * function hides the edges that fail a truth test (predicate). The method\n   * adds the anonymous function to the chain of filters. The filter is not\n   * executed until the apply() method is called.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.edgesBy(function(e) {\n   * >   return e.size > 1;\n   * > }, 'edgeSize');\n   *\n   * @param  {function}             fn  The filter predicate.\n   * @param  {?string}              key The key to identify the filter.\n   * @return {sigma.plugins.filter}     Returns the instance.\n   */\n  Filter.prototype.edgesBy = function(fn, key) {\n    // Wrap the predicate to be applied on the graph and add it to the chain.\n    register(Processors.edges, fn, key);\n\n    return this;\n  };\n\n  /**\n   * This method is used to filter the nodes which are not direct connections\n   * of a given node. The method must be called with the node identifier. It\n   * may take an identifier as argument to undo the filter later. The filter\n   * is not executed until the apply() method is called.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.neighborsOf('n0');\n   *\n   * @param  {string}               id  The node id.\n   * @param  {?string}              key The key to identify the filter.\n   * @return {sigma.plugins.filter}     Returns the instance.\n   */\n  Filter.prototype.neighborsOf = function(id, key) {\n    if (typeof id !== 'string')\n      throw 'The node id \"'+ id.toString() +'\" must be a string.';\n    if (!id.length)\n      throw 'The node id must be a non-empty string.';\n\n    // Wrap the predicate to be applied on the graph and add it to the chain.\n    register(Processors.neighbors, id, key);\n\n    return this;\n  };\n\n  /**\n   * This method is used to execute the chain of filters and to refresh the\n   * display.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter\n   * >   .nodesBy(function(n) {\n   * >     return this.degree(n.id) > 0;\n   * >   }, 'degreeNotNull')\n   * >   .apply();\n   *\n   * @return {sigma.plugins.filter}      Returns the instance.\n   */\n  Filter.prototype.apply = function() {\n    for (var i = 0, len = _chain.length; i < len; ++i) {\n      _chain[i].processor(_chain[i].predicate);\n    };\n\n    if (_chain[0] && 'undo' === _chain[0].key) {\n      _chain.shift();\n    }\n\n    _s.refresh();\n\n    return this;\n  };\n\n  /**\n   * This method undoes one or several filters, depending on how it is called.\n   *\n   * To undo all filters, call \"undo\" without argument. To undo a specific\n   * filter, call it with the key of the filter. To undo multiple filters, call\n   * it with an array of keys or multiple arguments, and it will undo each\n   * filter, in the same order. The undo is not executed until the apply()\n   * method is called. For instance:\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter\n   * >   .nodesBy(function(n) {\n   * >     return this.degree(n.id) > 0;\n   * >   }, 'degreeNotNull');\n   * >   .edgesBy(function(e) {\n   * >     return e.size > 1;\n   * >   }, 'edgeSize')\n   * >   .undo();\n   *\n   * Other examples:\n   * > filter.undo();\n   * > filter.undo('myfilter');\n   * > filter.undo(['myfilter1', 'myfilter2']);\n   * > filter.undo('myfilter1', 'myfilter2');\n   *\n   * @param  {?(string|array|*string))} v Eventually one key, an array of keys.\n   * @return {sigma.plugins.filter}       Returns the instance.\n   */\n  Filter.prototype.undo = function(v) {\n    var q = Object.create(null),\n        la = arguments.length;\n\n    // find removable filters\n    if (la === 1) {\n      if (Object.prototype.toString.call(v) === '[object Array]')\n        for (var i = 0, len = v.length; i < len; i++)\n          q[v[i]] = true;\n\n      else // 1 filter key\n        q[v] = true;\n\n    } else if (la > 1) {\n      for (var i = 0; i < la; i++)\n        q[arguments[i]] = true;\n    }\n    else\n      this.clear();\n\n    unregister(q);\n\n    function processor() {\n      var n = _g.nodes(),\n          ln = n.length,\n          e = _g.edges(),\n          le = e.length;\n\n      while(ln--)\n        n[ln].hidden = false;\n\n      while(le--)\n        e[le].hidden = false;\n    };\n\n    _chain.unshift({\n      'key': 'undo',\n      'processor': processor\n    });\n\n    return this;\n  };\n\n  // fast deep copy function\n  function deepCopy(o) {\n    var copy = Object.create(null);\n    for (var i in o) {\n      if (typeof o[i] === \"object\" && o[i] !== null) {\n        copy[i] = deepCopy(o[i]);\n      }\n      else if (typeof o[i] === \"function\" && o[i] !== null) {\n        // clone function:\n        eval(\" copy[i] = \" +  o[i].toString());\n        //copy[i] = o[i].bind(_g);\n      }\n\n      else\n        copy[i] = o[i];\n    }\n    return copy;\n  };\n\n  function cloneChain(chain) {\n    // Clone the array of filters:\n    var copy = chain.slice(0);\n    for (var i = 0, len = copy.length; i < len; i++) {\n      copy[i] = deepCopy(copy[i]);\n      if (typeof copy[i].processor === \"function\")\n        copy[i].processor = 'filter.processors.' + copy[i].processor.name;\n    };\n    return copy;\n  }\n\n  /**\n   * This method is used to empty the chain of filters.\n   * Prefer the undo() method to reset filters.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > filter.clear();\n   *\n   * @return {sigma.plugins.filter} Returns the instance.\n   */\n  Filter.prototype.clear = function() {\n    _chain.length = 0; // clear the array\n    _keysIndex = Object.create(null);\n    return this;\n  };\n\n  /**\n   * This method clones the filter chain and return the copy.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > var chain = filter.export();\n   *\n   * @return {object}   The cloned chain of filters.\n   */\n  Filter.prototype.export = function() {\n    var c = cloneChain(_chain);\n    return c;\n  };\n\n  /**\n   * This method sets the chain of filters with the specified chain.\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   * > var chain = [\n   * >   {\n   * >     key: 'my-filter',\n   * >     predicate: function(n) {...},\n   * >     processor: 'filter.processors.nodes'\n   * >   }, ...\n   * > ];\n   * > filter.import(chain);\n   *\n   * @param {array} chain The chain of filters.\n   * @return {sigma.plugins.filter} Returns the instance.\n   */\n  Filter.prototype.import = function(chain) {\n    if (chain === undefined)\n      throw 'Wrong arguments.';\n\n    if (Object.prototype.toString.call(chain) !== '[object Array]')\n      throw 'The chain\" must be an array.';\n\n    var copy = cloneChain(chain);\n\n    for (var i = 0, len = copy.length; i < len; i++) {\n      if (copy[i].predicate === undefined || copy[i].processor === undefined)\n        throw 'Wrong arguments.';\n\n      if (copy[i].key != undefined && typeof copy[i].key !== 'string')\n        throw 'The filter key \"'+ copy[i].key.toString() +'\" must be a string.';\n\n      if (typeof copy[i].predicate !== 'function')\n        throw 'The predicate of key \"'+ copy[i].key +'\" must be a function.';\n\n      if (typeof copy[i].processor !== 'string')\n        throw 'The processor of key \"'+ copy[i].key +'\" must be a string.';\n\n      // Replace the processor name by the corresponding function:\n      switch(copy[i].processor) {\n        case 'filter.processors.nodes':\n          copy[i].processor = Processors.nodes;\n          break;\n        case 'filter.processors.edges':\n          copy[i].processor = Processors.edges;\n          break;\n        case 'filter.processors.neighbors':\n          copy[i].processor = Processors.neighbors;\n          break;\n        default:\n          throw 'Unknown processor ' + copy[i].processor;\n      }\n    };\n\n    _chain = copy;\n\n    return this;\n  };\n\n\n  /**\n   * Interface\n   * ------------------\n   *\n   * > var filter = new sigma.plugins.filter(s);\n   */\n  var filter = null;\n\n  /**\n   * @param  {sigma} s The related sigma instance.\n   */\n  sigma.plugins.filter = function(s) {\n    // Create new filter to update the graph params\n    filter = new Filter(s);\n    return filter;\n  };\n\n}).call(this);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/plugins.filter.js\n// module id = ./node_modules/react-sigma/sigma/plugins.filter.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 133);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 133:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n(function() {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  sigma.utils.pkg('sigma.plugins');\n\n  var _id = 0,\n      _cache = {};\n\n  /**\n   * This function will change size for all nodes depending to their degree\n   *\n   * @param  {sigma}   s       \t\tThe related sigma instance.\n   * @param  {object}  initialSize \tStart size property\n   */\n  sigma.plugins.relativeSize = function(s, initialSize) {\n    var nodes = s.graph.nodes();\n\n    // second create size for every node\n    for(var i = 0; i < nodes.length; i++) {\n      var degree = s.graph.degree(nodes[i].id);\n      nodes[i].size = initialSize * Math.sqrt(degree);\n    }\n    s.refresh();\n  };\n}).call(window);\n\n}.call(window));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/plugins.relativeSize.js\n// module id = ./node_modules/react-sigma/sigma/plugins.relativeSize.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 83);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 63:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  if (typeof conrad === 'undefined')\n    throw 'conrad is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the svg sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.svg}             The renderer instance.\n   */\n  sigma.renderers.svg = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.svg: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var i,\n        l,\n        a,\n        fn,\n        self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.domElements = {\n      graph: null,\n      groups: {},\n      nodes: {},\n      edges: {},\n      labels: {},\n      hovers: {}\n    };\n    this.measurementCanvas = null;\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Is the renderer meant to be freestyle?\n    this.settings('freeStyle', !!this.options.freeStyle);\n\n    // SVG xmlns\n    this.settings('xmlns', 'http://www.w3.org/2000/svg');\n\n    // Indexes:\n    this.nodesOnScreen = [];\n    this.edgesOnScreen = [];\n\n    // Find the prefix:\n    this.options.prefix = 'renderer' + sigma.utils.id() + ':';\n\n    // Initialize the DOM elements\n    this.initDOM('svg');\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.graph,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Bind resize:\n    window.addEventListener('resize', function() {\n      self.resize();\n    });\n\n    // Deal with sigma events:\n    // TODO: keep an option to override the DOM events?\n    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);\n    this.bindHovers(this.options.prefix);\n\n    // Resize\n    this.resize(false);\n  };\n\n  /**\n   * This method renders the graph on the svg scene.\n   *\n   * @param  {?object}                options Eventually an object of options.\n   * @return {sigma.renderers.svg}            Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.render = function(options) {\n    options = options || {};\n\n    var a,\n        i,\n        k,\n        e,\n        l,\n        o,\n        source,\n        target,\n        start,\n        edges,\n        renderers,\n        subrenderers,\n        index = {},\n        graph = this.graph,\n        nodes = this.graph.nodes,\n        prefix = this.options.prefix || '',\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes'),\n        drawLabels = this.settings(options, 'drawLabels'),\n        embedSettings = this.settings.embedObjects(options, {\n          prefix: this.options.prefix,\n          forceLabels: this.options.forceLabels\n        });\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Apply the camera's view:\n    this.camera.applyView(\n      undefined,\n      this.options.prefix,\n      {\n        width: this.width,\n        height: this.height\n      }\n    );\n\n    // Hiding everything\n    // TODO: find a more sensible way to perform this operation\n    this.hideDOMElements(this.domElements.nodes);\n    this.hideDOMElements(this.domElements.edges);\n    this.hideDOMElements(this.domElements.labels);\n\n    // Find which nodes are on screen\n    this.edgesOnScreen = [];\n    this.nodesOnScreen = this.camera.quadtree.area(\n      this.camera.getRectangle(this.width, this.height)\n    );\n\n    // Node index\n    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)\n      index[a[i].id] = a[i];\n\n    // Find which edges are on screen\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      o = a[i];\n      if (\n        (index[o.source] || index[o.target]) &&\n        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)\n      )\n        this.edgesOnScreen.push(o);\n    }\n\n    // Display nodes\n    //---------------\n    renderers = sigma.svg.nodes;\n    subrenderers = sigma.svg.labels;\n\n    //-- First we create the nodes which are not already created\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {\n\n          // Node\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.nodes[a[i].id] = e;\n          this.domElements.groups.nodes.appendChild(e);\n\n          // Label\n          e = (subrenderers[a[i].type] || subrenderers.def).create(\n            a[i],\n            embedSettings\n          );\n\n          this.domElements.labels[a[i].id] = e;\n          this.domElements.groups.labels.appendChild(e);\n        }\n      }\n\n    //-- Second we update the nodes\n    if (drawNodes)\n      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {\n\n        if (a[i].hidden)\n          continue;\n\n        // Node\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.nodes[a[i].id],\n          embedSettings\n        );\n\n        // Label\n        (subrenderers[a[i].type] || subrenderers.def).update(\n          a[i],\n          this.domElements.labels[a[i].id],\n          embedSettings\n        );\n      }\n\n    // Display edges\n    //---------------\n    renderers = sigma.svg.edges;\n\n    //-- First we create the edges which are not already created\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        if (!this.domElements.edges[a[i].id]) {\n          source = nodes(a[i].source);\n          target = nodes(a[i].target);\n\n          e = (renderers[a[i].type] || renderers.def).create(\n            a[i],\n            source,\n            target,\n            embedSettings\n          );\n\n          this.domElements.edges[a[i].id] = e;\n          this.domElements.groups.edges.appendChild(e);\n        }\n       }\n\n    //-- Second we update the edges\n    if (drawEdges)\n      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {\n        source = nodes(a[i].source);\n        target = nodes(a[i].target);\n\n        (renderers[a[i].type] || renderers.def).update(\n          a[i],\n          this.domElements.edges[a[i].id],\n          source,\n          target,\n          embedSettings\n        );\n       }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string} tag The label tag.\n   * @param  {string} id  The id of the element (to store it in \"domElements\").\n   */\n  sigma.renderers.svg.prototype.initDOM = function(tag) {\n    var dom = document.createElementNS(this.settings('xmlns'), tag),\n        c = this.settings('classPrefix'),\n        g,\n        l,\n        i;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', c + '-svg');\n\n    // Setting SVG namespace\n    dom.setAttribute('xmlns', this.settings('xmlns'));\n    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    dom.setAttribute('version', '1.1');\n\n    // Creating the measurement canvas\n    var canvas = document.createElement('canvas');\n    canvas.setAttribute('class', c + '-measurement-canvas');\n\n    // Appending elements\n    this.domElements.graph = this.container.appendChild(dom);\n\n    // Creating groups\n    var groups = ['edges', 'nodes', 'labels', 'hovers'];\n    for (i = 0, l = groups.length; i < l; i++) {\n      g = document.createElementNS(this.settings('xmlns'), 'g');\n\n      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);\n      g.setAttributeNS(null, 'class', c + '-group');\n\n      this.domElements.groups[groups[i]] =\n        this.domElements.graph.appendChild(g);\n    }\n\n    // Appending measurement canvas\n    this.container.appendChild(canvas);\n    this.measurementCanvas = canvas.getContext('2d');\n  };\n\n  /**\n   * This method hides a batch of SVG DOM elements.\n   *\n   * @param  {array}                  elements  An array of elements to hide.\n   * @param  {object}                 renderer  The renderer to use.\n   * @return {sigma.renderers.svg}              Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {\n    var o,\n        i;\n\n    for (i in elements) {\n      o = elements[i];\n      sigma.svg.utils.hide(o);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method binds the hover events to the renderer.\n   *\n   * @param  {string} prefix The renderer prefix.\n   */\n  // TODO: add option about whether to display hovers or not\n  sigma.renderers.svg.prototype.bindHovers = function(prefix) {\n    var renderers = sigma.svg.hovers,\n        self = this,\n        hoveredNode;\n\n    function overNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      var hover = (renderers[node.type] || renderers.def).create(\n        node,\n        self.domElements.nodes[node.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[node.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n      hoveredNode = node;\n    }\n\n    function outNode(e) {\n      var node = e.data.node,\n          embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      if (!embedSettings('enableHovering'))\n        return;\n\n      // Deleting element\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[node.id]\n      );\n      hoveredNode = null;\n      delete self.domElements.hovers[node.id];\n\n      // Reinstate\n      self.domElements.groups.nodes.appendChild(\n        self.domElements.nodes[node.id]\n      );\n    }\n\n    // OPTIMIZE: perform a real update rather than a deletion\n    function update() {\n      if (!hoveredNode)\n        return;\n\n      var embedSettings = self.settings.embedObjects({\n            prefix: prefix\n          });\n\n      // Deleting element before update\n      self.domElements.groups.hovers.removeChild(\n        self.domElements.hovers[hoveredNode.id]\n      );\n      delete self.domElements.hovers[hoveredNode.id];\n\n      var hover = (renderers[hoveredNode.type] || renderers.def).create(\n        hoveredNode,\n        self.domElements.nodes[hoveredNode.id],\n        self.measurementCanvas,\n        embedSettings\n      );\n\n      self.domElements.hovers[hoveredNode.id] = hover;\n\n      // Inserting the hover in the dom\n      self.domElements.groups.hovers.appendChild(hover);\n    }\n\n    // Binding events\n    this.bind('overNode', overNode);\n    this.bind('outNode', outNode);\n\n    // Update on render\n    this.bind('render', update);\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}                width  The new width of the container.\n   * @param  {?number}                height The new height of the container.\n   * @return {sigma.renderers.svg}           Returns the instance itself.\n   */\n  sigma.renderers.svg.prototype.resize = function(w, h) {\n    var oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = 1;\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      this.domElements.graph.style.width = w + 'px';\n      this.domElements.graph.style.height = h + 'px';\n\n      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {\n        this.domElements.graph.setAttribute('width', (w * pixelRatio));\n        this.domElements.graph.setAttribute('height', (h * pixelRatio));\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * The labels, nodes and edges renderers are stored in the three following\n   * objects. When an element is drawn, its type will be checked and if a\n   * renderer with the same name exists, it will be used. If not found, the\n   * default renderer will be used instead.\n   *\n   * They are stored in different files, in the \"./svg\" folder.\n   */\n  sigma.utils.pkg('sigma.svg.nodes');\n  sigma.utils.pkg('sigma.svg.edges');\n  sigma.utils.pkg('sigma.svg.labels');\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 65:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The curve edge renderer. It renders the node as a bezier curve.\n   */\n  sigma.svg.edges.curve = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var path = document.createElementNS(settings('xmlns'), 'path');\n\n      // Attributes\n      path.setAttributeNS(null, 'data-edge-id', edge.id);\n      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      path.setAttributeNS(null, 'stroke', color);\n\n      return path;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, path, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n\n      // Control point\n      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +\n        (target[prefix + 'y'] - source[prefix + 'y']) / 4,\n          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +\n        (source[prefix + 'x'] - target[prefix + 'x']) / 4;\n\n      // Path\n      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +\n              'Q' + cx + ',' + cy + ' ' +\n              target[prefix + 'x'] + ',' + target[prefix + 'y'];\n\n      // Updating attributes\n      path.setAttributeNS(null, 'd', p);\n      path.setAttributeNS(null, 'fill', 'none');\n\n      // Showing\n      path.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 66:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.edges');\n\n  /**\n   * The default edge renderer. It renders the node as a simple line.\n   */\n  sigma.svg.edges.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(edge, source, target, settings) {\n      var color = edge.color,\n          prefix = settings('prefix') || '',\n          edgeColor = settings('edgeColor'),\n          defaultNodeColor = settings('defaultNodeColor'),\n          defaultEdgeColor = settings('defaultEdgeColor');\n\n      if (!color)\n        switch (edgeColor) {\n          case 'source':\n            color = source.color || defaultNodeColor;\n            break;\n          case 'target':\n            color = target.color || defaultNodeColor;\n            break;\n          default:\n            color = defaultEdgeColor;\n            break;\n        }\n\n      var line = document.createElementNS(settings('xmlns'), 'line');\n\n      // Attributes\n      line.setAttributeNS(null, 'data-edge-id', edge.id);\n      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');\n      line.setAttributeNS(null, 'stroke', color);\n\n      return line;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   edge       The edge object.\n     * @param  {DOMElement}               line       The line DOM Element.\n     * @param  {object}                   source     The source node object.\n     * @param  {object}                   target     The target node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    update: function(edge, line, source, target, settings) {\n      var prefix = settings('prefix') || '';\n\n      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);\n      line.setAttributeNS(null, 'x1', source[prefix + 'x']);\n      line.setAttributeNS(null, 'y1', source[prefix + 'y']);\n      line.setAttributeNS(null, 'x2', target[prefix + 'x']);\n      line.setAttributeNS(null, 'y2', target[prefix + 'y']);\n\n      // Showing\n      line.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 67:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.hovers');\n\n  /**\n   * The default hover renderer.\n   */\n  sigma.svg.hovers.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}           node               The node object.\n     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by\n     *                            the svg to perform some measurements and\n     *                            passed by the renderer.\n     * @param  {DOMElement}       nodeCircle         The node DOM Element.\n     * @param  {configurable}     settings           The settings function.\n     */\n    create: function(node, nodeCircle, measurementCanvas, settings) {\n\n      // Defining visual properties\n      var x,\n          y,\n          w,\n          h,\n          e,\n          d,\n          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),\n          prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          fontSize = (settings('labelSize') === 'fixed') ?\n            settings('defaultLabelSize') :\n            settings('labelSizeRatio') * size,\n          fontColor = (settings('labelHoverColor') === 'node') ?\n                        (node.color || settings('defaultNodeColor')) :\n                        settings('defaultLabelHoverColor');\n\n      // Creating elements\n      var group = document.createElementNS(settings('xmlns'), 'g'),\n          rectangle = document.createElementNS(settings('xmlns'), 'rect'),\n          circle = document.createElementNS(settings('xmlns'), 'circle'),\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      // Defining properties\n      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');\n      group.setAttributeNS(null, 'data-node-id', node.id);\n\n      if (typeof node.label === 'string') {\n\n        // Text\n        text.innerHTML = node.label;\n        text.textContent = node.label;\n        text.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-label');\n        text.setAttributeNS(null, 'font-size', fontSize);\n        text.setAttributeNS(null, 'font-family', settings('font'));\n        text.setAttributeNS(null, 'fill', fontColor);\n        text.setAttributeNS(null, 'x',\n          Math.round(node[prefix + 'x'] + size + 3));\n        text.setAttributeNS(null, 'y',\n          Math.round(node[prefix + 'y'] + fontSize / 3));\n\n        // Measures\n        // OPTIMIZE: Find a better way than a measurement canvas\n        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);\n        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);\n        w = Math.round(\n          measurementCanvas.measureText(node.label).width +\n            fontSize / 2 + size + 9\n        );\n        h = Math.round(fontSize + 4);\n        e = Math.round(fontSize / 2 + 2);\n\n        // Circle\n        circle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        circle.setAttributeNS(null, 'fill', '#fff');\n        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n        circle.setAttributeNS(null, 'r', e);\n\n        // Rectangle\n        rectangle.setAttributeNS(\n            null,\n            'class',\n            settings('classPrefix') + '-hover-area');\n        rectangle.setAttributeNS(null, 'fill', '#fff');\n        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);\n        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);\n        rectangle.setAttributeNS(null, 'width', w);\n        rectangle.setAttributeNS(null, 'height', h);\n      }\n\n      // Appending childs\n      group.appendChild(circle);\n      group.appendChild(rectangle);\n      group.appendChild(text);\n      group.appendChild(nodeCircle);\n\n      return group;\n    }\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 68:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.svg.labels');\n\n  /**\n   * The default label renderer. It renders the label as a simple text.\n   */\n  sigma.svg.labels.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node       The node object.\n     * @param  {configurable}             settings   The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'],\n          text = document.createElementNS(settings('xmlns'), 'text');\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      var fontColor = (settings('labelColor') === 'node') ?\n        (node.color || settings('defaultNodeColor')) :\n        settings('defaultLabelColor');\n\n      text.setAttributeNS(null, 'data-label-target', node.id);\n      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');\n      text.setAttributeNS(null, 'font-size', fontSize);\n      text.setAttributeNS(null, 'font-family', settings('font'));\n      text.setAttributeNS(null, 'fill', fontColor);\n\n      text.innerHTML = node.label;\n      text.textContent = node.label;\n\n      return text;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               text     The label DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, text, settings) {\n      var prefix = settings('prefix') || '',\n          size = node[prefix + 'size'];\n\n      var fontSize = (settings('labelSize') === 'fixed') ?\n        settings('defaultLabelSize') :\n        settings('labelSizeRatio') * size;\n\n      // Case when we don't want to display the label\n      if (!settings('forceLabels') && size < settings('labelThreshold'))\n        return;\n\n      if (typeof node.label !== 'string')\n        return;\n\n      // Updating\n      text.setAttributeNS(null, 'x',\n        Math.round(node[prefix + 'x'] + size + 3));\n      text.setAttributeNS(null, 'y',\n        Math.round(node[prefix + 'y'] + fontSize / 3));\n\n      // Showing\n      text.style.display = '';\n\n      return this;\n    }\n  };\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 69:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.nodes');\n\n  /**\n   * The default node renderer. It renders the node as a simple disc.\n   */\n  sigma.svg.nodes.def = {\n\n    /**\n     * SVG Element creation.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {configurable}             settings The settings function.\n     */\n    create: function(node, settings) {\n      var prefix = settings('prefix') || '',\n          circle = document.createElementNS(settings('xmlns'), 'circle');\n\n      // Defining the node's circle\n      circle.setAttributeNS(null, 'data-node-id', node.id);\n      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');\n      circle.setAttributeNS(\n        null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Returning the DOM Element\n      return circle;\n    },\n\n    /**\n     * SVG Element update.\n     *\n     * @param  {object}                   node     The node object.\n     * @param  {DOMElement}               circle   The node DOM element.\n     * @param  {configurable}             settings The settings function.\n     */\n    update: function(node, circle, settings) {\n      var prefix = settings('prefix') || '';\n\n      // Applying changes\n      // TODO: optimize - check if necessary\n      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);\n      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);\n      circle.setAttributeNS(null, 'r', node[prefix + 'size']);\n\n      // Updating only if not freestyle\n      if (!settings('freeStyle'))\n        circle.setAttributeNS(\n          null, 'fill', node.color || settings('defaultNodeColor'));\n\n      // Showing\n      circle.style.display = '';\n\n      return this;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 70:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.svg.utils');\n\n  /**\n   * Some useful functions used by sigma's SVG renderer.\n   */\n  sigma.svg.utils = {\n\n    /**\n     * SVG Element show.\n     *\n     * @param  {DOMElement}               element   The DOM element to show.\n     */\n    show: function(element) {\n      element.style.display = '';\n      return this;\n    },\n\n    /**\n     * SVG Element hide.\n     *\n     * @param  {DOMElement}               element   The DOM element to hide.\n     */\n    hide: function(element) {\n      element.style.display = 'none';\n      return this;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 83:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_sigma_renderers_svg_js__ = __webpack_require__(63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_sigma_renderers_svg_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_sigma_renderers_svg_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_svg_sigma_svg_utils_js__ = __webpack_require__(70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_svg_sigma_svg_utils_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_svg_sigma_svg_utils_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_svg_sigma_svg_nodes_def_js__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_svg_sigma_svg_nodes_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_svg_sigma_svg_nodes_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_svg_sigma_svg_edges_def_js__ = __webpack_require__(66);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_svg_sigma_svg_edges_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_svg_sigma_svg_edges_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_svg_sigma_svg_edges_curve_js__ = __webpack_require__(65);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_svg_sigma_svg_edges_curve_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_svg_sigma_svg_edges_curve_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_svg_sigma_svg_labels_def_js__ = __webpack_require__(68);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_svg_sigma_svg_labels_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_svg_sigma_svg_labels_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_src_renderers_svg_sigma_svg_hovers_def_js__ = __webpack_require__(67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_src_renderers_svg_sigma_svg_hovers_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_sigma_react_src_renderers_svg_sigma_svg_hovers_def_js__);\n\n\n\n\n\n\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/svg.js\n// module id = ./node_modules/react-sigma/sigma/svg.js\n// module chunks = 4","var Sigma =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 84);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 62:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(global) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  // Check if WebGL is enabled:\n  var canvas,\n      webgl = !!global.WebGLRenderingContext;\n  if (webgl) {\n    canvas = document.createElement('canvas');\n    try {\n      webgl = !!(\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl')\n      );\n    } catch (e) {\n      webgl = false;\n    }\n  }\n\n  // Copy the good renderer:\n  sigma.renderers.def = webgl ?\n    sigma.renderers.webgl :\n    sigma.renderers.canvas;\n})(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 64:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function(undefined) {\n  'use strict';\n\n  if (typeof sigma === 'undefined')\n    throw 'sigma is not declared';\n\n  // Initialize packages:\n  sigma.utils.pkg('sigma.renderers');\n\n  /**\n   * This function is the constructor of the canvas sigma's renderer.\n   *\n   * @param  {sigma.classes.graph}            graph    The graph to render.\n   * @param  {sigma.classes.camera}           camera   The camera.\n   * @param  {configurable}           settings The sigma instance settings\n   *                                           function.\n   * @param  {object}                 object   The options object.\n   * @return {sigma.renderers.canvas}          The renderer instance.\n   */\n  sigma.renderers.webgl = function(graph, camera, settings, options) {\n    if (typeof options !== 'object')\n      throw 'sigma.renderers.webgl: Wrong arguments.';\n\n    if (!(options.container instanceof HTMLElement))\n      throw 'Container not found.';\n\n    var k,\n        i,\n        l,\n        a,\n        fn,\n        _self = this;\n\n    sigma.classes.dispatcher.extend(this);\n\n    // Conrad related attributes:\n    this.jobs = {};\n\n    Object.defineProperty(this, 'conradId', {\n      value: sigma.utils.id()\n    });\n\n    // Initialize main attributes:\n    this.graph = graph;\n    this.camera = camera;\n    this.contexts = {};\n    this.domElements = {};\n    this.options = options;\n    this.container = this.options.container;\n    this.settings = (\n        typeof options.settings === 'object' &&\n        options.settings\n      ) ?\n        settings.embedObjects(options.settings) :\n        settings;\n\n    // Find the prefix:\n    this.options.prefix = this.camera.readPrefix;\n\n    // Initialize programs hash\n    Object.defineProperty(this, 'nodePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgePrograms', {\n      value: {}\n    });\n    Object.defineProperty(this, 'nodeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeFloatArrays', {\n      value: {}\n    });\n    Object.defineProperty(this, 'edgeIndicesArrays', {\n      value: {}\n    });\n\n    // Initialize the DOM elements:\n    if (this.settings(options, 'batchEdgesDrawing')) {\n      this.initDOM('canvas', 'edges', true);\n      this.initDOM('canvas', 'nodes', true);\n    } else {\n      this.initDOM('canvas', 'scene', true);\n      this.contexts.nodes = this.contexts.scene;\n      this.contexts.edges = this.contexts.scene;\n    }\n\n    this.initDOM('canvas', 'labels');\n    this.initDOM('canvas', 'mouse');\n    this.contexts.hover = this.contexts.mouse;\n\n    // Initialize captors:\n    this.captors = [];\n    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];\n    for (i = 0, l = a.length; i < l; i++) {\n      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];\n      this.captors.push(\n        new fn(\n          this.domElements.mouse,\n          this.camera,\n          this.settings\n        )\n      );\n    }\n\n    // Deal with sigma events:\n    sigma.misc.bindEvents.call(this, this.camera.prefix);\n    sigma.misc.drawHovers.call(this, this.camera.prefix);\n\n    this.resize();\n  };\n\n\n\n\n  /**\n   * This method will generate the nodes and edges float arrays. This step is\n   * separated from the \"render\" method, because to keep WebGL efficient, since\n   * all the camera and middlewares are modelised as matrices and they do not\n   * require the float arrays to be regenerated.\n   *\n   * Basically, when the user moves the camera or applies some specific linear\n   * transformations, this process step will be skipped, and the \"render\"\n   * method will efficiently refresh the rendering.\n   *\n   * And when the user modifies the graph colors or positions (applying a new\n   * layout or filtering the colors, for instance), this \"process\" step will be\n   * required to regenerate the float arrays.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.process = function() {\n    var a,\n        i,\n        l,\n        k,\n        type,\n        renderer,\n        graph = this.graph,\n        options = sigma.utils.extend(options, this.options),\n        defaultEdgeType = this.settings(options, 'defaultEdgeType'),\n        defaultNodeType = this.settings(options, 'defaultNodeType');\n\n    // Empty float arrays:\n    for (k in this.nodeFloatArrays)\n      delete this.nodeFloatArrays[k];\n\n    for (k in this.edgeFloatArrays)\n      delete this.edgeFloatArrays[k];\n\n    for (k in this.edgeIndicesArrays)\n      delete this.edgeIndicesArrays[k];\n\n    // Sort edges and nodes per types:\n    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultEdgeType;\n      k = (type && sigma.webgl.edges[type]) ? type : 'def';\n\n      if (!this.edgeFloatArrays[k])\n        this.edgeFloatArrays[k] = {\n          edges: []\n        };\n\n      this.edgeFloatArrays[k].edges.push(a[i]);\n    }\n\n    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {\n      type = a[i].type || defaultNodeType;\n      k = (type && sigma.webgl.nodes[type]) ? type : 'def';\n\n      if (!this.nodeFloatArrays[k])\n        this.nodeFloatArrays[k] = {\n          nodes: []\n        };\n\n      this.nodeFloatArrays[k].nodes.push(a[i]);\n    }\n\n    // Push edges:\n    for (k in this.edgeFloatArrays) {\n      renderer = sigma.webgl.edges[k];\n      a = this.edgeFloatArrays[k].edges;\n\n      // Creating the necessary arrays\n      this.edgeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden &&\n          !graph.nodes(a[i].source).hidden &&\n          !graph.nodes(a[i].target).hidden\n        )\n          renderer.addEdge(\n            a[i],\n            graph.nodes(a[i].source),\n            graph.nodes(a[i].target),\n            this.edgeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n\n      if (typeof renderer.computeIndices === 'function')\n        this.edgeIndicesArrays[k] = renderer.computeIndices(\n          this.edgeFloatArrays[k].array\n        );\n    }\n\n    // Push nodes:\n    for (k in this.nodeFloatArrays) {\n      renderer = sigma.webgl.nodes[k];\n      a = this.nodeFloatArrays[k].nodes;\n\n      // Creating the necessary arrays\n      this.nodeFloatArrays[k].array = new Float32Array(\n        a.length * renderer.POINTS * renderer.ATTRIBUTES\n      );\n\n      for (i = 0, l = a.length; i < l; i++) {\n        if (!this.nodeFloatArrays[k].array)\n          this.nodeFloatArrays[k].array = new Float32Array(\n            a.length * renderer.POINTS * renderer.ATTRIBUTES\n          );\n\n        // Just check that the edge and both its extremities are visible:\n        if (\n          !a[i].hidden\n        )\n          renderer.addNode(\n            a[i],\n            this.nodeFloatArrays[k].array,\n            i * renderer.POINTS * renderer.ATTRIBUTES,\n            options.prefix,\n            this.settings\n          );\n      }\n    }\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method renders the graph. It basically calls each program (and\n   * generate them if they do not exist yet) to render nodes and edges, batched\n   * per renderer.\n   *\n   * As in the canvas renderer, it is possible to display edges, nodes and / or\n   * labels in batches, to make the whole thing way more scalable.\n   *\n   * @param  {?object}               params Eventually an object of options.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.render = function(params) {\n    var a,\n        i,\n        l,\n        k,\n        o,\n        program,\n        renderer,\n        self = this,\n        graph = this.graph,\n        nodesGl = this.contexts.nodes,\n        edgesGl = this.contexts.edges,\n        matrix = this.camera.getMatrix(),\n        options = sigma.utils.extend(params, this.options),\n        drawLabels = this.settings(options, 'drawLabels'),\n        drawEdges = this.settings(options, 'drawEdges'),\n        drawNodes = this.settings(options, 'drawNodes');\n\n    // Call the resize function:\n    this.resize(false);\n\n    // Check the 'hideEdgesOnMove' setting:\n    if (this.settings(options, 'hideEdgesOnMove'))\n      if (this.camera.isAnimated || this.camera.isMoving)\n        drawEdges = false;\n\n    // Clear canvases:\n    this.clear();\n\n    // Translate matrix to [width/2, height/2]:\n    matrix = sigma.utils.matrices.multiply(\n      matrix,\n      sigma.utils.matrices.translation(this.width / 2, this.height / 2)\n    );\n\n    // Kill running jobs:\n    for (k in this.jobs)\n      if (conrad.hasJob(k))\n        conrad.killJob(k);\n\n    if (drawEdges) {\n      if (this.settings(options, 'batchEdgesDrawing'))\n        (function() {\n          var a,\n              k,\n              i,\n              id,\n              job,\n              arr,\n              end,\n              start,\n              indices,\n              renderer,\n              batchSize,\n              currentProgram;\n\n          id = 'edges_' + this.conradId;\n          batchSize = this.settings(options, 'webglEdgesBatchSize');\n          a = Object.keys(this.edgeFloatArrays);\n\n          if (!a.length)\n            return;\n          i = 0;\n          renderer = sigma.webgl.edges[a[i]];\n          arr = this.edgeFloatArrays[a[i]].array;\n          indices = this.edgeIndicesArrays[a[i]];\n          start = 0;\n          end = Math.min(\n            start + batchSize * renderer.POINTS,\n            arr.length / renderer.ATTRIBUTES\n          );\n\n          job = function() {\n            // Check program:\n            if (!this.edgePrograms[a[i]])\n              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);\n\n            if (start < end) {\n              edgesGl.useProgram(this.edgePrograms[a[i]]);\n              renderer.render(\n                edgesGl,\n                this.edgePrograms[a[i]],\n                arr,\n                {\n                  settings: this.settings,\n                  matrix: matrix,\n                  width: this.width,\n                  height: this.height,\n                  ratio: this.camera.ratio,\n                  scalingRatio: this.settings(\n                    options,\n                    'webglOversamplingRatio'\n                  ),\n                  start: start,\n                  count: end - start,\n                  indicesData: indices\n                }\n              );\n            }\n\n            // Catch job's end:\n            if (\n              end >= arr.length / renderer.ATTRIBUTES &&\n              i === a.length - 1\n            ) {\n              delete this.jobs[id];\n              return false;\n            }\n\n            if (end >= arr.length / renderer.ATTRIBUTES) {\n              i++;\n              arr = this.edgeFloatArrays[a[i]].array;\n              renderer = sigma.webgl.edges[a[i]];\n              start = 0;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            } else {\n              start = end;\n              end = Math.min(\n                start + batchSize * renderer.POINTS,\n                arr.length / renderer.ATTRIBUTES\n              );\n            }\n\n            return true;\n          };\n\n          this.jobs[id] = job;\n          conrad.addJob(id, job.bind(this));\n        }).call(this);\n      else {\n        for (k in this.edgeFloatArrays) {\n          renderer = sigma.webgl.edges[k];\n\n          // Check program:\n          if (!this.edgePrograms[k])\n            this.edgePrograms[k] = renderer.initProgram(edgesGl);\n\n          // Render\n          if (this.edgeFloatArrays[k]) {\n            edgesGl.useProgram(this.edgePrograms[k]);\n            renderer.render(\n              edgesGl,\n              this.edgePrograms[k],\n              this.edgeFloatArrays[k].array,\n              {\n                settings: this.settings,\n                matrix: matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                scalingRatio: this.settings(options, 'webglOversamplingRatio'),\n                indicesData: this.edgeIndicesArrays[k]\n              }\n            );\n          }\n        }\n      }\n    }\n\n    if (drawNodes) {\n      // Enable blending:\n      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);\n      nodesGl.enable(nodesGl.BLEND);\n\n      for (k in this.nodeFloatArrays) {\n        renderer = sigma.webgl.nodes[k];\n\n        // Check program:\n        if (!this.nodePrograms[k])\n          this.nodePrograms[k] = renderer.initProgram(nodesGl);\n\n        // Render\n        if (this.nodeFloatArrays[k]) {\n          nodesGl.useProgram(this.nodePrograms[k]);\n          renderer.render(\n            nodesGl,\n            this.nodePrograms[k],\n            this.nodeFloatArrays[k].array,\n            {\n              settings: this.settings,\n              matrix: matrix,\n              width: this.width,\n              height: this.height,\n              ratio: this.camera.ratio,\n              scalingRatio: this.settings(options, 'webglOversamplingRatio')\n            }\n          );\n        }\n      }\n    }\n\n    if (drawLabels) {\n      a = this.camera.quadtree.area(\n        this.camera.getRectangle(this.width, this.height)\n      );\n\n      // Apply camera view to these nodes:\n      this.camera.applyView(\n        undefined,\n        undefined,\n        {\n          nodes: a,\n          edges: [],\n          width: this.width,\n          height: this.height\n        }\n      );\n\n      o = function(key) {\n        return self.settings({\n          prefix: self.camera.prefix\n        }, key);\n      };\n\n      for (i = 0, l = a.length; i < l; i++)\n        if (!a[i].hidden)\n          (\n            sigma.canvas.labels[\n              a[i].type ||\n              this.settings(options, 'defaultNodeType')\n            ] || sigma.canvas.labels.def\n          )(a[i], this.contexts.labels, o);\n    }\n\n    this.dispatchEvent('render');\n\n    return this;\n  };\n\n\n\n\n  /**\n   * This method creates a DOM element of the specified type, switches its\n   * position to \"absolute\", references it to the domElements attribute, and\n   * finally appends it to the container.\n   *\n   * @param  {string}   tag   The label tag.\n   * @param  {string}   id    The id of the element (to store it in\n   *                          \"domElements\").\n   * @param  {?boolean} webgl Will init the WebGL context if true.\n   */\n  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {\n    var gl,\n        dom = document.createElement(tag),\n        self = this;\n\n    dom.style.position = 'absolute';\n    dom.setAttribute('class', 'sigma-' + id);\n\n    this.domElements[id] = dom;\n    this.container.appendChild(dom);\n\n    if (tag.toLowerCase() === 'canvas') {\n      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {\n        preserveDrawingBuffer: true\n      });\n\n      // Adding webgl context loss listeners\n      if (webgl) {\n        dom.addEventListener('webglcontextlost', function(e) {\n          e.preventDefault();\n        }, false);\n\n        dom.addEventListener('webglcontextrestored', function(e) {\n          self.render();\n        }, false);\n      }\n    }\n  };\n\n  /**\n   * This method resizes each DOM elements in the container and stores the new\n   * dimensions. Then, it renders the graph.\n   *\n   * @param  {?number}               width  The new width of the container.\n   * @param  {?number}               height The new height of the container.\n   * @return {sigma.renderers.webgl}        Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.resize = function(w, h) {\n    var k,\n        oldWidth = this.width,\n        oldHeight = this.height,\n        pixelRatio = sigma.utils.getPixelRatio();\n\n    if (w !== undefined && h !== undefined) {\n      this.width = w;\n      this.height = h;\n    } else {\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n\n      w = this.width;\n      h = this.height;\n    }\n\n    if (oldWidth !== this.width || oldHeight !== this.height) {\n      for (k in this.domElements) {\n        this.domElements[k].style.width = w + 'px';\n        this.domElements[k].style.height = h + 'px';\n\n        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {\n          // If simple 2D canvas:\n          if (this.contexts[k] && this.contexts[k].scale) {\n            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');\n            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');\n\n            if (pixelRatio !== 1)\n              this.contexts[k].scale(pixelRatio, pixelRatio);\n          } else {\n            this.domElements[k].setAttribute(\n              'width',\n              (w * this.settings('webglOversamplingRatio')) + 'px'\n            );\n            this.domElements[k].setAttribute(\n              'height',\n              (h * this.settings('webglOversamplingRatio')) + 'px'\n            );\n          }\n        }\n      }\n    }\n\n    // Scale:\n    for (k in this.contexts)\n      if (this.contexts[k] && this.contexts[k].viewport)\n        this.contexts[k].viewport(\n          0,\n          0,\n          this.width * this.settings('webglOversamplingRatio'),\n          this.height * this.settings('webglOversamplingRatio')\n        );\n\n    return this;\n  };\n\n  /**\n   * This method clears each canvas.\n   *\n   * @return {sigma.renderers.webgl} Returns the instance itself.\n   */\n  sigma.renderers.webgl.prototype.clear = function() {\n    this.contexts.labels.clearRect(0, 0, this.width, this.height);\n    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n\n    return this;\n  };\n\n  /**\n   * This method kills contexts and other attributes.\n   */\n  sigma.renderers.webgl.prototype.kill = function() {\n    var k,\n        captor;\n\n    // Kill captors:\n    while ((captor = this.captors.pop()))\n      captor.kill();\n    delete this.captors;\n\n    // Kill contexts:\n    for (k in this.domElements) {\n      this.domElements[k].parentNode.removeChild(this.domElements[k]);\n      delete this.domElements[k];\n      delete this.contexts[k];\n    }\n    delete this.domElements;\n    delete this.contexts;\n  };\n\n\n\n\n  /**\n   * The object \"sigma.webgl.nodes\" contains the different WebGL node\n   * renderers. The default one draw nodes as discs. Here are the attributes\n   * any node renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw a node.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addNode     A function that adds a node to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       node\n   *                        > {number}       index   The node index in the\n   *                                                 nodes array.\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the nodes\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n\n\n\n  /**\n   * The object \"sigma.webgl.edges\" contains the different WebGL edge\n   * renderers. The default one draw edges as direct lines. Here are the\n   * attributes any edge renderer must have:\n   *\n   * {number}   POINTS      The number of points required to draw an edge.\n   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.\n   * {function} addEdge     A function that adds an edge to the data stack that\n   *                        will be given to the buffer. Here is the arguments:\n   *                        > {object}       edge\n   *                        > {object}       source\n   *                        > {object}       target\n   *                        > {Float32Array} data    The stack.\n   *                        > {object}       options Some options.\n   * {function} render      The function that will effectively render the edges\n   *                        into the buffer.\n   *                        > {WebGLRenderingContext} gl\n   *                        > {WebGLProgram}          program\n   *                        > {Float32Array} data    The stack to give to the\n   *                                                 buffer.\n   *                        > {object}       params  An object containing some\n   *                                                 options, like width,\n   *                                                 height, the camera ratio.\n   * {function} initProgram The function that will initiate the program, with\n   *                        the relevant shaders and parameters. It must return\n   *                        the newly created program.\n   *\n   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it\n   * works more precisely.\n   */\n  sigma.utils.pkg('sigma.webgl.edges');\n\n\n\n\n  /**\n   * The object \"sigma.canvas.labels\" contains the different\n   * label renderers for the WebGL renderer. Since displaying texts in WebGL is\n   * definitely painful and since there a way less labels to display than nodes\n   * or edges, the default renderer simply renders them in a canvas.\n   *\n   * A labels renderer is a simple function, taking as arguments the related\n   * node, the renderer and a settings function.\n   */\n  sigma.utils.pkg('sigma.canvas.labels');\n}).call(this);\n\n}.call(window));\n\n/***/ }),\n\n/***/ 71:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as arrows going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing\n   * mode.\n   *\n   * It is expensive, since drawing a single edge requires 9 points, each\n   * having a lot of attributes.\n   */\n  sigma.webgl.edges.arrow = {\n    POINTS: 9,\n    ATTRIBUTES: 11,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          targetSize = target[prefix + 'size'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      // Arrow head:\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = -1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = targetSize;\n      data[i++] = 1.0;\n      data[i++] = 0.0;\n      data[i++] = 1.0;\n      data[i++] = 1.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation1 =\n            gl.getAttribLocation(program, 'a_pos1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_pos2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          targetSizeLocation =\n            gl.getAttribLocation(program, 'a_tSize'),\n          delayLocation =\n            gl.getAttribLocation(program, 'a_delay'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          headLocation =\n            gl.getAttribLocation(program, 'a_head'),\n          headPositionLocation =\n            gl.getAttribLocation(program, 'a_headPosition'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          nodeRatioLocation =\n            gl.getUniformLocation(program, 'u_nodeRatio'),\n          arrowHeadLocation =\n            gl.getUniformLocation(program, 'u_arrowHead'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(\n        nodeRatioLocation,\n        Math.pow(params.ratio, params.settings('nodesPowRatio')) /\n        params.ratio\n      );\n      gl.uniform1f(arrowHeadLocation, 5.0);\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(targetSizeLocation);\n      gl.enableVertexAttribArray(delayLocation);\n      gl.enableVertexAttribArray(minusLocation);\n      gl.enableVertexAttribArray(headLocation);\n      gl.enableVertexAttribArray(headPositionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(targetSizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(delayLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        28\n      );\n      gl.vertexAttribPointer(headLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        32\n      );\n      gl.vertexAttribPointer(headPositionLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        36\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        40\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_pos1;',\n          'attribute vec2 a_pos2;',\n          'attribute float a_thickness;',\n          'attribute float a_tSize;',\n          'attribute float a_delay;',\n          'attribute float a_minus;',\n          'attribute float a_head;',\n          'attribute float a_headPosition;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_nodeRatio;',\n          'uniform float u_arrowHead;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 pos = normalize(a_pos2 - a_pos1);',\n\n            'mat2 matrix = (1.0 - a_head) *',\n              '(',\n                'a_minus * u_matrixHalfPiMinus +',\n                '(1.0 - a_minus) * u_matrixHalfPi',\n              ') + a_head * (',\n                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',\n                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',\n              ');',\n\n            'pos = a_pos1 + (',\n              // Deal with body:\n              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',\n              // Deal with head:\n              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',\n              // Deal with delay:\n              'a_delay * pos * (',\n                'a_tSize / u_nodeRatio +',\n                'u_arrowHead * a_thickness * u_ratio',\n              ')',\n            ');',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(pos, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 72:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines going from the source node\n   * to the target node. To deal with edge thicknesses, the lines are made of\n   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.\n   *\n   * It is expensive, since drawing a single edge requires 6 points, each\n   * having 7 attributes (source position, target position, thickness, color\n   * and a flag indicating which vertice of the rectangle it is).\n   */\n  sigma.webgl.edges.def = {\n    POINTS: 6,\n    ATTRIBUTES: 7,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 1.0;\n      data[i++] = color;\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = w;\n      data[i++] = 0.0;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation1 =\n            gl.getAttribLocation(program, 'a_position1'),\n          positionLocation2 =\n            gl.getAttribLocation(program, 'a_position2'),\n          thicknessLocation =\n            gl.getAttribLocation(program, 'a_thickness'),\n          minusLocation =\n            gl.getAttribLocation(program, 'a_minus'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          matrixHalfPiLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPi'),\n          matrixHalfPiMinusLocation =\n            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n      gl.uniformMatrix2fv(\n        matrixHalfPiLocation,\n        false,\n        sigma.utils.matrices.rotation(Math.PI / 2, true)\n      );\n      gl.uniformMatrix2fv(\n        matrixHalfPiMinusLocation,\n        false,\n        sigma.utils.matrices.rotation(-Math.PI / 2, true)\n      );\n\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(positionLocation1);\n      gl.enableVertexAttribArray(positionLocation2);\n      gl.enableVertexAttribArray(thicknessLocation);\n      gl.enableVertexAttribArray(minusLocation);\n\n      gl.vertexAttribPointer(positionLocation1,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(positionLocation2,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(thicknessLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n      gl.vertexAttribPointer(minusLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        20\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        24\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position1;',\n          'attribute vec2 a_position2;',\n          'attribute float a_thickness;',\n          'attribute float a_minus;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n          'uniform mat2 u_matrixHalfPi;',\n          'uniform mat2 u_matrixHalfPiMinus;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Find the good point:\n            'vec2 position = a_thickness * u_ratio *',\n              'normalize(a_position2 - a_position1);',\n\n            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',\n              '(1.0 - a_minus) * u_matrixHalfPi;',\n\n            'position = matrix * position + a_position1;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 73:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.edges');\n\n  /**\n   * This edge renderer will display edges as lines with the gl.LINES display\n   * mode. Since this mode does not support well thickness, edges are all drawn\n   * with the same thickness (3px), independantly of the edge attributes or the\n   * zooming ratio.\n   */\n  sigma.webgl.edges.fast = {\n    POINTS: 2,\n    ATTRIBUTES: 3,\n    addEdge: function(edge, source, target, data, i, prefix, settings) {\n      var w = (edge[prefix + 'size'] || 1) / 2,\n          x1 = source[prefix + 'x'],\n          y1 = source[prefix + 'y'],\n          x2 = target[prefix + 'x'],\n          y2 = target[prefix + 'y'],\n          color = edge.color;\n\n      if (!color)\n        switch (settings('edgeColor')) {\n          case 'source':\n            color = source.color || settings('defaultNodeColor');\n            break;\n          case 'target':\n            color = target.color || settings('defaultNodeColor');\n            break;\n          default:\n            color = settings('defaultEdgeColor');\n            break;\n        }\n\n      // Normalize color:\n      color = sigma.utils.floatColor(color);\n\n      data[i++] = x1;\n      data[i++] = y1;\n      data[i++] = color;\n\n      data[i++] = x2;\n      data[i++] = y2;\n      data[i++] = color;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n\n      gl.lineWidth(3);\n      gl.drawArrays(\n        gl.LINES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'gl_FragColor = color;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 74:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes as discs, shaped in triangles with\n   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,\n   * it will store three times the center of node, with the color and the size,\n   * and an angle indicating which \"corner\" of the triangle to draw.\n   *\n   * The fragment shader does not deal with anti-aliasing, so make sure that\n   * you deal with it somewhere else in the code (by default, the WebGL\n   * renderer will oversample the rendering through the webglOversamplingRatio\n   * value).\n   */\n  sigma.webgl.nodes.def = {\n    POINTS: 3,\n    ATTRIBUTES: 5,\n    addNode: function(node, data, i, prefix, settings) {\n      var color = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 0;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 2 * Math.PI / 3;\n\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = color;\n      data[i++] = 4 * Math.PI / 3;\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          angleLocation =\n            gl.getAttribLocation(program, 'a_angle'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n      gl.enableVertexAttribArray(angleLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n      gl.vertexAttribPointer(\n        angleLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        16\n      );\n\n      gl.drawArrays(\n        gl.TRIANGLES,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n          'attribute float a_angle;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main() {',\n            // Multiply the point size twice:\n            'radius = a_size * u_ratio;',\n\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',\n            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n            'center = position * u_scale;',\n            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',\n\n            'position = position +',\n              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',\n            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',\n\n            'radius = radius * u_scale;',\n\n            'gl_Position = vec4(position, 0, 1);',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n          'varying vec2 center;',\n          'varying float radius;',\n\n          'void main(void) {',\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n\n            'vec2 m = gl_FragCoord.xy - center;',\n            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            // Here is how we draw a disc instead of a square:\n            'if (diff > 0.0)',\n              'gl_FragColor = color;',\n            'else',\n              'gl_FragColor = color0;',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 75:\n/***/ (function(module, exports) {\n\n/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n;(function() {\n  'use strict';\n\n  sigma.utils.pkg('sigma.webgl.nodes');\n\n  /**\n   * This node renderer will display nodes in the fastest way: Nodes are basic\n   * squares, drawn through the gl.POINTS drawing method. The size of the nodes\n   * are represented with the \"gl_PointSize\" value in the vertex shader.\n   *\n   * It is the fastest node renderer here since the buffer just takes one line\n   * to draw each node (with attributes \"x\", \"y\", \"size\" and \"color\").\n   *\n   * Nevertheless, this method has some problems, especially due to some issues\n   * with the gl.POINTS:\n   *  - First, if the center of a node is outside the scene, the point will not\n   *    be drawn, even if it should be partly on screen.\n   *  - I tried applying a fragment shader similar to the one in the default\n   *    node renderer to display them as discs, but it did not work fine on\n   *    some computers settings, filling the discs with weird gradients not\n   *    depending on the actual color.\n   */\n  sigma.webgl.nodes.fast = {\n    POINTS: 1,\n    ATTRIBUTES: 4,\n    addNode: function(node, data, i, prefix, settings) {\n      data[i++] = node[prefix + 'x'];\n      data[i++] = node[prefix + 'y'];\n      data[i++] = node[prefix + 'size'];\n      data[i++] = sigma.utils.floatColor(\n        node.color || settings('defaultNodeColor')\n      );\n    },\n    render: function(gl, program, data, params) {\n      var buffer;\n\n      // Define attributes:\n      var positionLocation =\n            gl.getAttribLocation(program, 'a_position'),\n          sizeLocation =\n            gl.getAttribLocation(program, 'a_size'),\n          colorLocation =\n            gl.getAttribLocation(program, 'a_color'),\n          resolutionLocation =\n            gl.getUniformLocation(program, 'u_resolution'),\n          matrixLocation =\n            gl.getUniformLocation(program, 'u_matrix'),\n          ratioLocation =\n            gl.getUniformLocation(program, 'u_ratio'),\n          scaleLocation =\n            gl.getUniformLocation(program, 'u_scale');\n\n      buffer = gl.createBuffer();\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\n\n      gl.uniform2f(resolutionLocation, params.width, params.height);\n      gl.uniform1f(\n        ratioLocation,\n        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))\n      );\n      gl.uniform1f(scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);\n\n      gl.enableVertexAttribArray(positionLocation);\n      gl.enableVertexAttribArray(sizeLocation);\n      gl.enableVertexAttribArray(colorLocation);\n\n      gl.vertexAttribPointer(\n        positionLocation,\n        2,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        0\n      );\n      gl.vertexAttribPointer(\n        sizeLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        8\n      );\n      gl.vertexAttribPointer(\n        colorLocation,\n        1,\n        gl.FLOAT,\n        false,\n        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,\n        12\n      );\n\n      gl.drawArrays(\n        gl.POINTS,\n        params.start || 0,\n        params.count || (data.length / this.ATTRIBUTES)\n      );\n    },\n    initProgram: function(gl) {\n      var vertexShader,\n          fragmentShader,\n          program;\n\n      vertexShader = sigma.utils.loadShader(\n        gl,\n        [\n          'attribute vec2 a_position;',\n          'attribute float a_size;',\n          'attribute float a_color;',\n\n          'uniform vec2 u_resolution;',\n          'uniform float u_ratio;',\n          'uniform float u_scale;',\n          'uniform mat3 u_matrix;',\n\n          'varying vec4 color;',\n\n          'void main() {',\n            // Scale from [[-1 1] [-1 1]] to the container:\n            'gl_Position = vec4(',\n              '((u_matrix * vec3(a_position, 1)).xy /',\n                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',\n              '0,',\n              '1',\n            ');',\n\n            // Multiply the point size twice:\n            //  - x SCALING_RATIO to correct the canvas scaling\n            //  - x 2 to correct the formulae\n            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',\n\n            // Extract the color:\n            'float c = a_color;',\n            'color.b = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.g = mod(c, 256.0); c = floor(c / 256.0);',\n            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',\n            'color.a = 1.0;',\n          '}'\n        ].join('\\n'),\n        gl.VERTEX_SHADER\n      );\n\n      fragmentShader = sigma.utils.loadShader(\n        gl,\n        [\n          'precision mediump float;',\n\n          'varying vec4 color;',\n\n          'void main(void) {',\n            'float border = 0.01;',\n            'float radius = 0.5;',\n\n            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',\n            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',\n            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',\n\n            'float t = 0.0;',\n            'if (dist > border)',\n              't = 1.0;',\n            'else if (dist > 0.0)',\n              't = dist / border;',\n\n            'gl_FragColor = mix(color0, color, t);',\n          '}'\n        ].join('\\n'),\n        gl.FRAGMENT_SHADER\n      );\n\n      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);\n\n      return program;\n    }\n  };\n})();\n\n}.call(window));\n\n/***/ }),\n\n/***/ 84:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_sigma_renderers_webgl_js__ = __webpack_require__(64);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_sigma_renderers_webgl_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_sigma_react_src_renderers_sigma_renderers_webgl_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_sigma_renderers_def_js__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_sigma_renderers_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_sigma_react_src_renderers_sigma_renderers_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_webgl_sigma_webgl_nodes_def_js__ = __webpack_require__(74);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_webgl_sigma_webgl_nodes_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_sigma_react_src_renderers_webgl_sigma_webgl_nodes_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_webgl_sigma_webgl_nodes_fast_js__ = __webpack_require__(75);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_webgl_sigma_webgl_nodes_fast_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_sigma_react_src_renderers_webgl_sigma_webgl_nodes_fast_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_webgl_sigma_webgl_edges_def_js__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_webgl_sigma_webgl_edges_def_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_sigma_react_src_renderers_webgl_sigma_webgl_edges_def_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_webgl_sigma_webgl_edges_fast_js__ = __webpack_require__(73);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_webgl_sigma_webgl_edges_fast_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_sigma_react_src_renderers_webgl_sigma_webgl_edges_fast_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_src_renderers_webgl_sigma_webgl_edges_arrow_js__ = __webpack_require__(71);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_sigma_react_src_renderers_webgl_sigma_webgl_edges_arrow_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_sigma_react_src_renderers_webgl_sigma_webgl_edges_arrow_js__);\n\n\n\n\n\n\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/react-sigma/sigma/webgl.js\n// module id = ./node_modules/react-sigma/sigma/webgl.js\n// module chunks = 4"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAFA;AAMA;AACA;;;AACA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;AAjCA;AACA;AADA;;;;;;;;;;;;AAAA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzhDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACniDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/nSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7vBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;A","sourceRoot":""}